// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceFirebaseHostingSiteConfig() *schema.Resource {
	return &schema.Resource{
		Create: resourceFirebaseHostingSiteConfigCreate,
		Read:   resourceFirebaseHostingSiteConfigRead,
		Update: resourceFirebaseHostingSiteConfigUpdate,
		Delete: resourceFirebaseHostingSiteConfigDelete,

		Importer: &schema.ResourceImporter{
			State: resourceFirebaseHostingSiteConfigImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"site_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Required. Immutable. A globally unique identifier for the Hosting site. This identifier is
used to construct the Firebase-provisioned subdomains for the site, so it must also be a valid
domain name label.`,
			},
			"cloud_logging_enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Whether or not web requests made by site visitors are logged via Cloud Logging.`,
			},
			"max_versions": {
				Type:     schema.TypeInt,
				Optional: true,
				Description: `The number of FINALIZED versions that will be held for a site before automatic deletion. When a new
version is deployed, content for versions in storage in excess of this number will be deleted, and
will no longer be billed for storage usage. Oldest versions will be deleted first; Default is 100`,
				Default: 100,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceFirebaseHostingSiteConfigCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	maxVersionsProp, err := expandFirebaseHostingSiteConfigMaxVersions(d.Get("max_versions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_versions"); !isEmptyValue(reflect.ValueOf(maxVersionsProp)) && (ok || !reflect.DeepEqual(v, maxVersionsProp)) {
		obj["maxVersions"] = maxVersionsProp
	}
	cloudLoggingEnabledProp, err := expandFirebaseHostingSiteConfigCloudLoggingEnabled(d.Get("cloud_logging_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cloud_logging_enabled"); !isEmptyValue(reflect.ValueOf(cloudLoggingEnabledProp)) && (ok || !reflect.DeepEqual(v, cloudLoggingEnabledProp)) {
		obj["cloudLoggingEnabled"] = cloudLoggingEnabledProp
	}

	url, err := replaceVars(d, config, "{{FirebaseHostingBasePath}}sites/{{site_id}}/config?update_mask=maxVersions,cloudLoggingEnabled")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new SiteConfig: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PATCH", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating SiteConfig: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "sites/{{site_id}}/config")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating SiteConfig %q: %#v", d.Id(), res)

	return resourceFirebaseHostingSiteConfigRead(d, meta)
}

func resourceFirebaseHostingSiteConfigRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{FirebaseHostingBasePath}}sites/{{site_id}}/config")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("FirebaseHostingSiteConfig %q", d.Id()))
	}

	if err := d.Set("max_versions", flattenFirebaseHostingSiteConfigMaxVersions(res["maxVersions"], d, config)); err != nil {
		return fmt.Errorf("Error reading SiteConfig: %s", err)
	}
	if err := d.Set("cloud_logging_enabled", flattenFirebaseHostingSiteConfigCloudLoggingEnabled(res["cloudLoggingEnabled"], d, config)); err != nil {
		return fmt.Errorf("Error reading SiteConfig: %s", err)
	}

	return nil
}

func resourceFirebaseHostingSiteConfigUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	obj := make(map[string]interface{})
	maxVersionsProp, err := expandFirebaseHostingSiteConfigMaxVersions(d.Get("max_versions"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_versions"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, maxVersionsProp)) {
		obj["maxVersions"] = maxVersionsProp
	}
	cloudLoggingEnabledProp, err := expandFirebaseHostingSiteConfigCloudLoggingEnabled(d.Get("cloud_logging_enabled"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("cloud_logging_enabled"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, cloudLoggingEnabledProp)) {
		obj["cloudLoggingEnabled"] = cloudLoggingEnabledProp
	}

	url, err := replaceVars(d, config, "{{FirebaseHostingBasePath}}sites/{{site_id}}/config")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating SiteConfig %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("max_versions") {
		updateMask = append(updateMask, "maxVersions")
	}

	if d.HasChange("cloud_logging_enabled") {
		updateMask = append(updateMask, "cloudLoggingEnabled")
	}
	// updateMask is a URL parameter but not present in the schema, so replaceVars
	// won't set it
	url, err = addQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PATCH", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating SiteConfig %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating SiteConfig %q: %#v", d.Id(), res)
	}

	return resourceFirebaseHostingSiteConfigRead(d, meta)
}

func resourceFirebaseHostingSiteConfigDelete(d *schema.ResourceData, meta interface{}) error {
	log.Printf("[WARNING] FirebaseHosting SiteConfig resources"+
		" cannot be deleted from Google Cloud. The resource %s will be removed from Terraform"+
		" state, but will still be present on Google Cloud.", d.Id())
	d.SetId("")

	return nil
}

func resourceFirebaseHostingSiteConfigImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"sites/(?P<site_id>[^/]+)/config",
		"(?P<site_id>[^/]+)/config",
		"(?P<site_id>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "sites/{{site_id}}/config")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenFirebaseHostingSiteConfigMaxVersions(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenFirebaseHostingSiteConfigCloudLoggingEnabled(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandFirebaseHostingSiteConfigMaxVersions(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseHostingSiteConfigCloudLoggingEnabled(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
