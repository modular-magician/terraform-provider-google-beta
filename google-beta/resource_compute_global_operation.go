// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"strconv"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func resourceComputeGlobalOperation() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeGlobalOperationCreate,
		Read:   resourceComputeGlobalOperationRead,
		Update: resourceComputeGlobalOperationUpdate,
		Delete: resourceComputeGlobalOperationDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeGlobalOperationImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(4 * time.Minute),
			Update: schema.DefaultTimeout(4 * time.Minute),
			Delete: schema.DefaultTimeout(4 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"client_operation_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The value of requestId if you provided it in the request. Not present otherwise.`,
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Name of the operation.`,
			},
			"operation_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The type of operation, such as insert, update, or delete, and so on.`,
			},
			"progress": {
				Type:        schema.TypeInt,
				Optional:    true,
				Description: `An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.`,
			},
			"status": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{"PENDING", "PENDING", "DONE", ""}, false),
				Description: `The status of the operation, which can be one of the following:
* PENDING
* PENDINGPENDING
* DONE Possible values: ["PENDING", "PENDING", "DONE"]`,
			},
			"status_message": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional textual description of the current status of the operation.`,
			},
			"user": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `User who requested the operation, for example: user@example.com.`,
			},
			"zone": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The URL of the zone where the operation resides. Only applicable when performing per-zone operations.`,
			},
			"creation_timestamp": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Creation timestamp in RFC3339 text format.This field is deprecated.`,
			},
			"description": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `An optional textual description of the resource.`,
			},
			"end_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time that this operation was completed. This value is in RFC3339 text format.`,
			},
			"id": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The unique identifier for the resource.`,
			},
			"insert_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time that this operation was requested. This value is in RFC3339 text format.`,
			},
			"start_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time that this operation was started by the server. This value is in RFC3339 text format.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"self_link": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeGlobalOperationCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandComputeGlobalOperationName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	zoneProp, err := expandComputeGlobalOperationZone(d.Get("zone"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("zone"); !isEmptyValue(reflect.ValueOf(zoneProp)) && (ok || !reflect.DeepEqual(v, zoneProp)) {
		obj["zone"] = zoneProp
	}
	clientOperationIdProp, err := expandComputeGlobalOperationClientOperationId(d.Get("client_operation_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_operation_id"); !isEmptyValue(reflect.ValueOf(clientOperationIdProp)) && (ok || !reflect.DeepEqual(v, clientOperationIdProp)) {
		obj["clientOperationId"] = clientOperationIdProp
	}
	operationTypeProp, err := expandComputeGlobalOperationOperationType(d.Get("operation_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("operation_type"); !isEmptyValue(reflect.ValueOf(operationTypeProp)) && (ok || !reflect.DeepEqual(v, operationTypeProp)) {
		obj["operationType"] = operationTypeProp
	}
	userProp, err := expandComputeGlobalOperationUser(d.Get("user"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("user"); !isEmptyValue(reflect.ValueOf(userProp)) && (ok || !reflect.DeepEqual(v, userProp)) {
		obj["user"] = userProp
	}
	progressProp, err := expandComputeGlobalOperationProgress(d.Get("progress"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("progress"); !isEmptyValue(reflect.ValueOf(progressProp)) && (ok || !reflect.DeepEqual(v, progressProp)) {
		obj["progress"] = progressProp
	}
	statusProp, err := expandComputeGlobalOperationStatus(d.Get("status"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("status"); !isEmptyValue(reflect.ValueOf(statusProp)) && (ok || !reflect.DeepEqual(v, statusProp)) {
		obj["status"] = statusProp
	}
	statusMessageProp, err := expandComputeGlobalOperationStatusMessage(d.Get("status_message"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("status_message"); !isEmptyValue(reflect.ValueOf(statusMessageProp)) && (ok || !reflect.DeepEqual(v, statusMessageProp)) {
		obj["statusMessage"] = statusMessageProp
	}

	url, err := replaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/operations")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new GlobalOperation: %#v", obj)
	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GlobalOperation: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating GlobalOperation: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{project}}/global/operations/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating GlobalOperation %q: %#v", d.Id(), res)

	return resourceComputeGlobalOperationRead(d, meta)
}

func resourceComputeGlobalOperationRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/operations/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GlobalOperation: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("ComputeGlobalOperation %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}

	if err := d.Set("creation_timestamp", flattenComputeGlobalOperationCreationTimestamp(res["creationTimestamp"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("description", flattenComputeGlobalOperationDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("id", flattenComputeGlobalOperationId(res["id"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("name", flattenComputeGlobalOperationName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("zone", flattenComputeGlobalOperationZone(res["zone"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("client_operation_id", flattenComputeGlobalOperationClientOperationId(res["clientOperationId"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("operation_type", flattenComputeGlobalOperationOperationType(res["operationType"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("user", flattenComputeGlobalOperationUser(res["user"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("progress", flattenComputeGlobalOperationProgress(res["progress"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("insert_time", flattenComputeGlobalOperationInsertTime(res["insertTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("start_time", flattenComputeGlobalOperationStartTime(res["startTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("end_time", flattenComputeGlobalOperationEndTime(res["endTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("status", flattenComputeGlobalOperationStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("status_message", flattenComputeGlobalOperationStatusMessage(res["statusMessage"], d, config)); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}
	if err := d.Set("self_link", ConvertSelfLinkToV1(res["selfLink"].(string))); err != nil {
		return fmt.Errorf("Error reading GlobalOperation: %s", err)
	}

	return nil
}

func resourceComputeGlobalOperationUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GlobalOperation: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	nameProp, err := expandComputeGlobalOperationName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	zoneProp, err := expandComputeGlobalOperationZone(d.Get("zone"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("zone"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, zoneProp)) {
		obj["zone"] = zoneProp
	}
	clientOperationIdProp, err := expandComputeGlobalOperationClientOperationId(d.Get("client_operation_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_operation_id"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, clientOperationIdProp)) {
		obj["clientOperationId"] = clientOperationIdProp
	}
	operationTypeProp, err := expandComputeGlobalOperationOperationType(d.Get("operation_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("operation_type"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, operationTypeProp)) {
		obj["operationType"] = operationTypeProp
	}
	userProp, err := expandComputeGlobalOperationUser(d.Get("user"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("user"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, userProp)) {
		obj["user"] = userProp
	}
	progressProp, err := expandComputeGlobalOperationProgress(d.Get("progress"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("progress"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, progressProp)) {
		obj["progress"] = progressProp
	}
	statusProp, err := expandComputeGlobalOperationStatus(d.Get("status"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("status"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, statusProp)) {
		obj["status"] = statusProp
	}
	statusMessageProp, err := expandComputeGlobalOperationStatusMessage(d.Get("status_message"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("status_message"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, statusMessageProp)) {
		obj["statusMessage"] = statusMessageProp
	}

	url, err := replaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/operations/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating GlobalOperation %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PUT", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating GlobalOperation %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating GlobalOperation %q: %#v", d.Id(), res)
	}

	return resourceComputeGlobalOperationRead(d, meta)
}

func resourceComputeGlobalOperationDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for GlobalOperation: %s", err)
	}
	billingProject = project

	url, err := replaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/global/operations/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting GlobalOperation %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "GlobalOperation")
	}

	log.Printf("[DEBUG] Finished deleting GlobalOperation %q: %#v", d.Id(), res)
	return nil
}

func resourceComputeGlobalOperationImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"projects/(?P<project>[^/]+)/global/operations/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<name>[^/]+)",
		"(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "projects/{{project}}/global/operations/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenComputeGlobalOperationCreationTimestamp(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationDescription(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationId(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := strconv.ParseInt(strVal, 10, 64); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeGlobalOperationName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationZone(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationClientOperationId(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationOperationType(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationUser(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationProgress(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := strconv.ParseInt(strVal, 10, 64); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenComputeGlobalOperationInsertTime(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationStartTime(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationEndTime(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationStatus(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeGlobalOperationStatusMessage(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandComputeGlobalOperationName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeGlobalOperationZone(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeGlobalOperationClientOperationId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeGlobalOperationOperationType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeGlobalOperationUser(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeGlobalOperationProgress(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeGlobalOperationStatus(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeGlobalOperationStatusMessage(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
