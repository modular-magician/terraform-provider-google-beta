// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"google.golang.org/api/googleapi"
)

var cloudRunJobGoogleProvidedAnnotations = regexp.MustCompile(`run\.googleapis\.com/(?:(?:creator)|(?:lastModifier))`)

func cloudrunJobAnnotationDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the annotations provided by Google
	if cloudRunJobGoogleProvidedAnnotations.MatchString(k) && new == "" {
		return true
	}

	// Let diff be determined by annotations (above)
	if strings.Contains(k, "annotations.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var cloudRunJobGoogleProvidedTemplateAnnotations = regexp.MustCompile(`run\.googleapis\.com/execution-environment`)

func cloudrunJobTemplateAnnotationDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the annotations provided by API
	if cloudRunJobGoogleProvidedTemplateAnnotations.MatchString(k) &&
		old == "gen2" && new == "" {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var cloudRunJobGoogleProvidedLabels = regexp.MustCompile(`cloud\.googleapis\.com/location$|run.googleapis.com/lastUpdatedTime`)

func cloudrunJobLabelDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the labels provided by Google
	if cloudRunJobGoogleProvidedLabels.MatchString(k) && new == "" {
		return true
	}

	// Let diff be determined by labels (above)
	if strings.Contains(k, "labels.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

func resourceCloudRunJob() *schema.Resource {
	return &schema.Resource{
		Create: resourceCloudRunJobCreate,
		Read:   resourceCloudRunJobRead,
		Delete: resourceCloudRunJobDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCloudRunJobImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the job. eg us-central1`,
			},
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Name must be unique within a namespace, within a Cloud Run region.
Is required when creating resources. Name is primarily intended
for creation idempotence and configuration definition. Cannot be updated.
More info: http://kubernetes.io/docs/user-guide/identifiers#names`,
			},
			"template": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Describes the execution that will be created when running a job.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"spec": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `ExecutionSpec holds the desired configuration for executions of this job.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"parallelism": {
										Type:     schema.TypeInt,
										Optional: true,
										ForceNew: true,
										Description: `Specifies the maximum desired number of tasks the execution should run at given time.
Must be <= taskCount. When the job is run, if this field is 0 or unset, the maximum
possible value will be used for that execution. The actual number of tasks running
in steady state will be less than this number when there are fewer tasks waiting to be
completed remaining, i.e. when the work left to do is less than max parallelism.`,
									},
									"task_count": {
										Type:     schema.TypeInt,
										Computed: true,
										Optional: true,
										ForceNew: true,
										Description: `Specifies the desired number of tasks the execution should run. Setting to 1 means that
parallelism is limited to 1 and the success of that task signals the success of the
execution. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/`,
									},
									"template": {
										Type:        schema.TypeList,
										Optional:    true,
										ForceNew:    true,
										Description: `Describes the task(s) that will be created when executing an execution.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"spec": {
													Type:     schema.TypeList,
													Computed: true,
													Optional: true,
													ForceNew: true,
													Description: `Specification of the desired behavior of the task. More info:
https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status`,
													MaxItems: 1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"containers": {
																Type:     schema.TypeList,
																Optional: true,
																ForceNew: true,
																Description: `List of containers belonging to the task. We disallow a number of fields on this Container.
Only a single container may be provided.`,
																MaxItems: 1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"image": {
																			Type:     schema.TypeString,
																			Required: true,
																			ForceNew: true,
																			Description: `Docker image name. This is most often a reference to a container located
in the container registry, such as gcr.io/cloudrun/hello
More info: https://kubernetes.io/docs/concepts/containers/images`,
																		},
																		"args": {
																			Type:     schema.TypeList,
																			Optional: true,
																			ForceNew: true,
																			Description: `Arguments to the entrypoint.
The docker image's CMD is used if this is not provided.
Variable references $(VAR_NAME) are expanded using the container's
environment. If a variable cannot be resolved, the reference in the input
string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
regardless of whether the variable exists or not.
More info:
https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell`,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"command": {
																			Type:     schema.TypeList,
																			Optional: true,
																			ForceNew: true,
																			Description: `Entrypoint array. Not executed within a shell.
The docker image's ENTRYPOINT is used if this is not provided.
Variable references $(VAR_NAME) are expanded using the container's
environment. If a variable cannot be resolved, the reference in the input
string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
regardless of whether the variable exists or not.
More info:
https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell`,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"env": {
																			Type:        schema.TypeList,
																			Optional:    true,
																			ForceNew:    true,
																			Description: `List of environment variables to set in the container.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"name": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						ForceNew:    true,
																						Description: `Name of the environment variable. Must be a C_IDENTIFIER.`,
																					},
																					"value": {
																						Type:     schema.TypeString,
																						Optional: true,
																						ForceNew: true,
																						Description: `Variable references $(VAR_NAME) are expanded
using the previous defined environment variables in the container and
any route environment variables. If a variable cannot be resolved,
the reference in the input string will be unchanged. The $(VAR_NAME)
syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
references will never be expanded, regardless of whether the variable
exists or not.
Defaults to "".`,
																					},
																					"value_from": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						ForceNew:    true,
																						Description: `Source for the environment variable's value. Only supports secret_key_ref. Cannot be used if value is not empty.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"secret_key_ref": {
																									Type:        schema.TypeList,
																									Required:    true,
																									ForceNew:    true,
																									Description: `Selects a key (version) of a secret in Secret Manager.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"key": {
																												Type:     schema.TypeString,
																												Required: true,
																												ForceNew: true,
																												Description: `A Cloud Secret Manager secret version. Must be 'latest' for the latest
version or an integer for a specific version.`,
																											},
																											"name": {
																												Type:     schema.TypeString,
																												Required: true,
																												ForceNew: true,
																												Description: `The name of the secret in Cloud Secret Manager. By default, the secret is assumed to be in the same project. 
If the secret is in another project, you must define an alias. 
An alias definition has the form: :projects/<project-id|project-number>/secrets/. 
If multiple alias definitions are needed, they must be separated by commas. 
The alias definitions must be set on the run.googleapis.com/secrets annotation.`,
																											},
																											"optional": {
																												Type:        schema.TypeBool,
																												Optional:    true,
																												ForceNew:    true,
																												Description: `Specify whether the Secret or its key must be defined.`,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"image_pull_policy": {
																			Type:     schema.TypeString,
																			Optional: true,
																			ForceNew: true,
																			Description: `Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if ':latest'
tag is specified, or IfNotPresent otherwise. More info:
https://kubernetes.io/docs/concepts/containers/images#updating-images`,
																		},
																		"ports": {
																			Type:     schema.TypeList,
																			Optional: true,
																			ForceNew: true,
																			Description: `List of ports to expose from the container. Only a single port can be
specified. The specified ports must be listening on all interfaces
(0.0.0.0) within the container to be accessible.

If omitted, a port number will be chosen and passed to the container
through the PORT environment variable for the container to listen on.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"container_port": {
																						Type:        schema.TypeInt,
																						Optional:    true,
																						ForceNew:    true,
																						Description: `Port number the container listens on. This must be a valid port number, 0 < x < 65536.`,
																					},
																					"name": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						ForceNew:    true,
																						Description: `If specified, used to specify which protocol to use. Allowed values are "http1" and "h2c".`,
																					},
																					"protocol": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						ForceNew:    true,
																						Description: `Protocol for port. Must be "TCP". Defaults to "TCP".`,
																					},
																				},
																			},
																		},
																		"resources": {
																			Type:        schema.TypeList,
																			Computed:    true,
																			Optional:    true,
																			ForceNew:    true,
																			Description: `Compute Resources required by this container. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources`,
																			MaxItems:    1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"limits": {
																						Type:     schema.TypeMap,
																						Computed: true,
																						Optional: true,
																						ForceNew: true,
																						Description: `Limits describes the maximum amount of compute resources allowed.
Only memory and CPU are supported.
The values of the map is string form of the 'quantity' k8s type:
https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go`,
																						Elem: &schema.Schema{Type: schema.TypeString},
																					},
																					"requests": {
																						Type:     schema.TypeMap,
																						Optional: true,
																						ForceNew: true,
																						Description: `Requests describes the minimum amount of compute resources required.
Only memory and CPU are supported.
If Requests is omitted for a container, it defaults to Limits if that is
explicitly specified, otherwise to an implementation-defined value.
The values of the map is string form of the 'quantity' k8s type:
https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go`,
																						Elem: &schema.Schema{Type: schema.TypeString},
																					},
																				},
																			},
																		},
																		"termination_message_path": {
																			Type:     schema.TypeString,
																			Optional: true,
																			ForceNew: true,
																			Description: `Path at which the file to which the container's termination message will be written
is mounted into the container's filesystem. Message written is intended to be brief
final status, such as an assertion failure message. Will be truncated by the node
if greater than 4096 bytes. The total message length across all containers will be
limited to 12kb. Defaults to /dev/termination-log.`,
																		},
																		"termination_message_policy": {
																			Type:     schema.TypeString,
																			Optional: true,
																			ForceNew: true,
																			Description: `Indicate how the termination message should be populated. File will use the contents
of terminationMessagePath to populate the container status message on both success
and failure. FallbackToLogsOnError will use the last chunk of container log output
if the termination message file is empty and the container exited with an error. The
log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to
File.`,
																		},
																		"volume_mounts": {
																			Type:     schema.TypeList,
																			Optional: true,
																			ForceNew: true,
																			Description: `Volume to mount into the container's filesystem.
Only supports SecretVolumeSources.
Pod volumes to mount into the container's filesystem.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"mount_path": {
																						Type:     schema.TypeString,
																						Required: true,
																						ForceNew: true,
																						Description: `Path within the container at which the volume should be mounted.  Must
not contain ':'.`,
																					},
																					"name": {
																						Type:        schema.TypeString,
																						Required:    true,
																						ForceNew:    true,
																						Description: `The name of the volume. There must be a corresponding Volume with the same name.`,
																					},
																					"sub_path": {
																						Type:     schema.TypeString,
																						Optional: true,
																						ForceNew: true,
																						Description: `Path within the volume from which the container's volume should be mounted.
Defaults to "" (volume's root).`,
																					},
																				},
																			},
																		},
																		"working_dir": {
																			Type:     schema.TypeString,
																			Optional: true,
																			ForceNew: true,
																			Description: `Container's working directory.
If not specified, the container runtime's default will be used, which
might be configured in the container image.`,
																		},
																	},
																},
															},
															"max_retries": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																ForceNew:    true,
																Description: `Number of retries allowed per task, before marking this job failed.`,
															},
															"service_account_name": {
																Type:     schema.TypeString,
																Computed: true,
																Optional: true,
																ForceNew: true,
																Description: `Email address of the IAM service account associated with the task of a job execution. The service
account represents the identity of the running task, and determines what permissions the task has.
If not provided, the task will use the project's default service account.`,
															},
															"timeout_seconds": {
																Type:     schema.TypeString,
																Computed: true,
																Optional: true,
																ForceNew: true,
																Description: `Duration in seconds the task may be active before the system will actively try to mark it
failed and kill associated containers. This applies per attempt of a task, meaning each retry can
run for the full timeout.`,
															},
															"volumes": {
																Type:     schema.TypeList,
																Optional: true,
																ForceNew: true,
																Description: `List of volumes that can be mounted by containers belonging to the task. More info:
https://kubernetes.io/docs/concepts/storage/volumes`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"name": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			ForceNew:    true,
																			Description: `Volume's name. In Cloud Run Fully Managed, the name 'cloudsql' is reserved.`,
																		},
																		"secret": {
																			Type:     schema.TypeList,
																			Optional: true,
																			ForceNew: true,
																			Description: `The secret's value will be presented as the content of a file whose name is defined in the item path.
If no items are defined, the name of the file is the secretName.

The contents of the target Secret's Data field will be presented in a volume as files using the keys
in the Data field as the file names.`,
																			MaxItems: 1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"default_mode": {
																						Type:     schema.TypeString,
																						Optional: true,
																						ForceNew: true,
																						Description: `Integer representation of mode bits to use on created files by default. Must be a value between 01 and
0777 (octal). If 0 or not set, it will default to 0644. Directories within the path are not affected
by this setting.

Notes:

- Internally, a umask of 0222 will be applied to any non-zero value.
- This is an integer representation of the mode bits. So, the octal integer value should look exactly
  as the chmod numeric notation with a leading zero. Some examples: for chmod 777 (a=rwx), set to 0777
  (octal) or 511 (base-10). For chmod 640 (u=rw,g=r), set to 0640 (octal) or 416 (base-10). For chmod
  755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or 493 (base-10).
- This might be in conflict with other options that affect the file mode, like fsGroup, and the result
  can be other mode bits set.`,
																					},
																					"items": {
																						Type:     schema.TypeList,
																						Optional: true,
																						ForceNew: true,
																						Description: `If unspecified, the volume will expose a file whose name is the secretName. If specified, the key will
be used as the version to fetch from Cloud Secret Manager and the path will be the name of the file
exposed in the volume. When items are defined, they must specify a key and a path.

If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into
the volume as a file whose name is the key and content is the value. If specified, the listed keys will
be projected into the specified paths, and unlisted keys will not be present. If a key is specified that
is not present in the Secret, the volume setup will error unless it is marked optional.`,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"key": {
																									Type:        schema.TypeString,
																									Optional:    true,
																									ForceNew:    true,
																									Description: `The key to project.`,
																								},
																								"mode": {
																									Type:     schema.TypeString,
																									Optional: true,
																									ForceNew: true,
																									Description: `Mode bits to use on this file, must be a value between 01 and 0777 (octal). If 0 or not set, the
Volume's default mode will be used.

Notes:

- Internally, a umask of 0222 will be applied to any non-zero value.
- This is an integer representation of the mode bits. So, the octal integer value should look
  exactly as the chmod numeric notation with a leading zero. Some examples: for chmod 777 (a=rwx),
  set to 0777 (octal) or 511 (base-10). For chmod 640 (u=rw,g=r), set to 0640 (octal) or 416
  (base-10). For chmod 755 (u=rwx,g=rx,o=rx), set to 0755 (octal) or 493 (base-10).
- This might be in conflict with other options that affect the file mode, like fsGroup, and the
  result can be other mode bits set.`,
																								},
																								"path": {
																									Type:     schema.TypeString,
																									Optional: true,
																									ForceNew: true,
																									Description: `The relative path of the file to map the key to. May not be an absolute path. May not contain the
path element '..'. May not start with the string '..'.`,
																								},
																							},
																						},
																					},
																					"optional": {
																						Type:        schema.TypeBool,
																						Optional:    true,
																						ForceNew:    true,
																						Description: `Specify whether the Secret or its keys must be defined.`,
																					},
																					"secret_name": {
																						Type:     schema.TypeString,
																						Optional: true,
																						ForceNew: true,
																						Description: `The name of the secret in Cloud Secret Manager. By default, the secret is assumed to be in the same
project. If the secret is in another project, you must define an alias. An alias definition has the
form: :projects/<project-id|project-number>/secrets/. If multiple alias definitions are needed,
they must be separated by commas. The alias definitions must be set on the
run.googleapis.com/secrets annotation.`,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"metadata": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"annotations": {
										Type:             schema.TypeMap,
										Computed:         true,
										Optional:         true,
										ForceNew:         true,
										DiffSuppressFunc: cloudrunJobTemplateAnnotationDiffSuppress,
										Description: `Annotations is an unstructured key value map stored with a resource that may be set by
external tools to store and retrieve arbitrary metadata. They are not queryable and should
be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations

**Note**: The Cloud Run API may add additional annotations that were not provided in your config.
If terraform plan shows a diff where a server-side annotation is added, you can add it to your config
or apply the lifecycle.ignore_changes rule to the metadata.0.annotations field.`,
										Elem: &schema.Schema{Type: schema.TypeString},
									},
									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
										ForceNew: true,
										Description: `Map of string keys and values that can be used to organize and categorize
(scope and select) objects. May match selectors of replication controllers
and routes.
More info: http://kubernetes.io/docs/user-guide/labels`,
										Elem: &schema.Schema{Type: schema.TypeString},
									},
									"name": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `Name must be unique within a namespace, within a Cloud Run region.
Is required when creating resources. Name is primarily intended
for creation idempotence and configuration definition. Cannot be updated.
More info: http://kubernetes.io/docs/user-guide/identifiers#names`,
									},
									"namespace": {
										Type:     schema.TypeString,
										Optional: true,
										ForceNew: true,
										Description: `In Cloud Run the namespace must be equal to either the
project ID or project number. It will default to the resource's project.`,
									},
									"generation": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `A sequence number representing a specific generation of the desired state.`,
									},
									"resource_version": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `An opaque value that represents the internal version of this object that
can be used by clients to determine when objects have changed. May be used
for optimistic concurrency, change detection, and the watch operation on a
resource or set of resources. They may only be valid for a
particular resource or set of resources.

More info:
https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency`,
									},
									"self_link": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `SelfLink is a URL representing this object.`,
									},
									"uid": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `UID is a unique id generated by the server on successful creation of a resource and is not
allowed to change on PUT operations.

More info: http://kubernetes.io/docs/user-guide/identifiers#uids`,
									},
								},
							},
						},
					},
				},
			},

			"metadata": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"annotations": {
							Type:             schema.TypeMap,
							Computed:         true,
							Optional:         true,
							ForceNew:         true,
							DiffSuppressFunc: cloudrunJobAnnotationDiffSuppress,
							Description: `Annotations is an unstructured key value map stored with a resource that may be set by
external tools to store and retrieve arbitrary metadata. They are not queryable and should
be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations

**Note**: The Cloud Run API may add additional annotations that were not provided in your config.
If terraform plan shows a diff where a server-side annotation is added, you can add it to your config
or apply the lifecycle.ignore_changes rule to the metadata.0.annotations field.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"labels": {
							Type:             schema.TypeMap,
							Computed:         true,
							Optional:         true,
							ForceNew:         true,
							DiffSuppressFunc: cloudrunJobLabelDiffSuppress,
							Description: `Map of string keys and values that can be used to organize and categorize
(scope and select) objects. May match selectors of replication controllers
and routes.
More info: http://kubernetes.io/docs/user-guide/labels`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"namespace": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							ForceNew: true,
							Description: `In Cloud Run the namespace must be equal to either the
project ID or project number. It will default to the resource's project.`,
						},
						"generation": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `A sequence number representing a specific generation of the desired state.`,
						},
						"resource_version": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `An opaque value that represents the internal version of this object that
can be used by clients to determine when objects have changed. May be used
for optimistic concurrency, change detection, and the watch operation on a
resource or set of resources. They may only be valid for a
particular resource or set of resources.

More info:
https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency`,
						},
						"self_link": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `SelfLink is a URL representing this object.`,
						},
						"uid": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `UID is a unique id generated by the server on successful creation of a resource and is not
allowed to change on PUT operations.

More info: http://kubernetes.io/docs/user-guide/identifiers#uids`,
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCloudRunJobCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	metadataProp, err := expandCloudRunJobMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata"); !isEmptyValue(reflect.ValueOf(metadataProp)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}
	specProp, err := expandCloudRunJobSpec(nil, d, config)
	if err != nil {
		return err
	} else if !isEmptyValue(reflect.ValueOf(specProp)) {
		obj["spec"] = specProp
	}

	obj, err = resourceCloudRunJobEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Job: %#v", obj)
	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating Job: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Job %q: %#v", d.Id(), res)

	return resourceCloudRunJobRead(d, meta)
}

func resourceCloudRunJobRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("CloudRunJob %q", d.Id()))
	}

	res, err = resourceCloudRunJobDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing CloudRunJob because it no longer exists.")
		d.SetId("")
		return nil
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}

	if err := d.Set("metadata", flattenCloudRunJobMetadata(res["metadata"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	// Terraform must set the top level schema field, but since this object contains collapsed properties
	// it's difficult to know what the top level should be. Instead we just loop over the map returned from flatten.
	if flattenedProp := flattenCloudRunJobSpec(res["spec"], d, config); flattenedProp != nil {
		if gerr, ok := flattenedProp.(*googleapi.Error); ok {
			return fmt.Errorf("Error reading Job: %s", gerr)
		}
		casted := flattenedProp.([]interface{})[0]
		if casted != nil {
			for k, v := range casted.(map[string]interface{}) {
				if err := d.Set(k, v); err != nil {
					return fmt.Errorf("Error setting %s: %s", k, err)
				}
			}
		}
	}

	return nil
}

func resourceCloudRunJobDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Job %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "Job")
	}

	log.Printf("[DEBUG] Finished deleting Job %q: %#v", d.Id(), res)
	return nil
}

func resourceCloudRunJobImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"apis/run.googleapis.com/v1/namespaces/(?P<project>[^/]+)/jobs/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<name>[^/]+)",
		"(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCloudRunJobMetadata(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["namespace"] =
		flattenCloudRunJobMetadataNamespace(original["namespace"], d, config)
	transformed["self_link"] =
		flattenCloudRunJobMetadataSelfLink(original["selfLink"], d, config)
	transformed["uid"] =
		flattenCloudRunJobMetadataUid(original["uid"], d, config)
	transformed["resource_version"] =
		flattenCloudRunJobMetadataResourceVersion(original["resourceVersion"], d, config)
	transformed["generation"] =
		flattenCloudRunJobMetadataGeneration(original["generation"], d, config)
	transformed["labels"] =
		flattenCloudRunJobMetadataLabels(original["labels"], d, config)
	transformed["annotations"] =
		flattenCloudRunJobMetadataAnnotations(original["annotations"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobMetadataNamespace(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return d.Get("project")
}

func flattenCloudRunJobMetadataSelfLink(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadataUid(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadataResourceVersion(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadataGeneration(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobMetadataLabels(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadataAnnotations(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpec(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["template"] =
		flattenCloudRunJobSpecTemplate(original["template"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplate(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["metadata"] =
		flattenCloudRunJobSpecTemplateMetadata(original["metadata"], d, config)
	transformed["spec"] =
		flattenCloudRunJobSpecTemplateSpec(original["spec"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateMetadata(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenCloudRunJobSpecTemplateMetadataName(original["name"], d, config)
	transformed["namespace"] =
		flattenCloudRunJobSpecTemplateMetadataNamespace(original["namespace"], d, config)
	transformed["self_link"] =
		flattenCloudRunJobSpecTemplateMetadataSelfLink(original["selfLink"], d, config)
	transformed["uid"] =
		flattenCloudRunJobSpecTemplateMetadataUid(original["uid"], d, config)
	transformed["resource_version"] =
		flattenCloudRunJobSpecTemplateMetadataResourceVersion(original["resourceVersion"], d, config)
	transformed["generation"] =
		flattenCloudRunJobSpecTemplateMetadataGeneration(original["generation"], d, config)
	transformed["labels"] =
		flattenCloudRunJobSpecTemplateMetadataLabels(original["labels"], d, config)
	transformed["annotations"] =
		flattenCloudRunJobSpecTemplateMetadataAnnotations(original["annotations"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateMetadataName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataNamespace(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataSelfLink(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataUid(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataResourceVersion(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataGeneration(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateMetadataLabels(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataAnnotations(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpec(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["parallelism"] =
		flattenCloudRunJobSpecTemplateSpecParallelism(original["parallelism"], d, config)
	transformed["task_count"] =
		flattenCloudRunJobSpecTemplateSpecTaskCount(original["taskCount"], d, config)
	transformed["template"] =
		flattenCloudRunJobSpecTemplateSpecTemplate(original["template"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecParallelism(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTaskCount(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplate(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["spec"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpec(original["spec"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpec(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["max_retries"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecMaxRetries(original["maxRetries"], d, config)
	transformed["timeout_seconds"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecTimeoutSeconds(original["timeoutSeconds"], d, config)
	transformed["service_account_name"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecServiceAccountName(original["serviceAccountName"], d, config)
	transformed["volumes"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumes(original["volumes"], d, config)
	transformed["containers"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainers(original["containers"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecMaxRetries(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecTimeoutSeconds(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecServiceAccountName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumes(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":   flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesName(original["name"], d, config),
			"secret": flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecret(original["secret"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecret(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_name"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretSecretName(original["secretName"], d, config)
	transformed["default_mode"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretDefaultMode(original["defaultMode"], d, config)
	transformed["optional"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretOptional(original["optional"], d, config)
	transformed["items"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretSecretName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretDefaultMode(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretOptional(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItems(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":  flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsKey(original["key"], d, config),
			"path": flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsPath(original["path"], d, config),
			"mode": flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsMode(original["mode"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsKey(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsPath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsMode(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainers(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"image":                      flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersImage(original["image"], d, config),
			"command":                    flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersCommand(original["command"], d, config),
			"args":                       flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersArgs(original["args"], d, config),
			"env":                        flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnv(original["env"], d, config),
			"resources":                  flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResources(original["resources"], d, config),
			"working_dir":                flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersWorkingDir(original["workingDir"], d, config),
			"ports":                      flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPorts(original["ports"], d, config),
			"volume_mounts":              flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMounts(original["volumeMounts"], d, config),
			"termination_message_path":   flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersTerminationMessagePath(original["terminationMessagePath"], d, config),
			"termination_message_policy": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersTerminationMessagePolicy(original["terminationMessagePolicy"], d, config),
			"image_pull_policy":          flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersImagePullPolicy(original["imagePullPolicy"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersImage(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersCommand(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersArgs(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnv(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":       flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvName(original["name"], d, config),
			"value":      flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValue(original["value"], d, config),
			"value_from": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFrom(original["valueFrom"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValue(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFrom(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_key_ref"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRef(original["secretKeyRef"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRef(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefKey(original["key"], d, config)
	transformed["name"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefName(original["name"], d, config)
	transformed["optional"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefOptional(original["optional"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefKey(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefOptional(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResources(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["limits"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesLimits(original["limits"], d, config)
	transformed["requests"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesRequests(original["requests"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesLimits(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesRequests(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersWorkingDir(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPorts(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":           flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsName(original["name"], d, config),
			"container_port": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsContainerPort(original["containerPort"], d, config),
			"protocol":       flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsProtocol(original["protocol"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsContainerPort(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsProtocol(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMounts(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":       flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsName(original["name"], d, config),
			"mount_path": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsMountPath(original["mountPath"], d, config),
			"sub_path":   flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsSubPath(original["subPath"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsMountPath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsSubPath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersTerminationMessagePath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersTerminationMessagePolicy(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersImagePullPolicy(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandCloudRunJobMetadata(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNamespace, err := expandCloudRunJobMetadataNamespace(original["namespace"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespace); val.IsValid() && !isEmptyValue(val) {
		transformed["namespace"] = transformedNamespace
	}

	transformedSelfLink, err := expandCloudRunJobMetadataSelfLink(original["self_link"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSelfLink); val.IsValid() && !isEmptyValue(val) {
		transformed["selfLink"] = transformedSelfLink
	}

	transformedUid, err := expandCloudRunJobMetadataUid(original["uid"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !isEmptyValue(val) {
		transformed["uid"] = transformedUid
	}

	transformedResourceVersion, err := expandCloudRunJobMetadataResourceVersion(original["resource_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourceVersion); val.IsValid() && !isEmptyValue(val) {
		transformed["resourceVersion"] = transformedResourceVersion
	}

	transformedGeneration, err := expandCloudRunJobMetadataGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !isEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	transformedLabels, err := expandCloudRunJobMetadataLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !isEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedAnnotations, err := expandCloudRunJobMetadataAnnotations(original["annotations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAnnotations); val.IsValid() && !isEmptyValue(val) {
		transformed["annotations"] = transformedAnnotations
	}

	return transformed, nil
}

// If the property hasn't been explicitly set in config use the project defined by the provider or env.
func expandCloudRunJobMetadataNamespace(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	if v == nil {
		project, err := getProject(d, config)
		if err != nil {
			return project, nil
		}
	}
	return v, nil
}

func expandCloudRunJobMetadataSelfLink(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobMetadataUid(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobMetadataResourceVersion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobMetadataGeneration(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobMetadataLabels(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobMetadataAnnotations(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpec(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	transformed := make(map[string]interface{})
	transformedTemplate, err := expandCloudRunJobSpecTemplate(d.Get("template"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemplate); val.IsValid() && !isEmptyValue(val) {
		transformed["template"] = transformedTemplate
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplate(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMetadata, err := expandCloudRunJobSpecTemplateMetadata(original["metadata"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetadata); val.IsValid() && !isEmptyValue(val) {
		transformed["metadata"] = transformedMetadata
	}

	transformedSpec, err := expandCloudRunJobSpecTemplateSpec(original["spec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSpec); val.IsValid() && !isEmptyValue(val) {
		transformed["spec"] = transformedSpec
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateMetadata(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandCloudRunJobSpecTemplateMetadataName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedNamespace, err := expandCloudRunJobSpecTemplateMetadataNamespace(original["namespace"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespace); val.IsValid() && !isEmptyValue(val) {
		transformed["namespace"] = transformedNamespace
	}

	transformedSelfLink, err := expandCloudRunJobSpecTemplateMetadataSelfLink(original["self_link"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSelfLink); val.IsValid() && !isEmptyValue(val) {
		transformed["selfLink"] = transformedSelfLink
	}

	transformedUid, err := expandCloudRunJobSpecTemplateMetadataUid(original["uid"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !isEmptyValue(val) {
		transformed["uid"] = transformedUid
	}

	transformedResourceVersion, err := expandCloudRunJobSpecTemplateMetadataResourceVersion(original["resource_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourceVersion); val.IsValid() && !isEmptyValue(val) {
		transformed["resourceVersion"] = transformedResourceVersion
	}

	transformedGeneration, err := expandCloudRunJobSpecTemplateMetadataGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !isEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	transformedLabels, err := expandCloudRunJobSpecTemplateMetadataLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !isEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedAnnotations, err := expandCloudRunJobSpecTemplateMetadataAnnotations(original["annotations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAnnotations); val.IsValid() && !isEmptyValue(val) {
		transformed["annotations"] = transformedAnnotations
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateMetadataName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataNamespace(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataSelfLink(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataUid(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataResourceVersion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataGeneration(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataLabels(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpecTemplateMetadataAnnotations(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpecTemplateSpec(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedParallelism, err := expandCloudRunJobSpecTemplateSpecParallelism(original["parallelism"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParallelism); val.IsValid() && !isEmptyValue(val) {
		transformed["parallelism"] = transformedParallelism
	}

	transformedTaskCount, err := expandCloudRunJobSpecTemplateSpecTaskCount(original["task_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTaskCount); val.IsValid() && !isEmptyValue(val) {
		transformed["taskCount"] = transformedTaskCount
	}

	transformedTemplate, err := expandCloudRunJobSpecTemplateSpecTemplate(original["template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemplate); val.IsValid() && !isEmptyValue(val) {
		transformed["template"] = transformedTemplate
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecParallelism(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTaskCount(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplate(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSpec, err := expandCloudRunJobSpecTemplateSpecTemplateSpec(original["spec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSpec); val.IsValid() && !isEmptyValue(val) {
		transformed["spec"] = transformedSpec
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpec(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMaxRetries, err := expandCloudRunJobSpecTemplateSpecTemplateSpecMaxRetries(original["max_retries"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxRetries); val.IsValid() && !isEmptyValue(val) {
		transformed["maxRetries"] = transformedMaxRetries
	}

	transformedTimeoutSeconds, err := expandCloudRunJobSpecTemplateSpecTemplateSpecTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !isEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedServiceAccountName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecServiceAccountName(original["service_account_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccountName); val.IsValid() && !isEmptyValue(val) {
		transformed["serviceAccountName"] = transformedServiceAccountName
	}

	transformedVolumes, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumes(original["volumes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVolumes); val.IsValid() && !isEmptyValue(val) {
		transformed["volumes"] = transformedVolumes
	}

	transformedContainers, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainers(original["containers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContainers); val.IsValid() && !isEmptyValue(val) {
		transformed["containers"] = transformedContainers
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecMaxRetries(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecTimeoutSeconds(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecServiceAccountName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumes(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedSecret, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecret(original["secret"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecret); val.IsValid() && !isEmptyValue(val) {
			transformed["secret"] = transformedSecret
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecret(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretSecretName(original["secret_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretName); val.IsValid() && !isEmptyValue(val) {
		transformed["secretName"] = transformedSecretName
	}

	transformedDefaultMode, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretDefaultMode(original["default_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefaultMode); val.IsValid() && !isEmptyValue(val) {
		transformed["defaultMode"] = transformedDefaultMode
	}

	transformedOptional, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretOptional(original["optional"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOptional); val.IsValid() && !isEmptyValue(val) {
		transformed["optional"] = transformedOptional
	}

	transformedItems, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItems(original["items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedItems); val.IsValid() && !isEmptyValue(val) {
		transformed["items"] = transformedItems
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretSecretName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretDefaultMode(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretOptional(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItems(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !isEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedPath, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsPath(original["path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !isEmptyValue(val) {
			transformed["path"] = transformedPath
		}

		transformedMode, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsMode(original["mode"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !isEmptyValue(val) {
			transformed["mode"] = transformedMode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsMode(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainers(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedImage, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersImage(original["image"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedImage); val.IsValid() && !isEmptyValue(val) {
			transformed["image"] = transformedImage
		}

		transformedCommand, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersCommand(original["command"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !isEmptyValue(val) {
			transformed["command"] = transformedCommand
		}

		transformedArgs, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersArgs(original["args"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedArgs); val.IsValid() && !isEmptyValue(val) {
			transformed["args"] = transformedArgs
		}

		transformedEnv, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnv(original["env"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEnv); val.IsValid() && !isEmptyValue(val) {
			transformed["env"] = transformedEnv
		}

		transformedResources, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResources(original["resources"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResources); val.IsValid() && !isEmptyValue(val) {
			transformed["resources"] = transformedResources
		}

		transformedWorkingDir, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersWorkingDir(original["working_dir"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedWorkingDir); val.IsValid() && !isEmptyValue(val) {
			transformed["workingDir"] = transformedWorkingDir
		}

		transformedPorts, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPorts(original["ports"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPorts); val.IsValid() && !isEmptyValue(val) {
			transformed["ports"] = transformedPorts
		}

		transformedVolumeMounts, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMounts(original["volume_mounts"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVolumeMounts); val.IsValid() && !isEmptyValue(val) {
			transformed["volumeMounts"] = transformedVolumeMounts
		}

		transformedTerminationMessagePath, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersTerminationMessagePath(original["termination_message_path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTerminationMessagePath); val.IsValid() && !isEmptyValue(val) {
			transformed["terminationMessagePath"] = transformedTerminationMessagePath
		}

		transformedTerminationMessagePolicy, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersTerminationMessagePolicy(original["termination_message_policy"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTerminationMessagePolicy); val.IsValid() && !isEmptyValue(val) {
			transformed["terminationMessagePolicy"] = transformedTerminationMessagePolicy
		}

		transformedImagePullPolicy, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersImagePullPolicy(original["image_pull_policy"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedImagePullPolicy); val.IsValid() && !isEmptyValue(val) {
			transformed["imagePullPolicy"] = transformedImagePullPolicy
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersImage(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersCommand(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersArgs(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnv(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !isEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedValueFrom, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFrom(original["value_from"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValueFrom); val.IsValid() && !isEmptyValue(val) {
			transformed["valueFrom"] = transformedValueFrom
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValue(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFrom(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretKeyRef, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRef(original["secret_key_ref"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretKeyRef); val.IsValid() && !isEmptyValue(val) {
		transformed["secretKeyRef"] = transformedSecretKeyRef
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRef(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKey, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefKey(original["key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !isEmptyValue(val) {
		transformed["key"] = transformedKey
	}

	transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
		transformed["name"] = transformedName
	}

	transformedOptional, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefOptional(original["optional"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOptional); val.IsValid() && !isEmptyValue(val) {
		transformed["optional"] = transformedOptional
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefOptional(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResources(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLimits, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesLimits(original["limits"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLimits); val.IsValid() && !isEmptyValue(val) {
		transformed["limits"] = transformedLimits
	}

	transformedRequests, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesRequests(original["requests"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequests); val.IsValid() && !isEmptyValue(val) {
		transformed["requests"] = transformedRequests
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesLimits(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesRequests(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersWorkingDir(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPorts(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedContainerPort, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsContainerPort(original["container_port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainerPort); val.IsValid() && !isEmptyValue(val) {
			transformed["containerPort"] = transformedContainerPort
		}

		transformedProtocol, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsProtocol(original["protocol"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedProtocol); val.IsValid() && !isEmptyValue(val) {
			transformed["protocol"] = transformedProtocol
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsContainerPort(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsProtocol(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMounts(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedMountPath, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsMountPath(original["mount_path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMountPath); val.IsValid() && !isEmptyValue(val) {
			transformed["mountPath"] = transformedMountPath
		}

		transformedSubPath, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsSubPath(original["sub_path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSubPath); val.IsValid() && !isEmptyValue(val) {
			transformed["subPath"] = transformedSubPath
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsMountPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsSubPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersTerminationMessagePath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersTerminationMessagePolicy(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersImagePullPolicy(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func resourceCloudRunJobEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	name := d.Get("name").(string)
	if obj["metadata"] == nil {
		obj["metadata"] = make(map[string]interface{})
	}
	metadata := obj["metadata"].(map[string]interface{})
	metadata["name"] = name

	// metadata.annotations needs to include launch-stage=BETA in order to use the Job feature
	if metadata["annotations"] == nil {
		metadata["annotations"] = make(map[string]string)
	}
	metadataAnnotations := metadata["annotations"].(map[string]string)
	metadataAnnotations["run.googleapis.com/launch-stage"] = "BETA"

	// The only acceptable version/kind right now
	obj["apiVersion"] = "run.googleapis.com/v1"
	obj["kind"] = "Job"
	return obj, nil
}

func resourceCloudRunJobDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	// metadata is not present if the API returns an error
	if obj, ok := res["metadata"]; ok {
		if meta, ok := obj.(map[string]interface{}); ok {
			res["name"] = meta["name"]
		} else {
			return nil, fmt.Errorf("Unable to decode 'metadata' block from API response.")
		}
	}
	return res, nil
}
