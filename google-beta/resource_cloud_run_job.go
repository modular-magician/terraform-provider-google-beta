// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"context"
	"fmt"
	"log"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"google.golang.org/api/googleapi"
)

func jobRevisionNameCustomizeDiff(_ context.Context, diff *schema.ResourceDiff, v interface{}) error {
	autogen := diff.Get("autogenerate_revision_name").(bool)
	if autogen && diff.HasChange("template.0.metadata.0.name") {
		return fmt.Errorf("google_cloud_run_job: `template.metadata.name` cannot be set while `autogenerate_revision_name` is true. Please remove the field or set `autogenerate_revision_name` to false.")
	}

	return nil
}

var cloudRunJobGoogleProvidedAnnotations = regexp.MustCompile(`serving\.knative\.dev/(?:(?:creator)|(?:lastModifier))$|run\.googleapis\.com/(?:(?:ingress-status))$|cloud\.googleapis\.com/(?:(?:location))`)

func cloudrunJobAnnotationDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the annotations provided by Google
	if cloudRunJobGoogleProvidedAnnotations.MatchString(k) && new == "" {
		return true
	}

	// Let diff be determined by annotations (above)
	if strings.Contains(k, "annotations.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var cloudRunJobGoogleProvidedTemplateAnnotations = regexp.MustCompile(`template\.0\.metadata\.0\.annotations\.run\.googleapis\.com/sandbox`)
var cloudRunJobGoogleProvidedTemplateAnnotations_autoscaling_maxscale = regexp.MustCompile(`template\.0\.metadata\.0\.annotations\.autoscaling\.knative\.dev/maxScale`)

func cloudrunJobTemplateAnnotationDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the annotations provided by API
	if cloudRunJobGoogleProvidedTemplateAnnotations.MatchString(k) &&
		old == "gvisor" && new == "" {
		return true
	}

	if cloudRunJobGoogleProvidedTemplateAnnotations_autoscaling_maxscale.MatchString(k) && new == "" {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var cloudRunJobGoogleProvidedLabels = regexp.MustCompile(`cloud\.googleapis\.com/(?:(?:location))`)

func cloudrunJobLabelDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the labels provided by Google
	if cloudRunJobGoogleProvidedLabels.MatchString(k) && new == "" {
		return true
	}

	// Let diff be determined by labels (above)
	if strings.Contains(k, "labels.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

func resourceCloudRunJob() *schema.Resource {
	return &schema.Resource{
		Create: resourceCloudRunJobCreate,
		Read:   resourceCloudRunJobRead,
		Update: resourceCloudRunJobUpdate,
		Delete: resourceCloudRunJobDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCloudRunJobImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		SchemaVersion: 1,
		CustomizeDiff: revisionNameCustomizeDiff,

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the cloud run instance. eg us-central1`,
			},
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Name must be unique within a namespace, within a Cloud Run region.
Is required when creating resources. Name is primarily intended
for creation idempotence and configuration definition. Cannot be updated.
More info: http://kubernetes.io/docs/user-guide/identifiers#names`,
			},
			"template": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `template holds the latest specification for the Revision to
be stamped out. The template references the container image, and may also
include labels and annotations that should be attached to the Revision.
To correlate a Revision, and/or to force a Revision to be created when the
spec doesn't otherwise change, a nonce label may be provided in the
template metadata. For more details, see:
https://github.com/knative/serving/blob/main/docs/client-conventions.md#associate-modifications-with-revisions

Cloud Run does not currently support referencing a build that is
responsible for materializing the container image from source.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"spec": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `RevisionSpec holds the desired state of the Revision (from the client).`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"template": {
										Type:        schema.TypeList,
										Required:    true,
										Description: `TaskTemplateSpec describes the data a task should have when created from a template.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"spec": {
													Type:        schema.TypeList,
													Required:    true,
													Description: `Specification of the desired behavior of the task.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"containers": {
																Type:     schema.TypeList,
																Computed: true,
																Optional: true,
																Description: `Container defines the unit of execution for this Revision.
In the context of a Revision, we disallow a number of the fields of
this Container, including: name, ports, and volumeMounts.
The runtime contract is documented here:
https://github.com/knative/serving/blob/main/docs/runtime-contract.md`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"image": {
																			Type:     schema.TypeString,
																			Required: true,
																			Description: `Docker image name. This is most often a reference to a container located
in the container registry, such as gcr.io/cloudrun/hello
More info: https://kubernetes.io/docs/concepts/containers/images`,
																		},
																		"args": {
																			Type:     schema.TypeList,
																			Optional: true,
																			Description: `Arguments to the entrypoint.
The docker image's CMD is used if this is not provided.
Variable references $(VAR_NAME) are expanded using the container's
environment. If a variable cannot be resolved, the reference in the input
string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
regardless of whether the variable exists or not.
More info:
https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell`,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"command": {
																			Type:     schema.TypeList,
																			Optional: true,
																			Description: `Entrypoint array. Not executed within a shell.
The docker image's ENTRYPOINT is used if this is not provided.
Variable references $(VAR_NAME) are expanded using the container's
environment. If a variable cannot be resolved, the reference in the input
string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
regardless of whether the variable exists or not.
More info:
https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell`,
																			Elem: &schema.Schema{
																				Type: schema.TypeString,
																			},
																		},
																		"env": {
																			Type:        schema.TypeSet,
																			Optional:    true,
																			Description: `List of environment variables to set in the container.`,
																			Elem:        cloudrunJobSpecTemplateSpecTemplateSpecContainersContainersEnvSchema(),
																			// Default schema.HashSchema is used.
																		},
																		"env_from": {
																			Type:       schema.TypeList,
																			Optional:   true,
																			Deprecated: "Not supported by Cloud Run fully managed",
																			ForceNew:   true,
																			Description: `List of sources to populate environment variables in the container.
All invalid keys will be reported as an event when the container is starting.
When a key exists in multiple sources, the value associated with the last source will
take precedence. Values defined by an Env with a duplicate key will take
precedence.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"config_map_ref": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `The ConfigMap to select from.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"local_object_reference": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `The ConfigMap to select from.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"name": {
																												Type:     schema.TypeString,
																												Required: true,
																												Description: `Name of the referent.
More info:
https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names`,
																											},
																										},
																									},
																								},
																								"optional": {
																									Type:        schema.TypeBool,
																									Optional:    true,
																									Description: `Specify whether the ConfigMap must be defined`,
																								},
																							},
																						},
																					},
																					"prefix": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						Description: `An optional identifier to prepend to each key in the ConfigMap.`,
																					},
																					"secret_ref": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `The Secret to select from.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"local_object_reference": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `The Secret to select from.`,
																									MaxItems:    1,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"name": {
																												Type:     schema.TypeString,
																												Required: true,
																												Description: `Name of the referent.
More info:
https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names`,
																											},
																										},
																									},
																								},
																								"optional": {
																									Type:        schema.TypeBool,
																									Optional:    true,
																									Description: `Specify whether the Secret must be defined`,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"liveness_probe": {
																			Type:     schema.TypeList,
																			Optional: true,
																			Description: `Periodic probe of container liveness. Container will be restarted if the probe fails. More info:
https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes`,
																			MaxItems: 1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"failure_threshold": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `Minimum consecutive failures for the probe to be considered failed after
having succeeded. Defaults to 3. Minimum value is 1.`,
																						Default: 3,
																					},
																					"http_get": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `HttpGet specifies the http request to perform.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"http_headers": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `Custom headers to set in the request. HTTP allows repeated headers.`,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"name": {
																												Type:        schema.TypeString,
																												Required:    true,
																												Description: `The header field name.`,
																											},
																											"value": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `The header field value.`,
																												Default:     "",
																											},
																										},
																									},
																								},
																								"path": {
																									Type:        schema.TypeString,
																									Optional:    true,
																									Description: `Path to access on the HTTP server. If set, it should not be empty string.`,
																									Default:     "/",
																								},
																							},
																						},
																					},
																					"initial_delay_seconds": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `Number of seconds after the container has started before the probe is
initiated.
Defaults to 0 seconds. Minimum value is 0. Maximum value is 3600.`,
																						Default: 0,
																					},
																					"period_seconds": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `How often (in seconds) to perform the probe.
Default to 10 seconds. Minimum value is 1. Maximum value is 3600.`,
																						Default: 10,
																					},
																					"timeout_seconds": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `Number of seconds after which the probe times out.
Defaults to 1 second. Minimum value is 1. Maximum value is 3600.
Must be smaller than period_seconds.`,
																						Default: 1,
																					},
																				},
																			},
																		},
																		"ports": {
																			Type:     schema.TypeList,
																			Computed: true,
																			Optional: true,
																			Description: `List of open ports in the container.
More Info:
https://cloud.google.com/run/docs/reference/rest/v1/RevisionSpec#ContainerPort`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"container_port": {
																						Type:        schema.TypeInt,
																						Optional:    true,
																						Description: `Port number the container listens on. This must be a valid port number, 0 < x < 65536.`,
																					},
																					"name": {
																						Type:        schema.TypeString,
																						Computed:    true,
																						Optional:    true,
																						Description: `If specified, used to specify which protocol to use. Allowed values are "http1" and "h2c".`,
																					},
																					"protocol": {
																						Type:        schema.TypeString,
																						Optional:    true,
																						Description: `Protocol for port. Must be "TCP". Defaults to "TCP".`,
																					},
																				},
																			},
																		},
																		"resources": {
																			Type:     schema.TypeList,
																			Computed: true,
																			Optional: true,
																			Description: `Compute Resources required by this container. Used to set values such as max memory
More info:
https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits`,
																			MaxItems: 1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"limits": {
																						Type:     schema.TypeMap,
																						Computed: true,
																						Optional: true,
																						Description: `Limits describes the maximum amount of compute resources allowed.
The values of the map is string form of the 'quantity' k8s type:
https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go`,
																						Elem: &schema.Schema{Type: schema.TypeString},
																					},
																					"requests": {
																						Type:     schema.TypeMap,
																						Optional: true,
																						Description: `Requests describes the minimum amount of compute resources required.
If Requests is omitted for a container, it defaults to Limits if that is
explicitly specified, otherwise to an implementation-defined value.
The values of the map is string form of the 'quantity' k8s type:
https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go`,
																						Elem: &schema.Schema{Type: schema.TypeString},
																					},
																				},
																			},
																		},
																		"startup_probe": {
																			Type:     schema.TypeList,
																			Computed: true,
																			Optional: true,
																			Description: `Startup probe of application within the container.
All other probes are disabled if a startup probe is provided, until it
succeeds. Container will not be added to service endpoints if the probe fails.
More info:
https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes`,
																			MaxItems: 1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"failure_threshold": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `Minimum consecutive failures for the probe to be considered failed after
having succeeded. Defaults to 3. Minimum value is 1.`,
																						Default: 3,
																					},
																					"http_get": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `HttpGet specifies the http request to perform.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"http_headers": {
																									Type:        schema.TypeList,
																									Optional:    true,
																									Description: `Custom headers to set in the request. HTTP allows repeated headers.`,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"name": {
																												Type:        schema.TypeString,
																												Required:    true,
																												Description: `The header field name.`,
																											},
																											"value": {
																												Type:        schema.TypeString,
																												Optional:    true,
																												Description: `The header field value.`,
																												Default:     "",
																											},
																										},
																									},
																								},
																								"path": {
																									Type:        schema.TypeString,
																									Optional:    true,
																									Description: `Path to access on the HTTP server. If set, it should not be empty string.`,
																									Default:     "/",
																								},
																							},
																						},
																						ExactlyOneOf: []string{},
																					},
																					"initial_delay_seconds": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `Number of seconds after the container has started before the probe is
initiated.
Defaults to 0 seconds. Minimum value is 0. Maximum value is 240.`,
																						Default: 0,
																					},
																					"period_seconds": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `How often (in seconds) to perform the probe.
Default to 10 seconds. Minimum value is 1. Maximum value is 240.`,
																						Default: 10,
																					},
																					"tcp_socket": {
																						Type:        schema.TypeList,
																						Optional:    true,
																						Description: `TcpSocket specifies an action involving a TCP port.`,
																						MaxItems:    1,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"port": {
																									Type:        schema.TypeInt,
																									Computed:    true,
																									Optional:    true,
																									Description: `Port number to access on the container. Number must be in the range 1 to 65535.`,
																								},
																							},
																						},
																						ExactlyOneOf: []string{},
																					},
																					"timeout_seconds": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `Number of seconds after which the probe times out.
Defaults to 1 second. Minimum value is 1. Maximum value is 3600.
Must be smaller than periodSeconds.`,
																						Default: 1,
																					},
																				},
																			},
																		},
																		"volume_mounts": {
																			Type:     schema.TypeList,
																			Optional: true,
																			Description: `Volume to mount into the container's filesystem.
Only supports SecretVolumeSources.`,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"mount_path": {
																						Type:     schema.TypeString,
																						Required: true,
																						Description: `Path within the container at which the volume should be mounted.  Must
not contain ':'.`,
																					},
																					"name": {
																						Type:        schema.TypeString,
																						Required:    true,
																						Description: `This must match the Name of a Volume.`,
																					},
																				},
																			},
																		},
																		"working_dir": {
																			Type:       schema.TypeString,
																			Optional:   true,
																			Deprecated: "Not supported by Cloud Run fully managed",
																			ForceNew:   true,
																			Description: `Container's working directory.
If not specified, the container runtime's default will be used, which
might be configured in the container image.`,
																		},
																	},
																},
															},
															"max_retries": {
																Type:        schema.TypeInt,
																Computed:    true,
																Optional:    true,
																Description: `Number of retries allowed per task, before marking this job failed.`,
															},
															"service_account_name": {
																Type:     schema.TypeString,
																Computed: true,
																Optional: true,
																Description: `Email address of the IAM service account associated with the task of a job execution. 
The service account represents the identity of the running task, and determines what permissions the task has.`,
															},
															"timeout_seconds": {
																Type:     schema.TypeString,
																Computed: true,
																Optional: true,
																Description: `Duration in seconds the task may be active before the system will actively try to mark it failed and kill associated containers. 
This applies per attempt of a task, meaning each retry can run for the full timeout.`,
															},
															"volumes": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `Volume represents a named volume in a container.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"name": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: `Volume's name.`,
																		},
																		"secret": {
																			Type:     schema.TypeList,
																			Required: true,
																			Description: `The secret's value will be presented as the content of a file whose
name is defined in the item path. If no items are defined, the name of
the file is the secret_name.`,
																			MaxItems: 1,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"secret_name": {
																						Type:     schema.TypeString,
																						Required: true,
																						Description: `The name of the secret in Cloud Secret Manager. By default, the secret
is assumed to be in the same project.
If the secret is in another project, you must define an alias.
An alias definition has the form:
{alias}:projects/{project-id|project-number}/secrets/{secret-name}.
If multiple alias definitions are needed, they must be separated by
commas.
The alias definitions must be set on the run.googleapis.com/secrets
annotation.`,
																					},
																					"default_mode": {
																						Type:     schema.TypeInt,
																						Optional: true,
																						Description: `Mode bits to use on created files by default. Must be a value between 0000
and 0777. Defaults to 0644. Directories within the path are not affected by
this setting. This might be in conflict with other options that affect the
file mode, like fsGroup, and the result can be other mode bits set.`,
																					},
																					"items": {
																						Type:     schema.TypeList,
																						Optional: true,
																						Description: `If unspecified, the volume will expose a file whose name is the
secret_name.
If specified, the key will be used as the version to fetch from Cloud
Secret Manager and the path will be the name of the file exposed in the
volume. When items are defined, they must specify a key and a path.`,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"key": {
																									Type:     schema.TypeString,
																									Required: true,
																									Description: `The Cloud Secret Manager secret version.
Can be 'latest' for the latest value or an integer for a specific version.`,
																								},
																								"path": {
																									Type:     schema.TypeString,
																									Required: true,
																									Description: `The relative path of the file to map the key to.
May not be an absolute path.
May not contain the path element '..'.
May not start with the string '..'.`,
																								},
																								"mode": {
																									Type:     schema.TypeInt,
																									Optional: true,
																									Description: `Mode bits to use on this file, must be a value between 0000 and 0777. If
not specified, the volume defaultMode will be used. This might be in
conflict with other options that affect the file mode, like fsGroup, and
the result can be other mode bits set.`,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"parallelism": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Specifies the maximum desired number of tasks the execution should run at given time.`,
									},
									"task_count": {
										Type:     schema.TypeInt,
										Optional: true,
										Description: `Specifies the desired number of tasks the execution should run. 
Setting to 1 means that parallelism is limited to 1 and the success of that task signals the success of the execution.`,
									},
								},
							},
						},
						"metadata": {
							Type:     schema.TypeList,
							Computed: true,
							Optional: true,
							Description: `Optional metadata for this Revision, including labels and annotations.
Name will be generated by the Configuration. To set minimum instances
for this revision, use the "autoscaling.knative.dev/minScale" annotation
key. To set maximum instances for this revision, use the
"autoscaling.knative.dev/maxScale" annotation key. To set Cloud SQL
connections for the revision, use the "run.googleapis.com/cloudsql-instances"
annotation key.`,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"annotations": {
										Type:             schema.TypeMap,
										Computed:         true,
										Optional:         true,
										DiffSuppressFunc: cloudrunTemplateAnnotationDiffSuppress,
										Description: `Annotations is a key value map stored with a resource that
may be set by external tools to store and retrieve arbitrary metadata. More
info: http://kubernetes.io/docs/user-guide/annotations

**Note**: The Cloud Run API may add additional annotations that were not provided in your config.
If terraform plan shows a diff where a server-side annotation is added, you can add it to your config
or apply the lifecycle.ignore_changes rule to the metadata.0.annotations field.`,
										Elem: &schema.Schema{Type: schema.TypeString},
									},
									"labels": {
										Type:     schema.TypeMap,
										Optional: true,
										Description: `Map of string keys and values that can be used to organize and categorize
(scope and select) objects. May match selectors of replication controllers
and routes.
More info: http://kubernetes.io/docs/user-guide/labels`,
										Elem: &schema.Schema{Type: schema.TypeString},
									},
									"name": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `Name must be unique within a namespace, within a Cloud Run region.
Is required when creating resources. Name is primarily intended
for creation idempotence and configuration definition. Cannot be updated.
More info: http://kubernetes.io/docs/user-guide/identifiers#names`,
									},
									"namespace": {
										Type:     schema.TypeString,
										Computed: true,
										Optional: true,
										Description: `In Cloud Run the namespace must be equal to either the
project ID or project number. It will default to the resource's project.`,
									},
									"generation": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `A sequence number representing a specific generation of the desired state.`,
									},
									"resource_version": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `An opaque value that represents the internal version of this object that
can be used by clients to determine when objects have changed. May be used
for optimistic concurrency, change detection, and the watch operation on a
resource or set of resources. They may only be valid for a
particular resource or set of resources.

More info:
https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency`,
									},
									"self_link": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `SelfLink is a URL representing this object.`,
									},
									"uid": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `UID is a unique id generated by the server on successful creation of a resource and is not
allowed to change on PUT operations.

More info: http://kubernetes.io/docs/user-guide/identifiers#uids`,
									},
								},
							},
						},
					},
				},
			},

			"metadata": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `Metadata associated with this Service, including name, namespace, labels,
and annotations.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"annotations": {
							Type:             schema.TypeMap,
							Computed:         true,
							Optional:         true,
							DiffSuppressFunc: cloudrunAnnotationDiffSuppress,
							Description: `Annotations is a key value map stored with a resource that
may be set by external tools to store and retrieve arbitrary metadata. More
info: http://kubernetes.io/docs/user-guide/annotations

**Note**: The Cloud Run API may add additional annotations that were not provided in your config.
If terraform plan shows a diff where a server-side annotation is added, you can add it to your config
or apply the lifecycle.ignore_changes rule to the metadata.0.annotations field.

Cloud Run (fully managed) uses the following annotation keys to configure features on a Service:

- 'run.googleapis.com/ingress' sets the [ingress settings](https://cloud.google.com/sdk/gcloud/reference/run/deploy#--ingress)
  for the Service. For example, '"run.googleapis.com/ingress" = "all"'.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"labels": {
							Type:             schema.TypeMap,
							Computed:         true,
							Optional:         true,
							DiffSuppressFunc: cloudrunLabelDiffSuppress,
							Description: `Map of string keys and values that can be used to organize and categorize
(scope and select) objects. May match selectors of replication controllers
and routes.
More info: http://kubernetes.io/docs/user-guide/labels`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"namespace": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							Description: `In Cloud Run the namespace must be equal to either the
project ID or project number.`,
						},
						"generation": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `A sequence number representing a specific generation of the desired state.`,
						},
						"resource_version": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `An opaque value that represents the internal version of this object that
can be used by clients to determine when objects have changed. May be used
for optimistic concurrency, change detection, and the watch operation on a
resource or set of resources. They may only be valid for a
particular resource or set of resources.

More info:
https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency`,
						},
						"self_link": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `SelfLink is a URL representing this object.`,
						},
						"uid": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `UID is a unique id generated by the server on successful creation of a resource and is not
allowed to change on PUT operations.

More info: http://kubernetes.io/docs/user-guide/identifiers#uids`,
						},
					},
				},
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The current status of the Service.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"conditions": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Array of observed Service Conditions, indicating the current ready state of the service.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"message": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human readable message indicating details about the current status.`,
									},
									"reason": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `One-word CamelCase reason for the condition's current status.`,
									},
									"status": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Status of the condition, one of True, False, Unknown.`,
									},
									"type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Type of domain mapping condition.`,
									},
								},
							},
						},
						"execution_count": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Number of executions created for this job.`,
						},
						"latest_created_execution": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `A pointer to the most recently created execution for this job. This is set regardless of the eventual state of the execution.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"completion_timestamp": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Completion timestamp of the execution.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. 
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
									},
									"creation_timestamp": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Creation timestamp of the execution.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
									},
									"name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Name of the execution.`,
									},
								},
							},
						},
						"observed_generation": {
							Type:     schema.TypeInt,
							Computed: true,
							Description: `ObservedGeneration is the 'Generation' of the Route that was last processed by the
controller.

Clients polling for completed reconciliation should poll until observedGeneration =
metadata.generation and the Ready condition's status is True or False.`,
						},
						"url": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `From RouteStatus. URL holds the url that will distribute traffic over the provided traffic
targets. It generally has the form
https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app`,
						},
					},
				},
			},
			"autogenerate_revision_name": {
				Type:     schema.TypeBool,
				Optional: true,
				Default:  false,
				Description: `If set to 'true', the revision name (template.metadata.name) will be omitted and
autogenerated by Cloud Run. This cannot be set to 'true' while 'template.metadata.name'
is also set.
(For legacy support, if 'template.metadata.name' is unset in state while
this field is set to false, the revision name will still autogenerate.)`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func cloudrunJobSpecTemplateSpecTemplateSpecContainersContainersEnvSchema() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Name of the environment variable.`,
			},
			"value": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `Variable references $(VAR_NAME) are expanded
using the previous defined environment variables in the container and
any route environment variables. If a variable cannot be resolved,
the reference in the input string will be unchanged. The $(VAR_NAME)
syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
references will never be expanded, regardless of whether the variable
exists or not.
Defaults to "".`,
			},
			"value_from": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Source for the environment variable's value. Only supports secret_key_ref.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"secret_key_ref": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `Selects a key (version) of a secret in Secret Manager.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:     schema.TypeString,
										Required: true,
										Description: `A Cloud Secret Manager secret version. Must be 'latest' for the latest
version or an integer for a specific version.`,
									},
									"name": {
										Type:     schema.TypeString,
										Required: true,
										Description: `The name of the secret in Cloud Secret Manager. By default, the secret is assumed to be in the same project. 
If the secret is in another project, you must define an alias. 
An alias definition has the form: :projects/{project-id|project-number}/secrets/. 
If multiple alias definitions are needed, they must be separated by commas. 
The alias definitions must be set on the run.googleapis.com/secrets annotation.`,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func resourceCloudRunJobCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	specProp, err := expandCloudRunJobSpec(nil, d, config)
	if err != nil {
		return err
	} else if !isEmptyValue(reflect.ValueOf(specProp)) {
		obj["spec"] = specProp
	}
	metadataProp, err := expandCloudRunJobMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata"); !isEmptyValue(reflect.ValueOf(metadataProp)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}

	obj, err = resourceCloudRunJobEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Job: %#v", obj)
	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate), isCloudRunCreationConflict)
	if err != nil {
		return fmt.Errorf("Error creating Job: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "locations/{{location}}/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = PollingWaitTime(resourceCloudRunJobPollRead(d, meta), PollCheckKnativeStatusFunc(res), "Creating Job", d.Timeout(schema.TimeoutCreate), 1)
	if err != nil {
		return fmt.Errorf("Error waiting to create Job: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Job %q: %#v", d.Id(), res)

	return resourceCloudRunJobRead(d, meta)
}

func resourceCloudRunJobPollRead(d *schema.ResourceData, meta interface{}) PollReadFunc {
	return func() (map[string]interface{}, error) {
		config := meta.(*Config)

		url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
		if err != nil {
			return nil, err
		}

		billingProject := ""

		project, err := getProject(d, config)
		if err != nil {
			return nil, fmt.Errorf("Error fetching project for Job: %s", err)
		}
		billingProject = project

		// err == nil indicates that the billing_project value was found
		if bp, err := getBillingProject(d, config); err == nil {
			billingProject = bp
		}

		userAgent, err := generateUserAgentString(d, config.userAgent)
		if err != nil {
			return nil, err
		}

		res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil, isCloudRunCreationConflict)
		if err != nil {
			return res, err
		}
		res, err = resourceCloudRunJobDecoder(d, meta, res)
		if err != nil {
			return nil, err
		}
		if res == nil {
			return nil, fake404("decoded", "CloudRunJob")
		}

		return res, nil
	}
}

func resourceCloudRunJobRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil, isCloudRunCreationConflict)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("CloudRunJob %q", d.Id()))
	}

	res, err = resourceCloudRunJobDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing CloudRunJob because it no longer exists.")
		d.SetId("")
		return nil
	}

	// Explicitly set virtual fields to default values if unset
	if _, ok := d.GetOkExists("autogenerate_revision_name"); !ok {
		if err := d.Set("autogenerate_revision_name", false); err != nil {
			return fmt.Errorf("Error setting autogenerate_revision_name: %s", err)
		}
	}
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}

	// Terraform must set the top level schema field, but since this object contains collapsed properties
	// it's difficult to know what the top level should be. Instead we just loop over the map returned from flatten.
	if flattenedProp := flattenCloudRunJobSpec(res["spec"], d, config); flattenedProp != nil {
		if gerr, ok := flattenedProp.(*googleapi.Error); ok {
			return fmt.Errorf("Error reading Job: %s", gerr)
		}
		casted := flattenedProp.([]interface{})[0]
		if casted != nil {
			for k, v := range casted.(map[string]interface{}) {
				if err := d.Set(k, v); err != nil {
					return fmt.Errorf("Error setting %s: %s", k, err)
				}
			}
		}
	}
	if err := d.Set("status", flattenCloudRunJobStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}
	if err := d.Set("metadata", flattenCloudRunJobMetadata(res["metadata"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}

	return nil
}

func resourceCloudRunJobUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	specProp, err := expandCloudRunJobSpec(nil, d, config)
	if err != nil {
		return err
	} else if !isEmptyValue(reflect.ValueOf(specProp)) {
		obj["spec"] = specProp
	}
	metadataProp, err := expandCloudRunJobMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("metadata"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}

	obj, err = resourceCloudRunJobEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Job %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PUT", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate), isCloudRunCreationConflict)

	if err != nil {
		return fmt.Errorf("Error updating Job %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating Job %q: %#v", d.Id(), res)
	}

	err = PollingWaitTime(resourceCloudRunJobPollRead(d, meta), PollCheckKnativeStatusFunc(res), "Updating Job", d.Timeout(schema.TimeoutUpdate), 1)
	if err != nil {
		return err
	}

	return resourceCloudRunJobRead(d, meta)
}

func resourceCloudRunJobDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Job %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete), isCloudRunCreationConflict)
	if err != nil {
		return handleNotFoundError(err, d, "Job")
	}

	log.Printf("[DEBUG] Finished deleting Job %q: %#v", d.Id(), res)
	return nil
}

func resourceCloudRunJobImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"locations/(?P<location>[^/]+)/namespaces/(?P<project>[^/]+)/jobs/(?P<name>[^/]+)",
		"(?P<location>[^/]+)/(?P<project>[^/]+)/(?P<name>[^/]+)",
		"(?P<location>[^/]+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "locations/{{location}}/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import
	if err := d.Set("autogenerate_revision_name", false); err != nil {
		return nil, fmt.Errorf("Error setting autogenerate_revision_name: %s", err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenCloudRunJobSpec(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["template"] =
		flattenCloudRunJobSpecTemplate(original["template"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplate(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["metadata"] =
		flattenCloudRunJobSpecTemplateMetadata(original["metadata"], d, config)
	transformed["spec"] =
		flattenCloudRunJobSpecTemplateSpec(original["spec"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateMetadata(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["labels"] =
		flattenCloudRunJobSpecTemplateMetadataLabels(original["labels"], d, config)
	transformed["generation"] =
		flattenCloudRunJobSpecTemplateMetadataGeneration(original["generation"], d, config)
	transformed["resource_version"] =
		flattenCloudRunJobSpecTemplateMetadataResourceVersion(original["resourceVersion"], d, config)
	transformed["self_link"] =
		flattenCloudRunJobSpecTemplateMetadataSelfLink(original["selfLink"], d, config)
	transformed["uid"] =
		flattenCloudRunJobSpecTemplateMetadataUid(original["uid"], d, config)
	transformed["namespace"] =
		flattenCloudRunJobSpecTemplateMetadataNamespace(original["namespace"], d, config)
	transformed["annotations"] =
		flattenCloudRunJobSpecTemplateMetadataAnnotations(original["annotations"], d, config)
	transformed["name"] =
		flattenCloudRunJobSpecTemplateMetadataName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateMetadataLabels(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataGeneration(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateMetadataResourceVersion(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataSelfLink(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataUid(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataNamespace(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataAnnotations(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateMetadataName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpec(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["parallelism"] =
		flattenCloudRunJobSpecTemplateSpecParallelism(original["parallelism"], d, config)
	transformed["task_count"] =
		flattenCloudRunJobSpecTemplateSpecTaskCount(original["taskCount"], d, config)
	transformed["template"] =
		flattenCloudRunJobSpecTemplateSpecTemplate(original["template"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecParallelism(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTaskCount(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplate(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["spec"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpec(original["spec"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpec(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["timeout_seconds"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecTimeoutSeconds(original["timeoutSeconds"], d, config)
	transformed["service_account_name"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecServiceAccountName(original["serviceAccountName"], d, config)
	transformed["max_retries"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecMaxRetries(original["maxRetries"], d, config)
	transformed["containers"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainers(original["containers"], d, config)
	transformed["volumes"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumes(original["volumes"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecTimeoutSeconds(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecServiceAccountName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecMaxRetries(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainers(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"working_dir":    flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersWorkingDir(original["workingDir"], d, config),
			"args":           flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersArgs(original["args"], d, config),
			"env_from":       flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFrom(original["envFrom"], d, config),
			"image":          flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersImage(original["image"], d, config),
			"command":        flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersCommand(original["command"], d, config),
			"env":            flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnv(original["env"], d, config),
			"ports":          flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPorts(original["ports"], d, config),
			"resources":      flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResources(original["resources"], d, config),
			"volume_mounts":  flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMounts(original["volumeMounts"], d, config),
			"startup_probe":  flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbe(original["startupProbe"], d, config),
			"liveness_probe": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbe(original["livenessProbe"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersWorkingDir(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersArgs(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFrom(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"prefix":         flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromPrefix(original["prefix"], d, config),
			"config_map_ref": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRef(original["configMapRef"], d, config),
			"secret_ref":     flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRef(original["secretRef"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromPrefix(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRef(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["optional"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefOptional(original["optional"], d, config)
	transformed["local_object_reference"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference(original["localObjectReference"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefOptional(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRef(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["local_object_reference"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference(original["localObjectReference"], d, config)
	transformed["optional"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefOptional(original["optional"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefOptional(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersImage(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersCommand(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnv(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := schema.NewSet(schema.HashResource(cloudrunJobSpecTemplateSpecTemplateSpecContainersContainersEnvSchema()), []interface{}{})
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed.Add(map[string]interface{}{
			"name":       flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvName(original["name"], d, config),
			"value":      flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValue(original["value"], d, config),
			"value_from": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFrom(original["valueFrom"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValue(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFrom(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_key_ref"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRef(original["secretKeyRef"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRef(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefKey(original["key"], d, config)
	transformed["name"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefName(original["name"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefKey(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPorts(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":           flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsName(original["name"], d, config),
			"protocol":       flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsProtocol(original["protocol"], d, config),
			"container_port": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsContainerPort(original["containerPort"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsProtocol(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsContainerPort(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResources(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["limits"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesLimits(original["limits"], d, config)
	transformed["requests"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesRequests(original["requests"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesLimits(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesRequests(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMounts(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"mount_path": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsMountPath(original["mountPath"], d, config),
			"name":       flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsName(original["name"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsMountPath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbe(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["initial_delay_seconds"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeInitialDelaySeconds(original["initialDelaySeconds"], d, config)
	transformed["timeout_seconds"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTimeoutSeconds(original["timeoutSeconds"], d, config)
	transformed["period_seconds"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbePeriodSeconds(original["periodSeconds"], d, config)
	transformed["failure_threshold"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeFailureThreshold(original["failureThreshold"], d, config)
	transformed["tcp_socket"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTcpSocket(original["tcpSocket"], d, config)
	transformed["http_get"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGet(original["httpGet"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeInitialDelaySeconds(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTimeoutSeconds(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbePeriodSeconds(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeFailureThreshold(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTcpSocket(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["port"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTcpSocketPort(original["port"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTcpSocketPort(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGet(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["path"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetPath(original["path"], d, config)
	transformed["http_headers"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(original["httpHeaders"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetPath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":  flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeadersName(original["name"], d, config),
			"value": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeadersValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeadersName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeadersValue(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbe(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["initial_delay_seconds"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeInitialDelaySeconds(original["initialDelaySeconds"], d, config)
	transformed["timeout_seconds"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeTimeoutSeconds(original["timeoutSeconds"], d, config)
	transformed["period_seconds"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbePeriodSeconds(original["periodSeconds"], d, config)
	transformed["failure_threshold"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeFailureThreshold(original["failureThreshold"], d, config)
	transformed["http_get"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGet(original["httpGet"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeInitialDelaySeconds(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeTimeoutSeconds(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbePeriodSeconds(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeFailureThreshold(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGet(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["path"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetPath(original["path"], d, config)
	transformed["http_headers"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(original["httpHeaders"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetPath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":  flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersName(original["name"], d, config),
			"value": flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersValue(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumes(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":   flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesName(original["name"], d, config),
			"secret": flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecret(original["secret"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecret(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_name"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretSecretName(original["secretName"], d, config)
	transformed["default_mode"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretDefaultMode(original["defaultMode"], d, config)
	transformed["items"] =
		flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretSecretName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretDefaultMode(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItems(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":  flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsKey(original["key"], d, config),
			"path": flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsPath(original["path"], d, config),
			"mode": flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsMode(original["mode"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsKey(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsPath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsMode(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobStatus(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["conditions"] =
		flattenCloudRunJobStatusConditions(original["conditions"], d, config)
	transformed["url"] =
		flattenCloudRunJobStatusUrl(original["url"], d, config)
	transformed["observed_generation"] =
		flattenCloudRunJobStatusObservedGeneration(original["observedGeneration"], d, config)
	transformed["execution_count"] =
		flattenCloudRunJobStatusExecutionCount(original["executionCount"], d, config)
	transformed["latest_created_execution"] =
		flattenCloudRunJobStatusLatestCreatedExecution(original["latestCreatedExecution"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobStatusConditions(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"message": flattenCloudRunJobStatusConditionsMessage(original["message"], d, config),
			"status":  flattenCloudRunJobStatusConditionsStatus(original["status"], d, config),
			"reason":  flattenCloudRunJobStatusConditionsReason(original["reason"], d, config),
			"type":    flattenCloudRunJobStatusConditionsType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobStatusConditionsMessage(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusConditionsStatus(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusConditionsReason(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusConditionsType(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusUrl(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusObservedGeneration(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobStatusExecutionCount(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobStatusLatestCreatedExecution(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenCloudRunJobStatusLatestCreatedExecutionName(original["name"], d, config)
	transformed["creation_timestamp"] =
		flattenCloudRunJobStatusLatestCreatedExecutionCreationTimestamp(original["creationTimestamp"], d, config)
	transformed["completion_timestamp"] =
		flattenCloudRunJobStatusLatestCreatedExecutionCompletionTimestamp(original["completionTimestamp"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobStatusLatestCreatedExecutionName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusLatestCreatedExecutionCreationTimestamp(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusLatestCreatedExecutionCompletionTimestamp(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadata(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["labels"] =
		flattenCloudRunJobMetadataLabels(original["labels"], d, config)
	transformed["generation"] =
		flattenCloudRunJobMetadataGeneration(original["generation"], d, config)
	transformed["resource_version"] =
		flattenCloudRunJobMetadataResourceVersion(original["resourceVersion"], d, config)
	transformed["self_link"] =
		flattenCloudRunJobMetadataSelfLink(original["selfLink"], d, config)
	transformed["uid"] =
		flattenCloudRunJobMetadataUid(original["uid"], d, config)
	transformed["namespace"] =
		flattenCloudRunJobMetadataNamespace(original["namespace"], d, config)
	transformed["annotations"] =
		flattenCloudRunJobMetadataAnnotations(original["annotations"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobMetadataLabels(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadataGeneration(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobMetadataResourceVersion(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadataSelfLink(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadataUid(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobMetadataNamespace(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return d.Get("project")
}

func flattenCloudRunJobMetadataAnnotations(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandCloudRunJobSpec(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	transformed := make(map[string]interface{})
	transformedTemplate, err := expandCloudRunJobSpecTemplate(d.Get("template"), d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemplate); val.IsValid() && !isEmptyValue(val) {
		transformed["template"] = transformedTemplate
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplate(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMetadata, err := expandCloudRunJobSpecTemplateMetadata(original["metadata"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetadata); val.IsValid() && !isEmptyValue(val) {
		transformed["metadata"] = transformedMetadata
	}

	transformedSpec, err := expandCloudRunJobSpecTemplateSpec(original["spec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSpec); val.IsValid() && !isEmptyValue(val) {
		transformed["spec"] = transformedSpec
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateMetadata(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLabels, err := expandCloudRunJobSpecTemplateMetadataLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !isEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedGeneration, err := expandCloudRunJobSpecTemplateMetadataGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !isEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	transformedResourceVersion, err := expandCloudRunJobSpecTemplateMetadataResourceVersion(original["resource_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourceVersion); val.IsValid() && !isEmptyValue(val) {
		transformed["resourceVersion"] = transformedResourceVersion
	}

	transformedSelfLink, err := expandCloudRunJobSpecTemplateMetadataSelfLink(original["self_link"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSelfLink); val.IsValid() && !isEmptyValue(val) {
		transformed["selfLink"] = transformedSelfLink
	}

	transformedUid, err := expandCloudRunJobSpecTemplateMetadataUid(original["uid"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !isEmptyValue(val) {
		transformed["uid"] = transformedUid
	}

	transformedNamespace, err := expandCloudRunJobSpecTemplateMetadataNamespace(original["namespace"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespace); val.IsValid() && !isEmptyValue(val) {
		transformed["namespace"] = transformedNamespace
	}

	transformedAnnotations, err := expandCloudRunJobSpecTemplateMetadataAnnotations(original["annotations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAnnotations); val.IsValid() && !isEmptyValue(val) {
		transformed["annotations"] = transformedAnnotations
	}

	transformedName, err := expandCloudRunJobSpecTemplateMetadataName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateMetadataLabels(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpecTemplateMetadataGeneration(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataResourceVersion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataSelfLink(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataUid(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

// If the property hasn't been explicitly set in config use the project defined by the provider or env.
func expandCloudRunJobSpecTemplateMetadataNamespace(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	if v == nil {
		project, err := getProject(d, config)
		if err != nil {
			return project, nil
		}
	}
	return v, nil
}

func expandCloudRunJobSpecTemplateMetadataAnnotations(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpecTemplateMetadataName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	if d.Get("autogenerate_revision_name") == true {
		return nil, nil
	}
	return v, nil
}

func expandCloudRunJobSpecTemplateSpec(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedParallelism, err := expandCloudRunJobSpecTemplateSpecParallelism(original["parallelism"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParallelism); val.IsValid() && !isEmptyValue(val) {
		transformed["parallelism"] = transformedParallelism
	}

	transformedTaskCount, err := expandCloudRunJobSpecTemplateSpecTaskCount(original["task_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTaskCount); val.IsValid() && !isEmptyValue(val) {
		transformed["taskCount"] = transformedTaskCount
	}

	transformedTemplate, err := expandCloudRunJobSpecTemplateSpecTemplate(original["template"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTemplate); val.IsValid() && !isEmptyValue(val) {
		transformed["template"] = transformedTemplate
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecParallelism(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTaskCount(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplate(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSpec, err := expandCloudRunJobSpecTemplateSpecTemplateSpec(original["spec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSpec); val.IsValid() && !isEmptyValue(val) {
		transformed["spec"] = transformedSpec
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpec(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTimeoutSeconds, err := expandCloudRunJobSpecTemplateSpecTemplateSpecTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !isEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedServiceAccountName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecServiceAccountName(original["service_account_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccountName); val.IsValid() && !isEmptyValue(val) {
		transformed["serviceAccountName"] = transformedServiceAccountName
	}

	transformedMaxRetries, err := expandCloudRunJobSpecTemplateSpecTemplateSpecMaxRetries(original["max_retries"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxRetries); val.IsValid() && !isEmptyValue(val) {
		transformed["maxRetries"] = transformedMaxRetries
	}

	transformedContainers, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainers(original["containers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContainers); val.IsValid() && !isEmptyValue(val) {
		transformed["containers"] = transformedContainers
	}

	transformedVolumes, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumes(original["volumes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVolumes); val.IsValid() && !isEmptyValue(val) {
		transformed["volumes"] = transformedVolumes
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecTimeoutSeconds(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecServiceAccountName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecMaxRetries(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainers(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedWorkingDir, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersWorkingDir(original["working_dir"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedWorkingDir); val.IsValid() && !isEmptyValue(val) {
			transformed["workingDir"] = transformedWorkingDir
		}

		transformedArgs, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersArgs(original["args"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedArgs); val.IsValid() && !isEmptyValue(val) {
			transformed["args"] = transformedArgs
		}

		transformedEnvFrom, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFrom(original["env_from"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEnvFrom); val.IsValid() && !isEmptyValue(val) {
			transformed["envFrom"] = transformedEnvFrom
		}

		transformedImage, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersImage(original["image"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedImage); val.IsValid() && !isEmptyValue(val) {
			transformed["image"] = transformedImage
		}

		transformedCommand, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersCommand(original["command"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !isEmptyValue(val) {
			transformed["command"] = transformedCommand
		}

		transformedEnv, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnv(original["env"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEnv); val.IsValid() && !isEmptyValue(val) {
			transformed["env"] = transformedEnv
		}

		transformedPorts, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPorts(original["ports"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPorts); val.IsValid() && !isEmptyValue(val) {
			transformed["ports"] = transformedPorts
		}

		transformedResources, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResources(original["resources"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResources); val.IsValid() && !isEmptyValue(val) {
			transformed["resources"] = transformedResources
		}

		transformedVolumeMounts, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMounts(original["volume_mounts"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVolumeMounts); val.IsValid() && !isEmptyValue(val) {
			transformed["volumeMounts"] = transformedVolumeMounts
		}

		transformedStartupProbe, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbe(original["startup_probe"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStartupProbe); val.IsValid() && !isEmptyValue(val) {
			transformed["startupProbe"] = transformedStartupProbe
		}

		transformedLivenessProbe, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbe(original["liveness_probe"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLivenessProbe); val.IsValid() && !isEmptyValue(val) {
			transformed["livenessProbe"] = transformedLivenessProbe
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersWorkingDir(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersArgs(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFrom(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPrefix, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromPrefix(original["prefix"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPrefix); val.IsValid() && !isEmptyValue(val) {
			transformed["prefix"] = transformedPrefix
		}

		transformedConfigMapRef, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRef(original["config_map_ref"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedConfigMapRef); val.IsValid() && !isEmptyValue(val) {
			transformed["configMapRef"] = transformedConfigMapRef
		}

		transformedSecretRef, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRef(original["secret_ref"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecretRef); val.IsValid() && !isEmptyValue(val) {
			transformed["secretRef"] = transformedSecretRef
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromPrefix(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRef(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOptional, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefOptional(original["optional"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOptional); val.IsValid() && !isEmptyValue(val) {
		transformed["optional"] = transformedOptional
	}

	transformedLocalObjectReference, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference(original["local_object_reference"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalObjectReference); val.IsValid() && !isEmptyValue(val) {
		transformed["localObjectReference"] = transformedLocalObjectReference
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefOptional(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRef(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLocalObjectReference, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference(original["local_object_reference"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocalObjectReference); val.IsValid() && !isEmptyValue(val) {
		transformed["localObjectReference"] = transformedLocalObjectReference
	}

	transformedOptional, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefOptional(original["optional"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOptional); val.IsValid() && !isEmptyValue(val) {
		transformed["optional"] = transformedOptional
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvFromSecretRefOptional(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersImage(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersCommand(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnv(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	v = v.(*schema.Set).List()
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !isEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedValueFrom, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFrom(original["value_from"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValueFrom); val.IsValid() && !isEmptyValue(val) {
			transformed["valueFrom"] = transformedValueFrom
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValue(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFrom(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretKeyRef, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRef(original["secret_key_ref"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretKeyRef); val.IsValid() && !isEmptyValue(val) {
		transformed["secretKeyRef"] = transformedSecretKeyRef
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRef(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKey, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefKey(original["key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !isEmptyValue(val) {
		transformed["key"] = transformedKey
	}

	transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefName(original["name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
		transformed["name"] = transformedName
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersEnvValueFromSecretKeyRefName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPorts(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedProtocol, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsProtocol(original["protocol"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedProtocol); val.IsValid() && !isEmptyValue(val) {
			transformed["protocol"] = transformedProtocol
		}

		transformedContainerPort, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsContainerPort(original["container_port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainerPort); val.IsValid() && !isEmptyValue(val) {
			transformed["containerPort"] = transformedContainerPort
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsProtocol(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersPortsContainerPort(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResources(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLimits, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesLimits(original["limits"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLimits); val.IsValid() && !isEmptyValue(val) {
		transformed["limits"] = transformedLimits
	}

	transformedRequests, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesRequests(original["requests"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRequests); val.IsValid() && !isEmptyValue(val) {
		transformed["requests"] = transformedRequests
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesLimits(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersResourcesRequests(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMounts(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedMountPath, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsMountPath(original["mount_path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMountPath); val.IsValid() && !isEmptyValue(val) {
			transformed["mountPath"] = transformedMountPath
		}

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsMountPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersVolumeMountsName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbe(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInitialDelaySeconds, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeInitialDelaySeconds(original["initial_delay_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInitialDelaySeconds); val.IsValid() && !isEmptyValue(val) {
		transformed["initialDelaySeconds"] = transformedInitialDelaySeconds
	}

	transformedTimeoutSeconds, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !isEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedPeriodSeconds, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbePeriodSeconds(original["period_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeriodSeconds); val.IsValid() && !isEmptyValue(val) {
		transformed["periodSeconds"] = transformedPeriodSeconds
	}

	transformedFailureThreshold, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeFailureThreshold(original["failure_threshold"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFailureThreshold); val.IsValid() && !isEmptyValue(val) {
		transformed["failureThreshold"] = transformedFailureThreshold
	}

	transformedTcpSocket, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTcpSocket(original["tcp_socket"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["tcpSocket"] = transformedTcpSocket
	}

	transformedHttpGet, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGet(original["http_get"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["httpGet"] = transformedHttpGet
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeInitialDelaySeconds(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTimeoutSeconds(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbePeriodSeconds(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeFailureThreshold(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTcpSocket(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPort, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTcpSocketPort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !isEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeTcpSocketPort(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGet(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPath, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetPath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !isEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedHttpHeaders, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(original["http_headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHttpHeaders); val.IsValid() && !isEmptyValue(val) {
		transformed["httpHeaders"] = transformedHttpHeaders
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeadersName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeadersValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeadersName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersStartupProbeHttpGetHttpHeadersValue(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbe(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInitialDelaySeconds, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeInitialDelaySeconds(original["initial_delay_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInitialDelaySeconds); val.IsValid() && !isEmptyValue(val) {
		transformed["initialDelaySeconds"] = transformedInitialDelaySeconds
	}

	transformedTimeoutSeconds, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !isEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedPeriodSeconds, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbePeriodSeconds(original["period_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeriodSeconds); val.IsValid() && !isEmptyValue(val) {
		transformed["periodSeconds"] = transformedPeriodSeconds
	}

	transformedFailureThreshold, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeFailureThreshold(original["failure_threshold"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFailureThreshold); val.IsValid() && !isEmptyValue(val) {
		transformed["failureThreshold"] = transformedFailureThreshold
	}

	transformedHttpGet, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGet(original["http_get"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["httpGet"] = transformedHttpGet
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeInitialDelaySeconds(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeTimeoutSeconds(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbePeriodSeconds(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeFailureThreshold(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGet(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPath, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetPath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !isEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedHttpHeaders, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(original["http_headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHttpHeaders); val.IsValid() && !isEmptyValue(val) {
		transformed["httpHeaders"] = transformedHttpHeaders
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeadersValue(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumes(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !isEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedSecret, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecret(original["secret"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecret); val.IsValid() && !isEmptyValue(val) {
			transformed["secret"] = transformedSecret
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecret(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretName, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretSecretName(original["secret_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretName); val.IsValid() && !isEmptyValue(val) {
		transformed["secretName"] = transformedSecretName
	}

	transformedDefaultMode, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretDefaultMode(original["default_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefaultMode); val.IsValid() && !isEmptyValue(val) {
		transformed["defaultMode"] = transformedDefaultMode
	}

	transformedItems, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItems(original["items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedItems); val.IsValid() && !isEmptyValue(val) {
		transformed["items"] = transformedItems
	}

	return transformed, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretSecretName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretDefaultMode(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItems(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !isEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedPath, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsPath(original["path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !isEmptyValue(val) {
			transformed["path"] = transformedPath
		}

		transformedMode, err := expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsMode(original["mode"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !isEmptyValue(val) {
			transformed["mode"] = transformedMode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobSpecTemplateSpecTemplateSpecVolumesSecretItemsMode(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobMetadata(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLabels, err := expandCloudRunJobMetadataLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !isEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedGeneration, err := expandCloudRunJobMetadataGeneration(original["generation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGeneration); val.IsValid() && !isEmptyValue(val) {
		transformed["generation"] = transformedGeneration
	}

	transformedResourceVersion, err := expandCloudRunJobMetadataResourceVersion(original["resource_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedResourceVersion); val.IsValid() && !isEmptyValue(val) {
		transformed["resourceVersion"] = transformedResourceVersion
	}

	transformedSelfLink, err := expandCloudRunJobMetadataSelfLink(original["self_link"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSelfLink); val.IsValid() && !isEmptyValue(val) {
		transformed["selfLink"] = transformedSelfLink
	}

	transformedUid, err := expandCloudRunJobMetadataUid(original["uid"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUid); val.IsValid() && !isEmptyValue(val) {
		transformed["uid"] = transformedUid
	}

	transformedNamespace, err := expandCloudRunJobMetadataNamespace(original["namespace"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNamespace); val.IsValid() && !isEmptyValue(val) {
		transformed["namespace"] = transformedNamespace
	}

	transformedAnnotations, err := expandCloudRunJobMetadataAnnotations(original["annotations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAnnotations); val.IsValid() && !isEmptyValue(val) {
		transformed["annotations"] = transformedAnnotations
	}

	return transformed, nil
}

func expandCloudRunJobMetadataLabels(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunJobMetadataGeneration(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobMetadataResourceVersion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobMetadataSelfLink(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunJobMetadataUid(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

// If the property hasn't been explicitly set in config use the project defined by the provider or env.
func expandCloudRunJobMetadataNamespace(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	if v == nil {
		project, err := getProject(d, config)
		if err != nil {
			return project, nil
		}
	}
	return v, nil
}

func expandCloudRunJobMetadataAnnotations(v interface{}, d TerraformResourceData, config *Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func resourceCloudRunJobEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	name := d.Get("name").(string)
	if obj["metadata"] == nil {
		obj["metadata"] = make(map[string]interface{})
	}
	metadata := obj["metadata"].(map[string]interface{})
	metadata["name"] = name

	// The only acceptable version/kind right now
	obj["apiVersion"] = "run.googleapis.com/v1"
	obj["kind"] = "Job"
	return obj, nil
}

func resourceCloudRunJobDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	// metadata is not present if the API returns an error
	if obj, ok := res["metadata"]; ok {
		if meta, ok := obj.(map[string]interface{}); ok {
			res["name"] = meta["name"]
		} else {
			return nil, fmt.Errorf("Unable to decode 'metadata' block from API response.")
		}
	}
	return res, nil
}
