// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/helper/validation"
)

func resourceFirestoreField() *schema.Resource {
	return &schema.Resource{
		Create: resourceFirestoreFieldCreate,
		Read:   resourceFirestoreFieldRead,
		Delete: resourceFirestoreFieldDelete,

		Importer: &schema.ResourceImporter{
			State: resourceFirestoreFieldImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(10 * time.Minute),
			Delete: schema.DefaultTimeout(10 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"collection": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The collection being indexed.`,
			},
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `A name of the form
'projects/{project_id}/databases/{database_id}/collectionGroups/{collectionId}/fields/{field_id}'`,
			},
			"database": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The Firestore database id. Defaults to '"(default)"'.`,
				Default:     "(default)",
			},
			"index_config": {
				Type:     schema.TypeList,
				Optional: true,
				ForceNew: true,
				Description: `The index configuration for this field. If unset, field indexing will revert to the configuration defined
by the ancestorField. To explicitly remove all indexes for this field, specify an index config with an empty
list of indexes.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"indexes": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `The indexes supported for this field.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"fields": {
										Type:     schema.TypeList,
										Optional: true,
										ForceNew: true,
										Description: `The fields supported by this index. The last field entry is always for
the field path '__name__'. If, on creation, '__name__' was not
specified as the last field, it will be added automatically with the
same direction as that of the last field defined. If the final field
in a composite index is not directional, the '__name__' will be
ordered '"ASCENDING"' (unless explicitly specified otherwise).`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"array_config": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: validation.StringInSlice([]string{"CONTAINS", ""}, false),
													Description: `Indicates that this field supports operations on arrayValues. Only one of 'order' and 'arrayConfig' can
be specified. Possible values: ["CONTAINS"]`,
												},
												"field_path": {
													Type:        schema.TypeString,
													Optional:    true,
													ForceNew:    true,
													Description: `Name of the field.`,
												},
												"order": {
													Type:         schema.TypeString,
													Optional:     true,
													ForceNew:     true,
													ValidateFunc: validation.StringInSlice([]string{"ASCENDING", "DESCENDING", ""}, false),
													Description: `Indicates that this field supports ordering by the specified order or comparing using =, <, <=, >, >=.
Only one of 'order' and 'arrayConfig' can be specified. Possible values: ["ASCENDING", "DESCENDING"]`,
												},
											},
										},
									},
									"query_scope": {
										Type:         schema.TypeString,
										Optional:     true,
										ForceNew:     true,
										ValidateFunc: validation.StringInSlice([]string{"COLLECTION", "COLLECTION_GROUP", ""}, false),
										Description: `The scope at which a query is run. One of '"COLLECTION"' or
'"COLLECTION_GROUP"'. Defaults to '"COLLECTION"'. Default value: "COLLECTION" Possible values: ["COLLECTION", "COLLECTION_GROUP"]`,
										Default: "COLLECTION",
									},
								},
							},
						},
					},
				},
			},
			"ancestor_field": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Output only. Specifies the resource name of the Field from which this field's index configuration is set
(when usesAncestorConfig is true), or from which it would be set if this field had no index
configuration (when usesAncestorConfig is false).`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
	}
}

func resourceFirestoreFieldCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	obj := make(map[string]interface{})
	databaseProp, err := expandFirestoreFieldDatabase(d.Get("database"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("database"); !isEmptyValue(reflect.ValueOf(databaseProp)) && (ok || !reflect.DeepEqual(v, databaseProp)) {
		obj["database"] = databaseProp
	}
	collectionProp, err := expandFirestoreFieldCollection(d.Get("collection"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("collection"); !isEmptyValue(reflect.ValueOf(collectionProp)) && (ok || !reflect.DeepEqual(v, collectionProp)) {
		obj["collection"] = collectionProp
	}
	nameProp, err := expandFirestoreFieldName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	indexConfigProp, err := expandFirestoreFieldIndexConfig(d.Get("index_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("index_config"); !isEmptyValue(reflect.ValueOf(indexConfigProp)) && (ok || !reflect.DeepEqual(v, indexConfigProp)) {
		obj["indexConfig"] = indexConfigProp
	}

	obj, err = resourceFirestoreFieldEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{FirestoreBasePath}}projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/fields/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Field: %#v", obj)
	project, err := getProject(d, config)
	if err != nil {
		return err
	}
	res, err := sendRequestWithTimeout(config, "PATCH", project, url, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating Field: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/fields/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = firestoreOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Field",
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Field: %s", err)
	}

	if err := d.Set("name", flattenFirestoreFieldName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = replaceVars(d, config, "projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/fields/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Field %q: %#v", d.Id(), res)

	metadata := res["metadata"].(map[string]interface{})
	name := metadata["field"].(string)
	log.Printf("[DEBUG] Setting Field name, id to %s", name)

	stringParts := strings.Split(name, "/")
	if len(stringParts) != 8 {
		return fmt.Errorf(
			"Saw %s when the name is expected to have shape %s",
			d.Get("field"),
			"projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/fields/{{name}}",
		)
	}

	d.Set("name", stringParts[7])
	d.SetId(name)

	return resourceFirestoreFieldRead(d, meta)
}

func resourceFirestoreFieldRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	url, err := replaceVars(d, config, "{{FirestoreBasePath}}projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/fields/{{name}}")
	if err != nil {
		return err
	}

	project, err := getProject(d, config)
	if err != nil {
		return err
	}
	res, err := sendRequest(config, "GET", project, url, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("FirestoreField %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Field: %s", err)
	}

	if err := d.Set("name", flattenFirestoreFieldName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Field: %s", err)
	}
	if err := d.Set("ancestor_field", flattenFirestoreFieldAncestorField(res["ancestorField"], d, config)); err != nil {
		return fmt.Errorf("Error reading Field: %s", err)
	}
	if err := d.Set("index_config", flattenFirestoreFieldIndexConfig(res["indexConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Field: %s", err)
	}

	return nil
}

func resourceFirestoreFieldDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	obj := make(map[string]interface{})
	databaseProp, err := expandFirestoreFieldDatabase(d.Get("database"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("database"); !isEmptyValue(reflect.ValueOf(databaseProp)) && (ok || !reflect.DeepEqual(v, databaseProp)) {
		obj["database"] = databaseProp
	}
	collectionProp, err := expandFirestoreFieldCollection(d.Get("collection"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("collection"); !isEmptyValue(reflect.ValueOf(collectionProp)) && (ok || !reflect.DeepEqual(v, collectionProp)) {
		obj["collection"] = collectionProp
	}
	nameProp, err := expandFirestoreFieldName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}

	obj, err = resourceFirestoreFieldEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{FirestoreBasePath}}{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Deleting Field: %#v", obj)
	project, err := getProject(d, config)
	if err != nil {
		return err
	}
	res, err := sendRequestWithTimeout(config, "PATCH", project, url, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return fmt.Errorf("Error deleting Field: %s", err)
	}

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = firestoreOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Field",
		d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return fmt.Errorf("Error waiting to delete Field: %s", err)
	}

	log.Printf("[DEBUG] Finished deleting Field %q: %#v", d.Id(), res)

	return resourceFirestoreFieldRead(d, meta)
}

func resourceFirestoreFieldImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {

	config := meta.(*Config)

	// current import_formats can't import fields with forward slashes in their value
	if err := parseImportId([]string{"(?P<field>.+)"}, d, config); err != nil {
		return nil, err
	}

	stringParts := strings.Split(d.Get("field").(string), "/")
	if len(stringParts) != 8 {
		return nil, fmt.Errorf(
			"Saw %s when the name is expected to have shape %s",
			d.Get("field"),
			"projects/{{project}}/databases/{{database}}/collectionGroups/{{collection}}/fields/{{name}}",
		)
	}

	d.Set("project", stringParts[1])
	d.Set("database", stringParts[3])
	d.Set("collection", stringParts[5])
	d.Set("name", stringParts[7])
	return []*schema.ResourceData{d}, nil
}

func flattenFirestoreFieldName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenFirestoreFieldAncestorField(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenFirestoreFieldIndexConfig(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["indexes"] =
		flattenFirestoreFieldIndexConfigIndexes(original["indexes"], d, config)
	return []interface{}{transformed}
}
func flattenFirestoreFieldIndexConfigIndexes(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"query_scope": flattenFirestoreFieldIndexConfigIndexesQueryScope(original["queryScope"], d, config),
			"fields":      flattenFirestoreFieldIndexConfigIndexesFields(original["fields"], d, config),
		})
	}
	return transformed
}
func flattenFirestoreFieldIndexConfigIndexesQueryScope(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenFirestoreFieldIndexConfigIndexesFields(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"field_path":   flattenFirestoreFieldIndexConfigIndexesFieldsFieldPath(original["fieldPath"], d, config),
			"order":        flattenFirestoreFieldIndexConfigIndexesFieldsOrder(original["order"], d, config),
			"array_config": flattenFirestoreFieldIndexConfigIndexesFieldsArrayConfig(original["arrayConfig"], d, config),
		})
	}
	return transformed
}
func flattenFirestoreFieldIndexConfigIndexesFieldsFieldPath(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenFirestoreFieldIndexConfigIndexesFieldsOrder(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenFirestoreFieldIndexConfigIndexesFieldsArrayConfig(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandFirestoreFieldDatabase(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirestoreFieldCollection(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirestoreFieldName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirestoreFieldIndexConfig(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedIndexes, err := expandFirestoreFieldIndexConfigIndexes(original["indexes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIndexes); val.IsValid() && !isEmptyValue(val) {
		transformed["indexes"] = transformedIndexes
	}

	return transformed, nil
}

func expandFirestoreFieldIndexConfigIndexes(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedQueryScope, err := expandFirestoreFieldIndexConfigIndexesQueryScope(original["query_scope"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedQueryScope); val.IsValid() && !isEmptyValue(val) {
			transformed["queryScope"] = transformedQueryScope
		}

		transformedFields, err := expandFirestoreFieldIndexConfigIndexesFields(original["fields"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFields); val.IsValid() && !isEmptyValue(val) {
			transformed["fields"] = transformedFields
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandFirestoreFieldIndexConfigIndexesQueryScope(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirestoreFieldIndexConfigIndexesFields(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedFieldPath, err := expandFirestoreFieldIndexConfigIndexesFieldsFieldPath(original["field_path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFieldPath); val.IsValid() && !isEmptyValue(val) {
			transformed["fieldPath"] = transformedFieldPath
		}

		transformedOrder, err := expandFirestoreFieldIndexConfigIndexesFieldsOrder(original["order"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOrder); val.IsValid() && !isEmptyValue(val) {
			transformed["order"] = transformedOrder
		}

		transformedArrayConfig, err := expandFirestoreFieldIndexConfigIndexesFieldsArrayConfig(original["array_config"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedArrayConfig); val.IsValid() && !isEmptyValue(val) {
			transformed["arrayConfig"] = transformedArrayConfig
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandFirestoreFieldIndexConfigIndexesFieldsFieldPath(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirestoreFieldIndexConfigIndexesFieldsOrder(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirestoreFieldIndexConfigIndexesFieldsArrayConfig(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func resourceFirestoreFieldEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {

	delete(obj, "project")
	delete(obj, "database")
	delete(obj, "collection")
	delete(obj, "name")
	return obj, nil
}
