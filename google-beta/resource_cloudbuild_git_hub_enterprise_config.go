// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceCloudBuildGitHubEnterpriseConfig() *schema.Resource {
	return &schema.Resource{
		Create: resourceCloudBuildGitHubEnterpriseConfigCreate,
		Read:   resourceCloudBuildGitHubEnterpriseConfigRead,
		Update: resourceCloudBuildGitHubEnterpriseConfigUpdate,
		Delete: resourceCloudBuildGitHubEnterpriseConfigDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCloudBuildGitHubEnterpriseConfigImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"app_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The GitHub app id of the Cloud Build app on the GitHub Enterprise server.`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Name to display for this config.`,
			},
			"host_url": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The URL of the github enterprise host the configuration is for.`,
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `The full resource name for the GitHubEnterpriseConfig For example: "projects/{$projectId}/githubEnterpriseConfigs/{$configId}"`,
			},
			"peered_network": {
				Type:     schema.TypeString,
				Optional: true,
				Description: `The U$RI of the repo (optional). If unspecified, the repo from which the trigger 
invocation originated is assumed to be the repo from which to read the specified path.
Optional. The network to be used when reaching out to the GitHub Enterprise server.
The VPC network must be enabled for private service connection. 
This should be set if the GitHub Enterprise server is hosted on-premises and not reachable by public internet.
If this field is left empty, no network peering will occur and calls to the GitHub Enterprise server will be made over the public internet.
Must be in the format projects/{project}/global/networks/{network}, where {project} is a project number or id and {network} is the name of a VPC network in the project.`,
			},
			"private_key_name": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Names of secrets in Secret Manager.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"private_key_version_name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The resource name for the private key secret version.`,
						},
						"oauth_client_id_version_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The resource name for the OAuth client ID secret version in Secret Manager.`,
						},
						"oauth_secret_version_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The resource name for the OAuth secret secret version in Secret Manager.`,
						},
						"webhook_secret_version_name": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The resource name for the webhook secret secret version in Secret Manager.`,
						},
					},
				},
			},
			"project_id": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The ProjectId where the resouce should be creted.`,
			},
			"ssl_ca": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Optional. SSL certificate to use for requests to GitHub Enterprise.`,
			},
			"webhook_key": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The key that should be attached to webhook calls to the v1.webhook endpoint.`,
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Output only. Time when the installation was associated with the project.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. 
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCloudBuildGitHubEnterpriseConfigCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandCloudBuildGitHubEnterpriseConfigName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	appIdProp, err := expandCloudBuildGitHubEnterpriseConfigAppId(d.Get("app_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("app_id"); !isEmptyValue(reflect.ValueOf(appIdProp)) && (ok || !reflect.DeepEqual(v, appIdProp)) {
		obj["appId"] = appIdProp
	}
	webhookKeyProp, err := expandCloudBuildGitHubEnterpriseConfigWebhookKey(d.Get("webhook_key"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("webhook_key"); !isEmptyValue(reflect.ValueOf(webhookKeyProp)) && (ok || !reflect.DeepEqual(v, webhookKeyProp)) {
		obj["webhookKey"] = webhookKeyProp
	}
	peeredNetworkProp, err := expandCloudBuildGitHubEnterpriseConfigPeeredNetwork(d.Get("peered_network"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("peered_network"); !isEmptyValue(reflect.ValueOf(peeredNetworkProp)) && (ok || !reflect.DeepEqual(v, peeredNetworkProp)) {
		obj["peeredNetwork"] = peeredNetworkProp
	}
	privateKeyNameProp, err := expandCloudBuildGitHubEnterpriseConfigPrivateKeyName(d.Get("private_key_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("private_key_name"); !isEmptyValue(reflect.ValueOf(privateKeyNameProp)) && (ok || !reflect.DeepEqual(v, privateKeyNameProp)) {
		obj["privateKeyName"] = privateKeyNameProp
	}
	displayNameProp, err := expandCloudBuildGitHubEnterpriseConfigDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !isEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	sslCaProp, err := expandCloudBuildGitHubEnterpriseConfigSslCa(d.Get("ssl_ca"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ssl_ca"); !isEmptyValue(reflect.ValueOf(sslCaProp)) && (ok || !reflect.DeepEqual(v, sslCaProp)) {
		obj["sslCa"] = sslCaProp
	}
	projectIdProp, err := expandCloudBuildGitHubEnterpriseConfigProjectId(d.Get("project_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("project_id"); !isEmptyValue(reflect.ValueOf(projectIdProp)) && (ok || !reflect.DeepEqual(v, projectIdProp)) {
		obj["projectId"] = projectIdProp
	}

	url, err := replaceVars(d, config, "{{CloudBuildBasePath}}projects/{{projectId}}/githubEnterpriseConfigs")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new GitHubEnterpriseConfig: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating GitHubEnterpriseConfig: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{$projectId}}/githubEnterpriseConfigs/{{configId}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating GitHubEnterpriseConfig %q: %#v", d.Id(), res)

	return resourceCloudBuildGitHubEnterpriseConfigRead(d, meta)
}

func resourceCloudBuildGitHubEnterpriseConfigRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudBuildBasePath}}projects/{{$projectId}}/githubEnterpriseConfigs/{{configId}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("CloudBuildGitHubEnterpriseConfig %q", d.Id()))
	}

	if err := d.Set("name", flattenCloudBuildGitHubEnterpriseConfigName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}
	if err := d.Set("app_id", flattenCloudBuildGitHubEnterpriseConfigAppId(res["appId"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}
	if err := d.Set("create_time", flattenCloudBuildGitHubEnterpriseConfigCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}
	if err := d.Set("webhook_key", flattenCloudBuildGitHubEnterpriseConfigWebhookKey(res["webhookKey"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}
	if err := d.Set("peered_network", flattenCloudBuildGitHubEnterpriseConfigPeeredNetwork(res["peeredNetwork"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}
	if err := d.Set("private_key_name", flattenCloudBuildGitHubEnterpriseConfigPrivateKeyName(res["privateKeyName"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}
	if err := d.Set("display_name", flattenCloudBuildGitHubEnterpriseConfigDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}
	if err := d.Set("ssl_ca", flattenCloudBuildGitHubEnterpriseConfigSslCa(res["sslCa"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}
	if err := d.Set("project_id", flattenCloudBuildGitHubEnterpriseConfigProjectId(res["projectId"], d, config)); err != nil {
		return fmt.Errorf("Error reading GitHubEnterpriseConfig: %s", err)
	}

	return nil
}

func resourceCloudBuildGitHubEnterpriseConfigUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	obj := make(map[string]interface{})
	nameProp, err := expandCloudBuildGitHubEnterpriseConfigName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	peeredNetworkProp, err := expandCloudBuildGitHubEnterpriseConfigPeeredNetwork(d.Get("peered_network"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("peered_network"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, peeredNetworkProp)) {
		obj["peeredNetwork"] = peeredNetworkProp
	}
	privateKeyNameProp, err := expandCloudBuildGitHubEnterpriseConfigPrivateKeyName(d.Get("private_key_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("private_key_name"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, privateKeyNameProp)) {
		obj["privateKeyName"] = privateKeyNameProp
	}
	displayNameProp, err := expandCloudBuildGitHubEnterpriseConfigDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	sslCaProp, err := expandCloudBuildGitHubEnterpriseConfigSslCa(d.Get("ssl_ca"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ssl_ca"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, sslCaProp)) {
		obj["sslCa"] = sslCaProp
	}

	url, err := replaceVars(d, config, "{{CloudBuildBasePath}}projects/{{$projectId}}/githubEnterpriseConfigs/{{configId}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating GitHubEnterpriseConfig %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PATCH", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating GitHubEnterpriseConfig %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating GitHubEnterpriseConfig %q: %#v", d.Id(), res)
	}

	return resourceCloudBuildGitHubEnterpriseConfigRead(d, meta)
}

func resourceCloudBuildGitHubEnterpriseConfigDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := replaceVars(d, config, "{{CloudBuildBasePath}}projects/{{$projectId}}/githubEnterpriseConfigs/{{configId}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting GitHubEnterpriseConfig %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "GitHubEnterpriseConfig")
	}

	log.Printf("[DEBUG] Finished deleting GitHubEnterpriseConfig %q: %#v", d.Id(), res)
	return nil
}

func resourceCloudBuildGitHubEnterpriseConfigImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"projects/(?P<project_id>[^/]+)/githubEnterpriseConfigs/(?P<name>[^/]+)",
		"(?P<project_id>[^/]+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "projects/{{$projectId}}/githubEnterpriseConfigs/{{configId}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCloudBuildGitHubEnterpriseConfigName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigAppId(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigCreateTime(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigWebhookKey(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigPeeredNetwork(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigPrivateKeyName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["private_key_version_name"] =
		flattenCloudBuildGitHubEnterpriseConfigPrivateKeyNamePrivateKeyVersionName(original["privateKeyVersionName"], d, config)
	transformed["webhook_secret_version_name"] =
		flattenCloudBuildGitHubEnterpriseConfigPrivateKeyNameWebhookSecretVersionName(original["webhookSecretVersionName"], d, config)
	transformed["oauth_secret_version_name"] =
		flattenCloudBuildGitHubEnterpriseConfigPrivateKeyNameOauthSecretVersionName(original["oauthSecretVersionName"], d, config)
	transformed["oauth_client_id_version_name"] =
		flattenCloudBuildGitHubEnterpriseConfigPrivateKeyNameOauthClientIdVersionName(original["oauthClientIdVersionName"], d, config)
	return []interface{}{transformed}
}
func flattenCloudBuildGitHubEnterpriseConfigPrivateKeyNamePrivateKeyVersionName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigPrivateKeyNameWebhookSecretVersionName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigPrivateKeyNameOauthSecretVersionName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigPrivateKeyNameOauthClientIdVersionName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigDisplayName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigSslCa(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudBuildGitHubEnterpriseConfigProjectId(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandCloudBuildGitHubEnterpriseConfigName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigAppId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigWebhookKey(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigPeeredNetwork(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigPrivateKeyName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPrivateKeyVersionName, err := expandCloudBuildGitHubEnterpriseConfigPrivateKeyNamePrivateKeyVersionName(original["private_key_version_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPrivateKeyVersionName); val.IsValid() && !isEmptyValue(val) {
		transformed["privateKeyVersionName"] = transformedPrivateKeyVersionName
	}

	transformedWebhookSecretVersionName, err := expandCloudBuildGitHubEnterpriseConfigPrivateKeyNameWebhookSecretVersionName(original["webhook_secret_version_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedWebhookSecretVersionName); val.IsValid() && !isEmptyValue(val) {
		transformed["webhookSecretVersionName"] = transformedWebhookSecretVersionName
	}

	transformedOauthSecretVersionName, err := expandCloudBuildGitHubEnterpriseConfigPrivateKeyNameOauthSecretVersionName(original["oauth_secret_version_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthSecretVersionName); val.IsValid() && !isEmptyValue(val) {
		transformed["oauthSecretVersionName"] = transformedOauthSecretVersionName
	}

	transformedOauthClientIdVersionName, err := expandCloudBuildGitHubEnterpriseConfigPrivateKeyNameOauthClientIdVersionName(original["oauth_client_id_version_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOauthClientIdVersionName); val.IsValid() && !isEmptyValue(val) {
		transformed["oauthClientIdVersionName"] = transformedOauthClientIdVersionName
	}

	return transformed, nil
}

func expandCloudBuildGitHubEnterpriseConfigPrivateKeyNamePrivateKeyVersionName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigPrivateKeyNameWebhookSecretVersionName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigPrivateKeyNameOauthSecretVersionName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigPrivateKeyNameOauthClientIdVersionName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigDisplayName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigSslCa(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandCloudBuildGitHubEnterpriseConfigProjectId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
