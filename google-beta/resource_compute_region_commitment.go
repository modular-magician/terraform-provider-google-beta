// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceComputeRegionCommitment() *schema.Resource {
	return &schema.Resource{
		Create: resourceComputeRegionCommitmentCreate,
		Read:   resourceComputeRegionCommitmentRead,
		Update: resourceComputeRegionCommitmentUpdate,
		Delete: resourceComputeRegionCommitmentDelete,

		Importer: &schema.ResourceImporter{
			State: resourceComputeRegionCommitmentImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"category": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validateEnum([]string{"MACHINE", "LICENSE"}),
				Description: `The category of the commitment. Category MACHINE specifies commitments 
composed of machine resources such as VCPU or MEMORY, listed in resources. 
Category LICENSE specifies commitments composed of software licenses, 
listed in licenseResources. Note that only MACHINE commitments should have a Type specified. Possible values: ["MACHINE", "LICENSE"]`,
			},
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Name of the resource. The name must be 1-63 characters long, and comply with
RFC1035. Specifically, the name must be 1-63 characters long and match
the regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' which means the
first character must be a lowercase letter, and all following
characters must be a dash, lowercase letter, or digit, except the last
character, which cannot be a dash.`,
			},
			"plan": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validateEnum([]string{"TWELVE_MONTH", "THIRTY_SIX_MONTH"}),
				Description: `The plan for this commitment, which determines duration and discount rate. 
The currently supported plans are TWELVE_MONTH (1 year), and THIRTY_SIX_MONTH (3 years). Possible values: ["TWELVE_MONTH", "THIRTY_SIX_MONTH"]`,
			},
			"region": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: compareSelfLinkOrResourceName,
				Description:      `The region where the commitment is made.`,
			},
			"type": {
				Type:     schema.TypeString,
				Required: true,
				Description: `The type of commitment, which affects the discount rate and the eligible resources. 
Type MEMORY_OPTIMIZED specifies a commitment that will only apply to memory optimized machines. 
Type ACCELERATOR_OPTIMIZED specifies a commitment that will only apply to accelerator optimized machines.`,
			},
			"auto_renew": {
				Type:     schema.TypeBool,
				Optional: true,
				Description: `Specifies whether to enable automatic renewal for the commitment. 
The default value is false if not specified. 
The field can be updated until the day of the commitment expiration at 12:00am PST. 
If the field is set to true, the commitment will be automatically renewed for either 
one or three years according to the terms of the existing commitment.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An optional description of this resource.`,
			},
			"license_resource": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The license specification required as part of a license commitment.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"amount": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The number of licenses purchased.`,
						},
						"cores_per_license": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Specifies the core range of the instance for which this license applies.`,
						},
						"license": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Any applicable license URI.`,
						},
					},
				},
				ExactlyOneOf: []string{"resources", "license_resource"},
			},
			"resources": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `A list of commitment amounts for particular resources. 
Note that VCPU and MEMORY resource commitments must occur together.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"accelerator_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Name of the accelerator type resource. Applicable only when the type is ACCELERATOR.`,
						},
						"amount": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Amount of the resource. Memory must be be specified in MB.`,
						},
						"type": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validateEnum([]string{"VCPU", "MEMORY", ""}),
							Description:  `Type of resource for which this commitment applies. Possible values are VCPU and MEMORY Possible values: ["VCPU", "MEMORY"]`,
						},
					},
				},
				ExactlyOneOf: []string{"resources", "license_resource"},
			},
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The unique identifier for the resource.`,
			},
			"status": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Status of the commitment with regards to eventual expiration (each commitment 
has an end date defined). One of the following values: NOT_YET_ACTIVE, ACTIVE, EXPIRED.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"self_link": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceComputeRegionCommitmentCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandComputeRegionCommitmentName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !isEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	descriptionProp, err := expandComputeRegionCommitmentDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !isEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	resourcesProp, err := expandComputeRegionCommitmentResources(d.Get("resources"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("resources"); !isEmptyValue(reflect.ValueOf(resourcesProp)) && (ok || !reflect.DeepEqual(v, resourcesProp)) {
		obj["resources"] = resourcesProp
	}
	planProp, err := expandComputeRegionCommitmentPlan(d.Get("plan"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("plan"); !isEmptyValue(reflect.ValueOf(planProp)) && (ok || !reflect.DeepEqual(v, planProp)) {
		obj["plan"] = planProp
	}
	typeProp, err := expandComputeRegionCommitmentType(d.Get("type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("type"); !isEmptyValue(reflect.ValueOf(typeProp)) && (ok || !reflect.DeepEqual(v, typeProp)) {
		obj["type"] = typeProp
	}
	categoryProp, err := expandComputeRegionCommitmentCategory(d.Get("category"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("category"); !isEmptyValue(reflect.ValueOf(categoryProp)) && (ok || !reflect.DeepEqual(v, categoryProp)) {
		obj["category"] = categoryProp
	}
	licenseResourceProp, err := expandComputeRegionCommitmentLicenseResource(d.Get("license_resource"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("license_resource"); !isEmptyValue(reflect.ValueOf(licenseResourceProp)) && (ok || !reflect.DeepEqual(v, licenseResourceProp)) {
		obj["licenseResource"] = licenseResourceProp
	}
	autoRenewProp, err := expandComputeRegionCommitmentAutoRenew(d.Get("auto_renew"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_renew"); !isEmptyValue(reflect.ValueOf(autoRenewProp)) && (ok || !reflect.DeepEqual(v, autoRenewProp)) {
		obj["autoRenew"] = autoRenewProp
	}
	regionProp, err := expandComputeRegionCommitmentRegion(d.Get("region"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("region"); !isEmptyValue(reflect.ValueOf(regionProp)) && (ok || !reflect.DeepEqual(v, regionProp)) {
		obj["region"] = regionProp
	}

	url, err := replaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/regions/{{region}}/commitments")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new RegionCommitment: %#v", obj)
	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RegionCommitment: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating RegionCommitment: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{project}}/regions/{{region}}/commitments/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating RegionCommitment %q: %#v", d.Id(), res)

	return resourceComputeRegionCommitmentRead(d, meta)
}

func resourceComputeRegionCommitmentRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/regions/{{region}}/commitments/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RegionCommitment: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("ComputeRegionCommitment %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}

	if err := d.Set("id", flattenComputeRegionCommitmentId(res["id"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("name", flattenComputeRegionCommitmentName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("description", flattenComputeRegionCommitmentDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("status", flattenComputeRegionCommitmentStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("resources", flattenComputeRegionCommitmentResources(res["resources"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("plan", flattenComputeRegionCommitmentPlan(res["plan"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("type", flattenComputeRegionCommitmentType(res["type"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("category", flattenComputeRegionCommitmentCategory(res["category"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("license_resource", flattenComputeRegionCommitmentLicenseResource(res["licenseResource"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("auto_renew", flattenComputeRegionCommitmentAutoRenew(res["autoRenew"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("region", flattenComputeRegionCommitmentRegion(res["region"], d, config)); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}
	if err := d.Set("self_link", ConvertSelfLinkToV1(res["selfLink"].(string))); err != nil {
		return fmt.Errorf("Error reading RegionCommitment: %s", err)
	}

	return nil
}

func resourceComputeRegionCommitmentUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RegionCommitment: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandComputeRegionCommitmentDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	resourcesProp, err := expandComputeRegionCommitmentResources(d.Get("resources"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("resources"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, resourcesProp)) {
		obj["resources"] = resourcesProp
	}
	planProp, err := expandComputeRegionCommitmentPlan(d.Get("plan"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("plan"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, planProp)) {
		obj["plan"] = planProp
	}
	typeProp, err := expandComputeRegionCommitmentType(d.Get("type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("type"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, typeProp)) {
		obj["type"] = typeProp
	}
	categoryProp, err := expandComputeRegionCommitmentCategory(d.Get("category"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("category"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, categoryProp)) {
		obj["category"] = categoryProp
	}
	licenseResourceProp, err := expandComputeRegionCommitmentLicenseResource(d.Get("license_resource"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("license_resource"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, licenseResourceProp)) {
		obj["licenseResource"] = licenseResourceProp
	}
	autoRenewProp, err := expandComputeRegionCommitmentAutoRenew(d.Get("auto_renew"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auto_renew"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, autoRenewProp)) {
		obj["autoRenew"] = autoRenewProp
	}

	url, err := replaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/regions/{{region}}/commitments/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating RegionCommitment %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("resources") {
		updateMask = append(updateMask, "resources")
	}

	if d.HasChange("plan") {
		updateMask = append(updateMask, "plan")
	}

	if d.HasChange("type") {
		updateMask = append(updateMask, "type")
	}

	if d.HasChange("category") {
		updateMask = append(updateMask, "category")
	}

	if d.HasChange("license_resource") {
		updateMask = append(updateMask, "licenseResource")
	}

	if d.HasChange("auto_renew") {
		updateMask = append(updateMask, "autoRenew")
	}
	// updateMask is a URL parameter but not present in the schema, so replaceVars
	// won't set it
	url, err = addQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PATCH", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating RegionCommitment %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating RegionCommitment %q: %#v", d.Id(), res)
	}

	return resourceComputeRegionCommitmentRead(d, meta)
}

func resourceComputeRegionCommitmentDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for RegionCommitment: %s", err)
	}
	billingProject = project

	url, err := replaceVars(d, config, "{{ComputeBasePath}}projects/{{project}}/regions/{{region}}/commitments/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting RegionCommitment %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "RegionCommitment")
	}

	log.Printf("[DEBUG] Finished deleting RegionCommitment %q: %#v", d.Id(), res)
	return nil
}

func resourceComputeRegionCommitmentImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"projects/(?P<project>[^/]+)/regions/(?P<region>[^/]+)/commitments/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<region>[^/]+)/(?P<name>[^/]+)",
		"(?P<region>[^/]+)/(?P<name>[^/]+)",
		"(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "projects/{{project}}/regions/{{region}}/commitments/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenComputeRegionCommitmentId(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentDescription(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentStatus(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentResources(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":             flattenComputeRegionCommitmentResourcesType(original["type"], d, config),
			"amount":           flattenComputeRegionCommitmentResourcesAmount(original["amount"], d, config),
			"accelerator_type": flattenComputeRegionCommitmentResourcesAcceleratorType(original["acceleratorType"], d, config),
		})
	}
	return transformed
}
func flattenComputeRegionCommitmentResourcesType(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentResourcesAmount(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentResourcesAcceleratorType(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentPlan(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentType(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentCategory(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentLicenseResource(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["license"] =
		flattenComputeRegionCommitmentLicenseResourceLicense(original["license"], d, config)
	transformed["amount"] =
		flattenComputeRegionCommitmentLicenseResourceAmount(original["amount"], d, config)
	transformed["cores_per_license"] =
		flattenComputeRegionCommitmentLicenseResourceCoresPerLicense(original["coresPerLicense"], d, config)
	return []interface{}{transformed}
}
func flattenComputeRegionCommitmentLicenseResourceLicense(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentLicenseResourceAmount(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentLicenseResourceCoresPerLicense(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentAutoRenew(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenComputeRegionCommitmentRegion(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	return ConvertSelfLinkToV1(v.(string))
}

func expandComputeRegionCommitmentName(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentDescription(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentResources(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandComputeRegionCommitmentResourcesType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !isEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedAmount, err := expandComputeRegionCommitmentResourcesAmount(original["amount"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAmount); val.IsValid() && !isEmptyValue(val) {
			transformed["amount"] = transformedAmount
		}

		transformedAcceleratorType, err := expandComputeRegionCommitmentResourcesAcceleratorType(original["accelerator_type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedAcceleratorType); val.IsValid() && !isEmptyValue(val) {
			transformed["acceleratorType"] = transformedAcceleratorType
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandComputeRegionCommitmentResourcesType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentResourcesAmount(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentResourcesAcceleratorType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentPlan(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentType(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentCategory(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentLicenseResource(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLicense, err := expandComputeRegionCommitmentLicenseResourceLicense(original["license"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLicense); val.IsValid() && !isEmptyValue(val) {
		transformed["license"] = transformedLicense
	}

	transformedAmount, err := expandComputeRegionCommitmentLicenseResourceAmount(original["amount"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAmount); val.IsValid() && !isEmptyValue(val) {
		transformed["amount"] = transformedAmount
	}

	transformedCoresPerLicense, err := expandComputeRegionCommitmentLicenseResourceCoresPerLicense(original["cores_per_license"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCoresPerLicense); val.IsValid() && !isEmptyValue(val) {
		transformed["coresPerLicense"] = transformedCoresPerLicense
	}

	return transformed, nil
}

func expandComputeRegionCommitmentLicenseResourceLicense(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentLicenseResourceAmount(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentLicenseResourceCoresPerLicense(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentAutoRenew(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandComputeRegionCommitmentRegion(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	f, err := parseGlobalFieldValue("regions", v.(string), "project", d, config, true)
	if err != nil {
		return nil, fmt.Errorf("Invalid value for region: %s", err)
	}
	return f.RelativeLink(), nil
}
