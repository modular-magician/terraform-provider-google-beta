// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func ResourceLoggingProjectLinkedDataset() *schema.Resource {
	return &schema.Resource{
		Create: resourceLoggingProjectLinkedDatasetCreate,
		Read:   resourceLoggingProjectLinkedDatasetRead,
		Update: resourceLoggingProjectLinkedDatasetUpdate,
		Delete: resourceLoggingProjectLinkedDatasetDelete,

		Importer: &schema.ResourceImporter{
			State: resourceLoggingProjectLinkedDatasetImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"bucket": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The bucket for which the linked dataset will be created`,
			},
			"link_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The id of the linked dataset.`,
			},
			"bigquery_dataset": {
				Type:     schema.TypeList,
				Computed: true,
				Optional: true,
				Description: `The information of a BigQuery Dataset. When a link is created, a BigQuery dataset is created along
with it, in the same project as the LogBucket it's linked to. This dataset will also have BigQuery
Views corresponding to the LogViews in the bucket.`,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"dataset_id": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Output only. The full resource name of the BigQuery dataset. The DATASET_ID will match the ID
of the link, so the link must match the naming restrictions of BigQuery datasets
(alphanumeric characters and underscores only). The dataset will have a resource path of
"bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET_ID]"`,
						},
					},
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Describes this link. The maximum length of the description is 8000 characters.`,
			},
			"create_time": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `Output only. The creation timestamp of the link. A timestamp in RFC3339 UTC "Zulu" format,
with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z"
and "2014-10-02T15:01:23.045123456Z".`,
			},
			"lifecycle_state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The resource lifecycle state.`,
			},
			"name": {
				Type:     schema.TypeString,
				Computed: true,
				Description: `The resource name of the linked dataset. The name can have up to 100 characters. A valid link id
(at the end of the link name) must only have alphanumeric characters and underscores within it.`,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceLoggingProjectLinkedDatasetCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandLoggingProjectLinkedDatasetDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !isEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	bigqueryDatasetProp, err := expandLoggingProjectLinkedDatasetBigqueryDataset(d.Get("bigquery_dataset"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bigquery_dataset"); !isEmptyValue(reflect.ValueOf(bigqueryDatasetProp)) && (ok || !reflect.DeepEqual(v, bigqueryDatasetProp)) {
		obj["bigqueryDataset"] = bigqueryDatasetProp
	}

	url, err := replaceVars(d, config, "{{LoggingBasePath}}{{bucket}}/links?linkId={{link_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new ProjectLinkedDataset: %#v", obj)
	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := SendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating ProjectLinkedDataset: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "{{bucket}}/links/{{link_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = LoggingOperationWaitTimeWithResponse(
		config, res, &opRes, "Creating ProjectLinkedDataset", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create ProjectLinkedDataset: %s", err)
	}

	if err := d.Set("name", flattenLoggingProjectLinkedDatasetName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = replaceVars(d, config, "{{bucket}}/links/{{link_id}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating ProjectLinkedDataset %q: %#v", d.Id(), res)

	return resourceLoggingProjectLinkedDatasetRead(d, meta)
}

func resourceLoggingProjectLinkedDatasetRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{LoggingBasePath}}{{bucket}}/links/{{link_id}}")
	if err != nil {
		return err
	}

	billingProject := ""

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := SendRequest(config, "GET", billingProject, url, userAgent, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("LoggingProjectLinkedDataset %q", d.Id()))
	}

	if err := d.Set("name", flattenLoggingProjectLinkedDatasetName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectLinkedDataset: %s", err)
	}
	if err := d.Set("description", flattenLoggingProjectLinkedDatasetDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectLinkedDataset: %s", err)
	}
	if err := d.Set("create_time", flattenLoggingProjectLinkedDatasetCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectLinkedDataset: %s", err)
	}
	if err := d.Set("lifecycle_state", flattenLoggingProjectLinkedDatasetLifecycleState(res["lifecycleState"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectLinkedDataset: %s", err)
	}
	if err := d.Set("bigquery_dataset", flattenLoggingProjectLinkedDatasetBigqueryDataset(res["bigqueryDataset"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectLinkedDataset: %s", err)
	}

	return nil
}

func resourceLoggingProjectLinkedDatasetUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	obj := make(map[string]interface{})
	descriptionProp, err := expandLoggingProjectLinkedDatasetDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	bigqueryDatasetProp, err := expandLoggingProjectLinkedDatasetBigqueryDataset(d.Get("bigquery_dataset"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("bigquery_dataset"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, bigqueryDatasetProp)) {
		obj["bigqueryDataset"] = bigqueryDatasetProp
	}

	url, err := replaceVars(d, config, "{{LoggingBasePath}}{{bucket}}/links/{{link_id}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating ProjectLinkedDataset %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := SendRequestWithTimeout(config, "PUT", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating ProjectLinkedDataset %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating ProjectLinkedDataset %q: %#v", d.Id(), res)
	}

	err = LoggingOperationWaitTime(
		config, res, "Updating ProjectLinkedDataset", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceLoggingProjectLinkedDatasetRead(d, meta)
}

func resourceLoggingProjectLinkedDatasetDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	url, err := replaceVars(d, config, "{{LoggingBasePath}}{{bucket}}/links/{{link_id}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting ProjectLinkedDataset %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := SendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "ProjectLinkedDataset")
	}

	err = LoggingOperationWaitTime(
		config, res, "Deleting ProjectLinkedDataset", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting ProjectLinkedDataset %q: %#v", d.Id(), res)
	return nil
}

func resourceLoggingProjectLinkedDatasetImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"(?P<bucket>.+)/links/(?P<link_id>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "{{bucket}}/links/{{link_id}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenLoggingProjectLinkedDatasetName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenLoggingProjectLinkedDatasetDescription(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenLoggingProjectLinkedDatasetCreateTime(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenLoggingProjectLinkedDatasetLifecycleState(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenLoggingProjectLinkedDatasetBigqueryDataset(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["dataset_id"] =
		flattenLoggingProjectLinkedDatasetBigqueryDatasetDatasetId(original["datasetId"], d, config)
	return []interface{}{transformed}
}
func flattenLoggingProjectLinkedDatasetBigqueryDatasetDatasetId(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func expandLoggingProjectLinkedDatasetDescription(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandLoggingProjectLinkedDatasetBigqueryDataset(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDatasetId, err := expandLoggingProjectLinkedDatasetBigqueryDatasetDatasetId(original["dataset_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDatasetId); val.IsValid() && !isEmptyValue(val) {
		transformed["datasetId"] = transformedDatasetId
	}

	return transformed, nil
}

func expandLoggingProjectLinkedDatasetBigqueryDatasetDatasetId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
