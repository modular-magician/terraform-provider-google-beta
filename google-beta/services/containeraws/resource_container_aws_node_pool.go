// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package containeraws

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"
)

func ResourceContainerAwsNodePool() *schema.Resource {
	return &schema.Resource{
		Create: resourceContainerAwsNodePoolCreate,
		Read:   resourceContainerAwsNodePoolRead,
		Update: resourceContainerAwsNodePoolUpdate,
		Delete: resourceContainerAwsNodePoolDelete,

		Importer: &schema.ResourceImporter{
			State: resourceContainerAwsNodePoolImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"autoscaling": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `Autoscaler configuration for this node pool.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"max_node_count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: `Maximum number of nodes in the NodePool. Must be >= min_node_count.`,
						},
						"min_node_count": {
							Type:        schema.TypeInt,
							Required:    true,
							Description: `Minimum number of nodes in the NodePool. Must be >= 1 and <= max_node_count.`,
						},
					},
				},
			},
			"cluster": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The awsCluster for the resource`,
			},
			"config": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `The configuration of the node pool.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"config_encryption": {
							Type:        schema.TypeList,
							Required:    true,
							Description: `The ARN of the AWS KMS key used to encrypt node pool configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"kms_key_arn": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The ARN of the AWS KMS key used to encrypt node pool configuration.`,
									},
								},
							},
						},
						"iam_instance_profile": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The name of the AWS IAM role assigned to nodes in the pool.`,
						},
						"autoscaling_metrics_collection": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. Configuration related to CloudWatch metrics collection on the Auto Scaling group of the node pool. When unspecified, metrics collection is disabled.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"granularity": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The frequency at which EC2 Auto Scaling sends aggregated data to AWS CloudWatch. The only valid value is "1Minute".`,
									},
									"metrics": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `The metrics to enable. For a list of valid metrics, see https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_EnableMetricsCollection.html. If you specify granularity and don't specify any metrics, all metrics are enabled.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"image_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `The OS image type to use on node pool instances.`,
						},
						"instance_placement": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Details of placement information for an instance.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"tenancy": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"TENANCY_UNSPECIFIED", "DEFAULT", "DEDICATED", "HOST", ""}),
										Description:  `The tenancy for the instance. Default value: "DEFAULT" Possible values: ["TENANCY_UNSPECIFIED", "DEFAULT", "DEDICATED", "HOST"]`,
										Default:      "DEFAULT",
									},
								},
							},
						},
						"instance_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. The AWS instance type. When unspecified, it defaults to 'm5.large'.`,
						},
						"labels": {
							Type:        schema.TypeMap,
							Optional:    true,
							Description: `Optional. The initial labels assigned to nodes of this node pool. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.`,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
						"proxy_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Proxy configuration for outbound HTTP(S) traffic.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"secret_arn": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The ARN of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.`,
									},
									"secret_version": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The version string of the AWS Secret Manager secret that contains the HTTP(S) proxy configuration.`,
									},
								},
							},
						},
						"root_volume": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Optional. Template for the root volume provisioned for node pool nodes. Volumes will be provisioned in the availability zone assigned to the node pool subnet. When unspecified, it defaults to 32 GiB with the GP2 volume type.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"iops": {
										Type:        schema.TypeInt,
										Computed:    true,
										Optional:    true,
										Description: `Optional. The number of I/O operations per second (IOPS) to provision for GP3 volume.`,
									},
									"kms_key_arn": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Optional. The Amazon Resource Name (ARN) of the Customer Managed Key (CMK) used to encrypt AWS EBS volumes. If not specified, the default Amazon managed key associated to the AWS region where this cluster runs will be used.`,
									},
									"size_gib": {
										Type:        schema.TypeInt,
										Computed:    true,
										Optional:    true,
										Description: `Optional. The size of the volume, in GiBs. When unspecified, a default value is provided. See the specific reference in the parent resource.`,
									},
									"throughput": {
										Type:        schema.TypeInt,
										Computed:    true,
										Optional:    true,
										Description: `Optional. The throughput to provision for the volume, in MiB/s. Only valid if the volume type is GP3.`,
									},
									"volume_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"VOLUME_TYPE_UNSPECIFIED", "GP2", "GP3", ""}),
										Description:  `Optional. Type of the EBS volume. When unspecified, it defaults to GP2 volume. Default value: "GP2" Possible values: ["VOLUME_TYPE_UNSPECIFIED", "GP2", "GP3"]`,
										Default:      "GP2",
									},
								},
							},
						},
						"security_group_ids": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. The IDs of additional security groups to add to nodes in this pool. The manager will automatically create security groups with minimum rules needed for a functioning cluster.`,
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
						"spot_config": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. When specified, the node pool will provision Spot instances from the set of spot_config.instance_types. This field is mutually exclusive with 'instance_type'`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"instance_types": {
										Type:        schema.TypeList,
										Required:    true,
										ForceNew:    true,
										Description: `List of AWS EC2 instance types for creating a spot node pool's nodes. The specified instance types must have the same number of CPUs and memory. You can use the Amazon EC2 Instance Selector tool (https://github.com/aws/amazon-ec2-instance-selector) to choose instance types with matching CPU and memory`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"ssh_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Optional. The SSH configuration.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ec2_key_pair": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The name of the EC2 key pair used to login into cluster machines.`,
									},
								},
							},
						},
						"tags": {
							Type:        schema.TypeMap,
							Optional:    true,
							Description: `Optional. Key/value metadata to assign to each underlying AWS resource. Specify at most 50 pairs containing alphanumerics, spaces, and symbols (.+-=_:@/). Keys can be up to 127 Unicode characters. Values can be up to 255 Unicode characters.`,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
						"taints": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `Optional. The initial taints assigned to nodes of this node pool.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"effect": {
										Type:         schema.TypeString,
										Required:     true,
										ForceNew:     true,
										ValidateFunc: verify.ValidateEnum([]string{"EFFECT_UNSPECIFIED", "NO_SCHEDULE", "PREFER_NO_SCHEDULE", "NO_EXECUTE"}),
										Description:  `The taint effect. Possible values: ["EFFECT_UNSPECIFIED", "NO_SCHEDULE", "PREFER_NO_SCHEDULE", "NO_EXECUTE"]`,
									},
									"key": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Key for the taint.`,
									},
									"value": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `Value for the taint.`,
									},
								},
							},
						},
					},
				},
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location for the resource`,
			},
			"max_pods_constraint": {
				Type:        schema.TypeList,
				Required:    true,
				ForceNew:    true,
				Description: `The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"max_pods_per_node": {
							Type:        schema.TypeInt,
							Required:    true,
							ForceNew:    true,
							Description: `The maximum number of pods to schedule on a single node.`,
						},
					},
				},
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The name of this resource.`,
			},
			"subnet_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The subnet where the node pool node run.`,
			},
			"version": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `The Kubernetes version to run on this node pool (e.g. '1.19.10-gke.1000'). You can list all supported versions on a given Google Cloud region by calling GetAwsServerConfig.`,
			},
			"annotations": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `Optional. Annotations on the node pool. This field has the same restrictions as Kubernetes annotations. The total size of all keys and values combined is limited to 256k. Key can have 2 segments: prefix (optional) and name (required), separated by a slash (/). Prefix must be a DNS subdomain. Name must be 63 characters or less, begin and end with alphanumerics, with dashes (-), underscores (_), dots (.), and alphanumerics between.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"management": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The Management configuration for this node pool.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auto_repair": {
							Type:     schema.TypeBool,
							Optional: true,
							Description: `Whether or not the nodes will be automatically repaired. When set to true,
the nodes in this node pool will be monitored and if they fail health
checks consistently over a period of time, an automatic repair action
will be triggered to replace them with new nodes.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The time at which this node pool was created.`,
			},
			"errors": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `A set of errors found in the node pool.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"message": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Human-friendly description of the error.`,
						},
					},
				},
			},
			"etag": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Allows clients to perform consistent read-modify-writes through optimistic concurrency control. May be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.`,
			},
			"reconciling": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Output only. If set, there are currently changes in flight to the node pool.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The lifecycle state of the node pool.`,
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. A globally unique identifier for the node pool.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Output only. The time at which this node pool was last updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceContainerAwsNodePoolCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	nameProp, err := expandContainerAwsNodePoolName(d.Get("name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("name"); !tpgresource.IsEmptyValue(reflect.ValueOf(nameProp)) && (ok || !reflect.DeepEqual(v, nameProp)) {
		obj["name"] = nameProp
	}
	versionProp, err := expandContainerAwsNodePoolVersion(d.Get("version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("version"); !tpgresource.IsEmptyValue(reflect.ValueOf(versionProp)) && (ok || !reflect.DeepEqual(v, versionProp)) {
		obj["version"] = versionProp
	}
	configProp, err := expandContainerAwsNodePoolConfig(d.Get("config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config"); !tpgresource.IsEmptyValue(reflect.ValueOf(configProp)) && (ok || !reflect.DeepEqual(v, configProp)) {
		obj["config"] = configProp
	}
	autoscalingProp, err := expandContainerAwsNodePoolAutoscaling(d.Get("autoscaling"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("autoscaling"); !tpgresource.IsEmptyValue(reflect.ValueOf(autoscalingProp)) && (ok || !reflect.DeepEqual(v, autoscalingProp)) {
		obj["autoscaling"] = autoscalingProp
	}
	subnetIdProp, err := expandContainerAwsNodePoolSubnetId(d.Get("subnet_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("subnet_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(subnetIdProp)) && (ok || !reflect.DeepEqual(v, subnetIdProp)) {
		obj["subnetId"] = subnetIdProp
	}
	annotationsProp, err := expandContainerAwsNodePoolAnnotations(d.Get("annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}
	maxPodsConstraintProp, err := expandContainerAwsNodePoolMaxPodsConstraint(d.Get("max_pods_constraint"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("max_pods_constraint"); !tpgresource.IsEmptyValue(reflect.ValueOf(maxPodsConstraintProp)) && (ok || !reflect.DeepEqual(v, maxPodsConstraintProp)) {
		obj["maxPodsConstraint"] = maxPodsConstraintProp
	}
	managementProp, err := expandContainerAwsNodePoolManagement(d.Get("management"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("management"); !tpgresource.IsEmptyValue(reflect.ValueOf(managementProp)) && (ok || !reflect.DeepEqual(v, managementProp)) {
		obj["management"] = managementProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ContainerAwsBasePath}}projects/{{project}}/locations/{{location}}/awsClusters/{{cluster}}/awsNodePools?awsNodePoolId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new NodePool: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for NodePool: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating NodePool: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/awsClusters/{{cluster}}/awsNodePools/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = ContainerAwsOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating NodePool", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create NodePool: %s", err)
	}

	if err := d.Set("name", flattenContainerAwsNodePoolName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/awsClusters/{{cluster}}/awsNodePools/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating NodePool %q: %#v", d.Id(), res)

	return resourceContainerAwsNodePoolRead(d, meta)
}

func resourceContainerAwsNodePoolRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ContainerAwsBasePath}}projects/{{project}}/locations/{{location}}/awsClusters/{{cluster}}/awsNodePools/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for NodePool: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("ContainerAwsNodePool %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}

	if err := d.Set("name", flattenContainerAwsNodePoolName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("version", flattenContainerAwsNodePoolVersion(res["version"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("config", flattenContainerAwsNodePoolConfig(res["config"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("autoscaling", flattenContainerAwsNodePoolAutoscaling(res["autoscaling"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("subnet_id", flattenContainerAwsNodePoolSubnetId(res["subnetId"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("state", flattenContainerAwsNodePoolState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("uid", flattenContainerAwsNodePoolUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("reconciling", flattenContainerAwsNodePoolReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("create_time", flattenContainerAwsNodePoolCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("update_time", flattenContainerAwsNodePoolUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("etag", flattenContainerAwsNodePoolEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("annotations", flattenContainerAwsNodePoolAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("max_pods_constraint", flattenContainerAwsNodePoolMaxPodsConstraint(res["maxPodsConstraint"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("errors", flattenContainerAwsNodePoolErrors(res["errors"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}
	if err := d.Set("management", flattenContainerAwsNodePoolManagement(res["management"], d, config)); err != nil {
		return fmt.Errorf("Error reading NodePool: %s", err)
	}

	return nil
}

func resourceContainerAwsNodePoolUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for NodePool: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	versionProp, err := expandContainerAwsNodePoolVersion(d.Get("version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("version"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, versionProp)) {
		obj["version"] = versionProp
	}
	configProp, err := expandContainerAwsNodePoolConfig(d.Get("config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, configProp)) {
		obj["config"] = configProp
	}
	autoscalingProp, err := expandContainerAwsNodePoolAutoscaling(d.Get("autoscaling"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("autoscaling"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, autoscalingProp)) {
		obj["autoscaling"] = autoscalingProp
	}
	annotationsProp, err := expandContainerAwsNodePoolAnnotations(d.Get("annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}
	managementProp, err := expandContainerAwsNodePoolManagement(d.Get("management"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("management"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, managementProp)) {
		obj["management"] = managementProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{ContainerAwsBasePath}}projects/{{project}}/locations/{{location}}/awsClusters/{{cluster}}/awsNodePools/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating NodePool %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("version") {
		updateMask = append(updateMask, "version")
	}

	if d.HasChange("config") {
		updateMask = append(updateMask, "config")
	}

	if d.HasChange("autoscaling") {
		updateMask = append(updateMask, "autoscaling")
	}

	if d.HasChange("annotations") {
		updateMask = append(updateMask, "annotations")
	}

	if d.HasChange("management") {
		updateMask = append(updateMask, "management")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}
	// The generated code sets the wrong masks for the following fields.
	newUpdateMask := []string{}
	fields := map[string]string{
		"autoscaling.0.min_node_count":             "autoscaling.min_node_count",
		"autoscaling.0.max_node_count":             "autoscaling.max_node_count",
		"config.0.config_encryption.0.kms_key_arn": "config.config_encryption.kms_key_arn",
		"config.0.security_group_ids":              "config.security_group_ids",
		"config.0.root_volume.0.iops":              "config.root_volume.iops",
		"config.0.root_volume.0.throughput":        "config.root_volume.throughput",
		"config.0.root_volume.0.kms_key_arn":       "config.root_volume.kms_key_arn",
		"config.0.root_volume.0.size_gib":          "config.root_volume.size_gib",
		"config.0.root_volume.0.volume_type":       "config.root_volume.volume_type",
		"config.0.proxy_config":                    "config.proxy_config",
		"config.0.ssh_config":                      "config.ssh_config",
		"config.0.instance_placement.0.tenancy":    "config.instance_placement.tenancy",
		"config.0.iam_instance_profile":            "config.iam_instance_profile",
		"config.0.labels":                          "config.labels",
		"config.0.tags":                            "config.tags",
		"config.0.autoscaling_metrics_collection":  "config.autoscaling_metrics_collection",
	}
	for k, v := range fields {
		if d.HasChange(k) {
			newUpdateMask = append(newUpdateMask, v)
		}
	}
	// Pull out any other set fields from the generated mask.
	for _, mask := range updateMask {
		if mask == "config" || mask == "autoscaling" {
			continue
		}
		newUpdateMask = append(newUpdateMask, mask)
	}
	// Overwrite the previously set mask.
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(newUpdateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
	})

	if err != nil {
		return fmt.Errorf("Error updating NodePool %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating NodePool %q: %#v", d.Id(), res)
	}

	err = ContainerAwsOperationWaitTime(
		config, res, project, "Updating NodePool", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceContainerAwsNodePoolRead(d, meta)
}

func resourceContainerAwsNodePoolDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for NodePool: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{ContainerAwsBasePath}}projects/{{project}}/locations/{{location}}/awsClusters/{{cluster}}/awsNodePools/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting NodePool %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "NodePool")
	}

	err = ContainerAwsOperationWaitTime(
		config, res, project, "Deleting NodePool", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting NodePool %q: %#v", d.Id(), res)
	return nil
}

func resourceContainerAwsNodePoolImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/awsClusters/(?P<cluster>[^/]+)/awsNodePools/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<cluster>[^/]+)/(?P<name>[^/]+)",
		"(?P<location>[^/]+)/(?P<cluster>[^/]+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/awsClusters/{{cluster}}/awsNodePools/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenContainerAwsNodePoolName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func flattenContainerAwsNodePoolVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["instance_type"] =
		flattenContainerAwsNodePoolConfigInstanceType(original["instanceType"], d, config)
	transformed["root_volume"] =
		flattenContainerAwsNodePoolConfigRootVolume(original["rootVolume"], d, config)
	transformed["taints"] =
		flattenContainerAwsNodePoolConfigTaints(original["taints"], d, config)
	transformed["labels"] =
		flattenContainerAwsNodePoolConfigLabels(original["labels"], d, config)
	transformed["tags"] =
		flattenContainerAwsNodePoolConfigTags(original["tags"], d, config)
	transformed["iam_instance_profile"] =
		flattenContainerAwsNodePoolConfigIamInstanceProfile(original["iamInstanceProfile"], d, config)
	transformed["config_encryption"] =
		flattenContainerAwsNodePoolConfigConfigEncryption(original["configEncryption"], d, config)
	transformed["ssh_config"] =
		flattenContainerAwsNodePoolConfigSshConfig(original["sshConfig"], d, config)
	transformed["spot_config"] =
		flattenContainerAwsNodePoolConfigSpotConfig(original["spotConfig"], d, config)
	transformed["security_group_ids"] =
		flattenContainerAwsNodePoolConfigSecurityGroupIds(original["securityGroupIds"], d, config)
	transformed["proxy_config"] =
		flattenContainerAwsNodePoolConfigProxyConfig(original["proxyConfig"], d, config)
	transformed["instance_placement"] =
		flattenContainerAwsNodePoolConfigInstancePlacement(original["instancePlacement"], d, config)
	transformed["image_type"] =
		flattenContainerAwsNodePoolConfigImageType(original["imageType"], d, config)
	transformed["autoscaling_metrics_collection"] =
		flattenContainerAwsNodePoolConfigAutoscalingMetricsCollection(original["autoscalingMetricsCollection"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolConfigInstanceType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigRootVolume(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["size_gib"] =
		flattenContainerAwsNodePoolConfigRootVolumeSizeGib(original["sizeGib"], d, config)
	transformed["volume_type"] =
		flattenContainerAwsNodePoolConfigRootVolumeVolumeType(original["volumeType"], d, config)
	transformed["iops"] =
		flattenContainerAwsNodePoolConfigRootVolumeIops(original["iops"], d, config)
	transformed["throughput"] =
		flattenContainerAwsNodePoolConfigRootVolumeThroughput(original["throughput"], d, config)
	transformed["kms_key_arn"] =
		flattenContainerAwsNodePoolConfigRootVolumeKmsKeyArn(original["kmsKeyArn"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolConfigRootVolumeSizeGib(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenContainerAwsNodePoolConfigRootVolumeVolumeType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigRootVolumeIops(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenContainerAwsNodePoolConfigRootVolumeThroughput(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenContainerAwsNodePoolConfigRootVolumeKmsKeyArn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigTaints(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"key":    flattenContainerAwsNodePoolConfigTaintsKey(original["key"], d, config),
			"value":  flattenContainerAwsNodePoolConfigTaintsValue(original["value"], d, config),
			"effect": flattenContainerAwsNodePoolConfigTaintsEffect(original["effect"], d, config),
		})
	}
	return transformed
}
func flattenContainerAwsNodePoolConfigTaintsKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigTaintsValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigTaintsEffect(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigIamInstanceProfile(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigConfigEncryption(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["kms_key_arn"] =
		flattenContainerAwsNodePoolConfigConfigEncryptionKmsKeyArn(original["kmsKeyArn"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolConfigConfigEncryptionKmsKeyArn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigSshConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ec2_key_pair"] =
		flattenContainerAwsNodePoolConfigSshConfigEc2KeyPair(original["ec2KeyPair"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolConfigSshConfigEc2KeyPair(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigSpotConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["instance_types"] =
		flattenContainerAwsNodePoolConfigSpotConfigInstanceTypes(original["instanceTypes"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolConfigSpotConfigInstanceTypes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigSecurityGroupIds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigProxyConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_arn"] =
		flattenContainerAwsNodePoolConfigProxyConfigSecretArn(original["secretArn"], d, config)
	transformed["secret_version"] =
		flattenContainerAwsNodePoolConfigProxyConfigSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolConfigProxyConfigSecretArn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigProxyConfigSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigInstancePlacement(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["tenancy"] =
		flattenContainerAwsNodePoolConfigInstancePlacementTenancy(original["tenancy"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolConfigInstancePlacementTenancy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigImageType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigAutoscalingMetricsCollection(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["granularity"] =
		flattenContainerAwsNodePoolConfigAutoscalingMetricsCollectionGranularity(original["granularity"], d, config)
	transformed["metrics"] =
		flattenContainerAwsNodePoolConfigAutoscalingMetricsCollectionMetrics(original["metrics"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolConfigAutoscalingMetricsCollectionGranularity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolConfigAutoscalingMetricsCollectionMetrics(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolAutoscaling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["min_node_count"] =
		flattenContainerAwsNodePoolAutoscalingMinNodeCount(original["minNodeCount"], d, config)
	transformed["max_node_count"] =
		flattenContainerAwsNodePoolAutoscalingMaxNodeCount(original["maxNodeCount"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolAutoscalingMinNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenContainerAwsNodePoolAutoscalingMaxNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenContainerAwsNodePoolSubnetId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolMaxPodsConstraint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["max_pods_per_node"] =
		flattenContainerAwsNodePoolMaxPodsConstraintMaxPodsPerNode(original["maxPodsPerNode"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolMaxPodsConstraintMaxPodsPerNode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenContainerAwsNodePoolErrors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"message": flattenContainerAwsNodePoolErrorsMessage(original["message"], d, config),
		})
	}
	return transformed
}
func flattenContainerAwsNodePoolErrorsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAwsNodePoolManagement(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["auto_repair"] =
		flattenContainerAwsNodePoolManagementAutoRepair(original["autoRepair"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAwsNodePoolManagementAutoRepair(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandContainerAwsNodePoolName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstanceType, err := expandContainerAwsNodePoolConfigInstanceType(original["instance_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceType"] = transformedInstanceType
	}

	transformedRootVolume, err := expandContainerAwsNodePoolConfigRootVolume(original["root_volume"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRootVolume); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["rootVolume"] = transformedRootVolume
	}

	transformedTaints, err := expandContainerAwsNodePoolConfigTaints(original["taints"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTaints); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["taints"] = transformedTaints
	}

	transformedLabels, err := expandContainerAwsNodePoolConfigLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedTags, err := expandContainerAwsNodePoolConfigTags(original["tags"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tags"] = transformedTags
	}

	transformedIamInstanceProfile, err := expandContainerAwsNodePoolConfigIamInstanceProfile(original["iam_instance_profile"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIamInstanceProfile); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["iamInstanceProfile"] = transformedIamInstanceProfile
	}

	transformedConfigEncryption, err := expandContainerAwsNodePoolConfigConfigEncryption(original["config_encryption"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConfigEncryption); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["configEncryption"] = transformedConfigEncryption
	}

	transformedSshConfig, err := expandContainerAwsNodePoolConfigSshConfig(original["ssh_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSshConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sshConfig"] = transformedSshConfig
	}

	transformedSpotConfig, err := expandContainerAwsNodePoolConfigSpotConfig(original["spot_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSpotConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["spotConfig"] = transformedSpotConfig
	}

	transformedSecurityGroupIds, err := expandContainerAwsNodePoolConfigSecurityGroupIds(original["security_group_ids"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecurityGroupIds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["securityGroupIds"] = transformedSecurityGroupIds
	}

	transformedProxyConfig, err := expandContainerAwsNodePoolConfigProxyConfig(original["proxy_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedProxyConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["proxyConfig"] = transformedProxyConfig
	}

	transformedInstancePlacement, err := expandContainerAwsNodePoolConfigInstancePlacement(original["instance_placement"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstancePlacement); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instancePlacement"] = transformedInstancePlacement
	}

	transformedImageType, err := expandContainerAwsNodePoolConfigImageType(original["image_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImageType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["imageType"] = transformedImageType
	}

	transformedAutoscalingMetricsCollection, err := expandContainerAwsNodePoolConfigAutoscalingMetricsCollection(original["autoscaling_metrics_collection"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutoscalingMetricsCollection); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["autoscalingMetricsCollection"] = transformedAutoscalingMetricsCollection
	}

	return transformed, nil
}

func expandContainerAwsNodePoolConfigInstanceType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigRootVolume(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSizeGib, err := expandContainerAwsNodePoolConfigRootVolumeSizeGib(original["size_gib"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSizeGib); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sizeGib"] = transformedSizeGib
	}

	transformedVolumeType, err := expandContainerAwsNodePoolConfigRootVolumeVolumeType(original["volume_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVolumeType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["volumeType"] = transformedVolumeType
	}

	transformedIops, err := expandContainerAwsNodePoolConfigRootVolumeIops(original["iops"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIops); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["iops"] = transformedIops
	}

	transformedThroughput, err := expandContainerAwsNodePoolConfigRootVolumeThroughput(original["throughput"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedThroughput); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["throughput"] = transformedThroughput
	}

	transformedKmsKeyArn, err := expandContainerAwsNodePoolConfigRootVolumeKmsKeyArn(original["kms_key_arn"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyArn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyArn"] = transformedKmsKeyArn
	}

	return transformed, nil
}

func expandContainerAwsNodePoolConfigRootVolumeSizeGib(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigRootVolumeVolumeType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigRootVolumeIops(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigRootVolumeThroughput(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigRootVolumeKmsKeyArn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigTaints(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedKey, err := expandContainerAwsNodePoolConfigTaintsKey(original["key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["key"] = transformedKey
		}

		transformedValue, err := expandContainerAwsNodePoolConfigTaintsValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedEffect, err := expandContainerAwsNodePoolConfigTaintsEffect(original["effect"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEffect); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["effect"] = transformedEffect
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandContainerAwsNodePoolConfigTaintsKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigTaintsValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigTaintsEffect(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandContainerAwsNodePoolConfigTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandContainerAwsNodePoolConfigIamInstanceProfile(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigConfigEncryption(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKmsKeyArn, err := expandContainerAwsNodePoolConfigConfigEncryptionKmsKeyArn(original["kms_key_arn"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyArn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyArn"] = transformedKmsKeyArn
	}

	return transformed, nil
}

func expandContainerAwsNodePoolConfigConfigEncryptionKmsKeyArn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigSshConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedEc2KeyPair, err := expandContainerAwsNodePoolConfigSshConfigEc2KeyPair(original["ec2_key_pair"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEc2KeyPair); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ec2KeyPair"] = transformedEc2KeyPair
	}

	return transformed, nil
}

func expandContainerAwsNodePoolConfigSshConfigEc2KeyPair(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigSpotConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstanceTypes, err := expandContainerAwsNodePoolConfigSpotConfigInstanceTypes(original["instance_types"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceTypes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceTypes"] = transformedInstanceTypes
	}

	return transformed, nil
}

func expandContainerAwsNodePoolConfigSpotConfigInstanceTypes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigSecurityGroupIds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigProxyConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretArn, err := expandContainerAwsNodePoolConfigProxyConfigSecretArn(original["secret_arn"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretArn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretArn"] = transformedSecretArn
	}

	transformedSecretVersion, err := expandContainerAwsNodePoolConfigProxyConfigSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandContainerAwsNodePoolConfigProxyConfigSecretArn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigProxyConfigSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigInstancePlacement(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTenancy, err := expandContainerAwsNodePoolConfigInstancePlacementTenancy(original["tenancy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTenancy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tenancy"] = transformedTenancy
	}

	return transformed, nil
}

func expandContainerAwsNodePoolConfigInstancePlacementTenancy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigImageType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigAutoscalingMetricsCollection(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGranularity, err := expandContainerAwsNodePoolConfigAutoscalingMetricsCollectionGranularity(original["granularity"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGranularity); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["granularity"] = transformedGranularity
	}

	transformedMetrics, err := expandContainerAwsNodePoolConfigAutoscalingMetricsCollectionMetrics(original["metrics"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetrics); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["metrics"] = transformedMetrics
	}

	return transformed, nil
}

func expandContainerAwsNodePoolConfigAutoscalingMetricsCollectionGranularity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolConfigAutoscalingMetricsCollectionMetrics(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolAutoscaling(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMinNodeCount, err := expandContainerAwsNodePoolAutoscalingMinNodeCount(original["min_node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minNodeCount"] = transformedMinNodeCount
	}

	transformedMaxNodeCount, err := expandContainerAwsNodePoolAutoscalingMaxNodeCount(original["max_node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxNodeCount"] = transformedMaxNodeCount
	}

	return transformed, nil
}

func expandContainerAwsNodePoolAutoscalingMinNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolAutoscalingMaxNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolSubnetId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandContainerAwsNodePoolMaxPodsConstraint(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMaxPodsPerNode, err := expandContainerAwsNodePoolMaxPodsConstraintMaxPodsPerNode(original["max_pods_per_node"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxPodsPerNode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxPodsPerNode"] = transformedMaxPodsPerNode
	}

	return transformed, nil
}

func expandContainerAwsNodePoolMaxPodsConstraintMaxPodsPerNode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandContainerAwsNodePoolManagement(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAutoRepair, err := expandContainerAwsNodePoolManagementAutoRepair(original["auto_repair"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAutoRepair); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["autoRepair"] = transformedAutoRepair
	}

	return transformed, nil
}

func expandContainerAwsNodePoolManagementAutoRepair(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
