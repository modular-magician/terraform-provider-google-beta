// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package integrationconnectors

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"
)

func ResourceIntegrationConnectorsConnection() *schema.Resource {
	return &schema.Resource{
		Create: resourceIntegrationConnectorsConnectionCreate,
		Read:   resourceIntegrationConnectorsConnectionRead,
		Update: resourceIntegrationConnectorsConnectionUpdate,
		Delete: resourceIntegrationConnectorsConnectionDelete,

		Importer: &schema.ResourceImporter{
			State: resourceIntegrationConnectorsConnectionImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Location in which Connection needs to be created.`,
			},
			"auth_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `authConfig for the connection.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"auth_type": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"AUTH_TYPE_UNSPECIFIED", "USER_PASSWORD", "OAUTH2_JWT_BEARER", "OAUTH2_CLIENT_CREDENTIALS", "SSH_PUBLIC_KEY", "OAUTH2_AUTH_CODE_FLOW", ""}),
							Description:  `authType of the Connection Possible values: ["AUTH_TYPE_UNSPECIFIED", "USER_PASSWORD", "OAUTH2_JWT_BEARER", "OAUTH2_CLIENT_CREDENTIALS", "SSH_PUBLIC_KEY", "OAUTH2_AUTH_CODE_FLOW"]`,
						},
						"user_password": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `A nested object resource`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"password": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Password for Authentication.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret_version": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Secret version of Password for Authentication.`,
												},
											},
										},
									},
									"username": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Username for Authentication.`,
									},
								},
							},
						},
					},
				},
			},
			"config_variables": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Config Variables for the connection.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Key for the connection`,
						},
					},
				},
			},
			"connector_version": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `connectorVersion.`,
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `An arbitrary description for the Conection.`,
			},
			"destination_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `DestinationConfig for the connection.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"destinations": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `destinations for the connection`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"host": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Host`,
									},
									"port": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `port number`,
									},
									"service_attachment": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Service Attachment`,
									},
								},
							},
						},
						"key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Key for the connection`,
						},
					},
				},
			},
			"eventing_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Eventing Configuration of a connection`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"registration_destination_config": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `registrationDestinationConfig`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"destination_config": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `DestinationConfig for the connection.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"destinations": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `destinations for the connection`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"host": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `Host`,
															},
															"port": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: `port number`,
															},
															"service_attachment": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `Service Attachment`,
															},
														},
													},
												},
												"key": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Key for the connection`,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"eventing_enablement_type": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"EVENTING_ENABLEMENT_TYPE_UNSPECIFIED", "EVENTING_AND_CONNECTION", "ONLY_EVENTING", ""}),
				Description:  `Eventing Enablement Type enum. Possible values: ["EVENTING_ENABLEMENT_TYPE_UNSPECIFIED", "EVENTING_AND_CONNECTION", "ONLY_EVENTING"]`,
			},
			"labels": {
				Type:        schema.TypeMap,
				Optional:    true,
				Description: `Resource labels to represent user provided metadata.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"node_config": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Node configuration for the connection.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"max_node_count": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `maxNodeCount for the node`,
						},
						"min_node_count": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: `minNodeCount for the node`,
						},
					},
				},
			},
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The region of the Connection.`,
			},
			"service_account": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Service Account that will be used.`,
			},
			"service_directory": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Service Directory that will be used.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Name of the connection resource.`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Status of the Integration Connector.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"state": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"STATE_UNSPECIFIED", "CREATING", "ACTIVE", "INACTIVE", "DELETING", ";UPDATING", "ERROR", "AUTHORIZATION_REQUIRED", ""}),
							Description:  `State of the Integration Connector Default value: "STATE_UNSPECIFIED" Possible values: ["STATE_UNSPECIFIED", "CREATING", "ACTIVE", "INACTIVE", "DELETING", ";UPDATING", "ERROR", "AUTHORIZATION_REQUIRED"]`,
							Default:      "STATE_UNSPECIFIED",
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceIntegrationConnectorsConnectionCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandIntegrationConnectorsConnectionDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	labelsProp, err := expandIntegrationConnectorsConnectionLabels(d.Get("labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	connectorVersionProp, err := expandIntegrationConnectorsConnectionConnectorVersion(d.Get("connector_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("connector_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(connectorVersionProp)) && (ok || !reflect.DeepEqual(v, connectorVersionProp)) {
		obj["connectorVersion"] = connectorVersionProp
	}
	configVariablesProp, err := expandIntegrationConnectorsConnectionConfigVariables(d.Get("config_variables"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config_variables"); !tpgresource.IsEmptyValue(reflect.ValueOf(configVariablesProp)) && (ok || !reflect.DeepEqual(v, configVariablesProp)) {
		obj["configVariables"] = configVariablesProp
	}
	authConfigProp, err := expandIntegrationConnectorsConnectionAuthConfig(d.Get("auth_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auth_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(authConfigProp)) && (ok || !reflect.DeepEqual(v, authConfigProp)) {
		obj["authConfig"] = authConfigProp
	}
	serviceAccountProp, err := expandIntegrationConnectorsConnectionServiceAccount(d.Get("service_account"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("service_account"); !tpgresource.IsEmptyValue(reflect.ValueOf(serviceAccountProp)) && (ok || !reflect.DeepEqual(v, serviceAccountProp)) {
		obj["serviceAccount"] = serviceAccountProp
	}
	serviceDirectoryProp, err := expandIntegrationConnectorsConnectionServiceDirectory(d.Get("service_directory"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("service_directory"); !tpgresource.IsEmptyValue(reflect.ValueOf(serviceDirectoryProp)) && (ok || !reflect.DeepEqual(v, serviceDirectoryProp)) {
		obj["serviceDirectory"] = serviceDirectoryProp
	}
	destinationConfigProp, err := expandIntegrationConnectorsConnectionDestinationConfig(d.Get("destination_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destination_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(destinationConfigProp)) && (ok || !reflect.DeepEqual(v, destinationConfigProp)) {
		obj["destinationConfig"] = destinationConfigProp
	}
	nodeConfigProp, err := expandIntegrationConnectorsConnectionNodeConfig(d.Get("node_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(nodeConfigProp)) && (ok || !reflect.DeepEqual(v, nodeConfigProp)) {
		obj["nodeConfig"] = nodeConfigProp
	}
	eventingConfigProp, err := expandIntegrationConnectorsConnectionEventingConfig(d.Get("eventing_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("eventing_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(eventingConfigProp)) && (ok || !reflect.DeepEqual(v, eventingConfigProp)) {
		obj["eventingConfig"] = eventingConfigProp
	}
	eventingEnablementTypeProp, err := expandIntegrationConnectorsConnectionEventingEnablementType(d.Get("eventing_enablement_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("eventing_enablement_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(eventingEnablementTypeProp)) && (ok || !reflect.DeepEqual(v, eventingEnablementTypeProp)) {
		obj["eventingEnablementType"] = eventingEnablementTypeProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationConnectorsBasePath}}projects/{{project}}/locations/{{region}}/connections?connectionId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Connection: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating Connection: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = IntegrationConnectorsOperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Connection", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create Connection: %s", err)
	}

	if err := d.Set("name", flattenIntegrationConnectorsConnectionName(opRes["name"], d, config)); err != nil {
		return err
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Connection %q: %#v", d.Id(), res)

	return resourceIntegrationConnectorsConnectionRead(d, meta)
}

func resourceIntegrationConnectorsConnectionRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationConnectorsBasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("IntegrationConnectorsConnection %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}

	if err := d.Set("name", flattenIntegrationConnectorsConnectionName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("description", flattenIntegrationConnectorsConnectionDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("labels", flattenIntegrationConnectorsConnectionLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("connector_version", flattenIntegrationConnectorsConnectionConnectorVersion(res["connectorVersion"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("status", flattenIntegrationConnectorsConnectionStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("config_variables", flattenIntegrationConnectorsConnectionConfigVariables(res["configVariables"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("auth_config", flattenIntegrationConnectorsConnectionAuthConfig(res["authConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("service_account", flattenIntegrationConnectorsConnectionServiceAccount(res["serviceAccount"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("service_directory", flattenIntegrationConnectorsConnectionServiceDirectory(res["serviceDirectory"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("destination_config", flattenIntegrationConnectorsConnectionDestinationConfig(res["destinationConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("node_config", flattenIntegrationConnectorsConnectionNodeConfig(res["nodeConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("eventing_config", flattenIntegrationConnectorsConnectionEventingConfig(res["eventingConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}
	if err := d.Set("eventing_enablement_type", flattenIntegrationConnectorsConnectionEventingEnablementType(res["eventingEnablementType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Connection: %s", err)
	}

	return nil
}

func resourceIntegrationConnectorsConnectionUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandIntegrationConnectorsConnectionDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	labelsProp, err := expandIntegrationConnectorsConnectionLabels(d.Get("labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	connectorVersionProp, err := expandIntegrationConnectorsConnectionConnectorVersion(d.Get("connector_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("connector_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, connectorVersionProp)) {
		obj["connectorVersion"] = connectorVersionProp
	}
	configVariablesProp, err := expandIntegrationConnectorsConnectionConfigVariables(d.Get("config_variables"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("config_variables"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, configVariablesProp)) {
		obj["configVariables"] = configVariablesProp
	}
	authConfigProp, err := expandIntegrationConnectorsConnectionAuthConfig(d.Get("auth_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("auth_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, authConfigProp)) {
		obj["authConfig"] = authConfigProp
	}
	serviceAccountProp, err := expandIntegrationConnectorsConnectionServiceAccount(d.Get("service_account"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("service_account"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, serviceAccountProp)) {
		obj["serviceAccount"] = serviceAccountProp
	}
	serviceDirectoryProp, err := expandIntegrationConnectorsConnectionServiceDirectory(d.Get("service_directory"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("service_directory"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, serviceDirectoryProp)) {
		obj["serviceDirectory"] = serviceDirectoryProp
	}
	destinationConfigProp, err := expandIntegrationConnectorsConnectionDestinationConfig(d.Get("destination_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("destination_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, destinationConfigProp)) {
		obj["destinationConfig"] = destinationConfigProp
	}
	nodeConfigProp, err := expandIntegrationConnectorsConnectionNodeConfig(d.Get("node_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("node_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, nodeConfigProp)) {
		obj["nodeConfig"] = nodeConfigProp
	}
	eventingConfigProp, err := expandIntegrationConnectorsConnectionEventingConfig(d.Get("eventing_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("eventing_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, eventingConfigProp)) {
		obj["eventingConfig"] = eventingConfigProp
	}
	eventingEnablementTypeProp, err := expandIntegrationConnectorsConnectionEventingEnablementType(d.Get("eventing_enablement_type"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("eventing_enablement_type"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, eventingEnablementTypeProp)) {
		obj["eventingEnablementType"] = eventingEnablementTypeProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationConnectorsBasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Connection %q: %#v", d.Id(), obj)
	updateMask := []string{}

	if d.HasChange("description") {
		updateMask = append(updateMask, "description")
	}

	if d.HasChange("labels") {
		updateMask = append(updateMask, "labels")
	}

	if d.HasChange("connector_version") {
		updateMask = append(updateMask, "connectorVersion")
	}

	if d.HasChange("config_variables") {
		updateMask = append(updateMask, "configVariables")
	}

	if d.HasChange("auth_config") {
		updateMask = append(updateMask, "authConfig")
	}

	if d.HasChange("service_account") {
		updateMask = append(updateMask, "serviceAccount")
	}

	if d.HasChange("service_directory") {
		updateMask = append(updateMask, "serviceDirectory")
	}

	if d.HasChange("destination_config") {
		updateMask = append(updateMask, "destinationConfig")
	}

	if d.HasChange("node_config") {
		updateMask = append(updateMask, "nodeConfig")
	}

	if d.HasChange("eventing_config") {
		updateMask = append(updateMask, "eventingConfig")
	}

	if d.HasChange("eventing_enablement_type") {
		updateMask = append(updateMask, "eventingEnablementType")
	}
	// updateMask is a URL parameter but not present in the schema, so ReplaceVars
	// won't set it
	url, err = transport_tpg.AddQueryParams(url, map[string]string{"updateMask": strings.Join(updateMask, ",")})
	if err != nil {
		return err
	}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	// if updateMask is empty we are not updating anything so skip the post
	if len(updateMask) > 0 {
		res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "PATCH",
			Project:   billingProject,
			RawURL:    url,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutUpdate),
		})

		if err != nil {
			return fmt.Errorf("Error updating Connection %q: %s", d.Id(), err)
		} else {
			log.Printf("[DEBUG] Finished updating Connection %q: %#v", d.Id(), res)
		}

		err = IntegrationConnectorsOperationWaitTime(
			config, res, project, "Updating Connection", userAgent,
			d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return err
		}
	}

	return resourceIntegrationConnectorsConnectionRead(d, meta)
}

func resourceIntegrationConnectorsConnectionDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Connection: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{IntegrationConnectorsBasePath}}projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Connection %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Connection")
	}

	err = IntegrationConnectorsOperationWaitTime(
		config, res, project, "Deleting Connection", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Connection %q: %#v", d.Id(), res)
	return nil
}

func resourceIntegrationConnectorsConnectionImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/connections/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/connections/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenIntegrationConnectorsConnectionName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConnectorVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionStatus(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["state"] =
		flattenIntegrationConnectorsConnectionStatusState(original["state"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionStatusState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionConfigVariables(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key"] =
		flattenIntegrationConnectorsConnectionConfigVariablesKey(original["key"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionConfigVariablesKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["auth_type"] =
		flattenIntegrationConnectorsConnectionAuthConfigAuthType(original["authType"], d, config)
	transformed["user_password"] =
		flattenIntegrationConnectorsConnectionAuthConfigUserPassword(original["userPassword"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigAuthType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigUserPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["username"] =
		flattenIntegrationConnectorsConnectionAuthConfigUserPasswordUsername(original["username"], d, config)
	transformed["password"] =
		flattenIntegrationConnectorsConnectionAuthConfigUserPasswordPassword(original["password"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigUserPasswordUsername(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionAuthConfigUserPasswordPassword(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_version"] =
		flattenIntegrationConnectorsConnectionAuthConfigUserPasswordPasswordSecretVersion(original["secretVersion"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionAuthConfigUserPasswordPasswordSecretVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionServiceDirectory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionDestinationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key"] =
		flattenIntegrationConnectorsConnectionDestinationConfigKey(original["key"], d, config)
	transformed["destinations"] =
		flattenIntegrationConnectorsConnectionDestinationConfigDestinations(original["destinations"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionDestinationConfigKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionDestinationConfigDestinations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"port":               flattenIntegrationConnectorsConnectionDestinationConfigDestinationsPort(original["port"], d, config),
			"service_attachment": flattenIntegrationConnectorsConnectionDestinationConfigDestinationsServiceAttachment(original["serviceAttachment"], d, config),
			"host":               flattenIntegrationConnectorsConnectionDestinationConfigDestinationsHost(original["host"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionDestinationConfigDestinationsPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionDestinationConfigDestinationsServiceAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionDestinationConfigDestinationsHost(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionNodeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["min_node_count"] =
		flattenIntegrationConnectorsConnectionNodeConfigMinNodeCount(original["minNodeCount"], d, config)
	transformed["max_node_count"] =
		flattenIntegrationConnectorsConnectionNodeConfigMaxNodeCount(original["maxNodeCount"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionNodeConfigMinNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionNodeConfigMaxNodeCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionEventingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["registration_destination_config"] =
		flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfig(original["registrationDestinationConfig"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["destination_config"] =
		flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfig(original["destinationConfig"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key"] =
		flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigKey(original["key"], d, config)
	transformed["destinations"] =
		flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinations(original["destinations"], d, config)
	return []interface{}{transformed}
}
func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"port":               flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsPort(original["port"], d, config),
			"service_attachment": flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsServiceAttachment(original["serviceAttachment"], d, config),
			"host":               flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsHost(original["host"], d, config),
		})
	}
	return transformed
}
func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsServiceAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsHost(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenIntegrationConnectorsConnectionEventingEnablementType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandIntegrationConnectorsConnectionDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandIntegrationConnectorsConnectionConnectorVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionConfigVariables(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKey, err := expandIntegrationConnectorsConnectionConfigVariablesKey(original["key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["key"] = transformedKey
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionConfigVariablesKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedAuthType, err := expandIntegrationConnectorsConnectionAuthConfigAuthType(original["auth_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAuthType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["authType"] = transformedAuthType
	}

	transformedUserPassword, err := expandIntegrationConnectorsConnectionAuthConfigUserPassword(original["user_password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUserPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["userPassword"] = transformedUserPassword
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigAuthType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigUserPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUsername, err := expandIntegrationConnectorsConnectionAuthConfigUserPasswordUsername(original["username"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUsername); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["username"] = transformedUsername
	}

	transformedPassword, err := expandIntegrationConnectorsConnectionAuthConfigUserPasswordPassword(original["password"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPassword); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["password"] = transformedPassword
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigUserPasswordUsername(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionAuthConfigUserPasswordPassword(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretVersion, err := expandIntegrationConnectorsConnectionAuthConfigUserPasswordPasswordSecretVersion(original["secret_version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretVersion"] = transformedSecretVersion
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionAuthConfigUserPasswordPasswordSecretVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionServiceDirectory(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionDestinationConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKey, err := expandIntegrationConnectorsConnectionDestinationConfigKey(original["key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["key"] = transformedKey
	}

	transformedDestinations, err := expandIntegrationConnectorsConnectionDestinationConfigDestinations(original["destinations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["destinations"] = transformedDestinations
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigDestinations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPort, err := expandIntegrationConnectorsConnectionDestinationConfigDestinationsPort(original["port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["port"] = transformedPort
		}

		transformedServiceAttachment, err := expandIntegrationConnectorsConnectionDestinationConfigDestinationsServiceAttachment(original["service_attachment"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedServiceAttachment); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["serviceAttachment"] = transformedServiceAttachment
		}

		transformedHost, err := expandIntegrationConnectorsConnectionDestinationConfigDestinationsHost(original["host"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHost); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["host"] = transformedHost
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigDestinationsPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigDestinationsServiceAttachment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionDestinationConfigDestinationsHost(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionNodeConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMinNodeCount, err := expandIntegrationConnectorsConnectionNodeConfigMinNodeCount(original["min_node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minNodeCount"] = transformedMinNodeCount
	}

	transformedMaxNodeCount, err := expandIntegrationConnectorsConnectionNodeConfigMaxNodeCount(original["max_node_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxNodeCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxNodeCount"] = transformedMaxNodeCount
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionNodeConfigMinNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionNodeConfigMaxNodeCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRegistrationDestinationConfig, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfig(original["registration_destination_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRegistrationDestinationConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["registrationDestinationConfig"] = transformedRegistrationDestinationConfig
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDestinationConfig, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfig(original["destination_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinationConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["destinationConfig"] = transformedDestinationConfig
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKey, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigKey(original["key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["key"] = transformedKey
	}

	transformedDestinations, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinations(original["destinations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDestinations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["destinations"] = transformedDestinations
	}

	return transformed, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPort, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsPort(original["port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["port"] = transformedPort
		}

		transformedServiceAttachment, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsServiceAttachment(original["service_attachment"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedServiceAttachment); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["serviceAttachment"] = transformedServiceAttachment
		}

		transformedHost, err := expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsHost(original["host"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedHost); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["host"] = transformedHost
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsServiceAttachment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingConfigRegistrationDestinationConfigDestinationConfigDestinationsHost(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandIntegrationConnectorsConnectionEventingEnablementType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
