// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package backupdr

import (
	"fmt"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"
)

func ResourceBackupDRBackup() *schema.Resource {
	return &schema.Resource{
		Create: resourceBackupDRBackupCreate,
		Read:   resourceBackupDRBackupRead,
		Update: resourceBackupDRBackupUpdate,
		Delete: resourceBackupDRBackupDelete,

		Importer: &schema.ResourceImporter{
			State: resourceBackupDRBackupImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(0 * time.Minute),
			Update: schema.DefaultTimeout(0 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"backup_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Id of the requesting object, Backup`,
			},
			"backup_vault_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Name of the Backup Vault associated with Backup`,
			},
			"data_source_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Name of the Data Source associated with Backup`,
			},
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `Location of the resource`,
			},
			"backup_appliance_locks": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `The list of BackupLocks taken by the accessor Backup Appliance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"lock_until_time": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `The time after which this lock is not considered valid and will no longer protect the Backup from deletion.`,
						},
						"backup_appliance_lock_info": {
							Type:        schema.TypeList,
							Optional:    true,
							ForceNew:    true,
							Description: `A nested object resource`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"backup_appliance_id": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `The ID of the backup/recovery appliance that created this lock.`,
									},
									"backup_appliance_name": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `The name of the backup/recovery appliance that created this lock.`,
									},
									"lock_reason": {
										Type:        schema.TypeString,
										Required:    true,
										ForceNew:    true,
										Description: `The reason for the lock: e.g. MOUNT/RESTORE/BACKUP/etc. The value of this string is only meaningful to the client and it is not interpreted by the BackupVault service.`,
									},
									"backup_image": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The image name that depends on this Backup.`,
									},
									"job_name": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The job name on the backup/recovery appliance that created this lock.`,
									},
									"sla_id": {
										Type:        schema.TypeInt,
										Optional:    true,
										ForceNew:    true,
										Description: `The SLA on the backup/recovery appliance that owns the lock.`,
									},
								},
							},
						},
						"service_lock_info": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `A nested object resource`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"operation": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The name of the operation that created this lock. The lock will automatically be released when the operation completes.`,
									},
								},
							},
						},
					},
				},
			},
			"e_tag": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `Server specified ETag to prevent updates from overwriting each other.`,
			},
			"enforced_retention_end_time": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The backup can not be deleted before this time.`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Resource labels to represent user provided metadata.


**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"backup_appliance_backup_properties": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `A nested object resource`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"recovery_range_end_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The latest timestamp of data available in this Backup.`,
						},
						"recovery_range_start_time": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The earliest timestamp of data available in this Backup.`,
						},
						"finalize_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The time when this backup object was finalized (if none, backup is not finalized).`,
						},
						"generation_id": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The numeric generation ID of the backup (monotonically increasing).`,
						},
					},
				},
			},
			"backup_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Type of the backup, unspecified, scheduled or ondemand.`,
				Default:     "BACKUP_TYPE_UNSPECIFIED",
			},
			"compute_instance_backup_properties": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Compute Engine specific backup properties.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"can_ip_forward": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Enables instances created based on these properties to send packets with source IP addresses other than their own and receive packets with destination IP addresses other than their own. If these instances will be used as an IP gateway or it will be set as the next-hop in a Route resource, specify 'true'. If unsure, leave this set to 'false'. See the https://cloud.google.com/vpc/docs/using-routes#canipforward documentation for more information.`,
						},
						"description": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `An optional text description for the instances that are created from these properties.`,
						},
						"disk": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `An array of disks that are associated with the instances that are created from these properties.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"auto_delete": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Specifies whether the disk will be auto-deleted when the instance is deleted (but not when the disk is detached from the instance).`,
									},
									"boot": {
										Type:        schema.TypeBool,
										Optional:    true,
										Description: `Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.`,
									},
									"device_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `This is used as an identifier for the disks. This is the unique name has to provided to modify disk parameters like disk_name and replica_zones (in case of RePDs)`,
									},
									"disk_encryption_key": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Encrypts or decrypts a disk using a customer-supplied encryption key.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"kms_key_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The name of the encryption key that is stored in Google Cloud KMS.`,
												},
												"kms_key_service_account": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used.`,
												},
												"raw_key": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Specifies a 256-bit customer-supplied encryption key.`,
												},
												"rsa_encrypted_key": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource.`,
												},
											},
										},
									},
									"disk_interface": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DISK_INTERFACE_UNSPECIFIED", "SCSI", "NVME", "NVDIMM", "ISCSI", ""}),
										Description:  `Specifies the disk interface to use for attaching this disk. Default value: "DISK_INTERFACE_UNSPECIFIED" Possible values: ["DISK_INTERFACE_UNSPECIFIED", "SCSI", "NVME", "NVDIMM", "ISCSI"]`,
										Default:      "DISK_INTERFACE_UNSPECIFIED",
									},
									"disk_size_gb": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `The size of the disk in GB.`,
									},
									"guest_os_feature": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `A list of features to enable on the guest operating system. Applicable only for bootable images.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"FEATURE_TYPE_UNSPECIFIED", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "MULTI_IP_SUBNET", "UEFI_COMPATIBLE", "SECURE_BOOT", "GVNIC", "SEV_CAPABLE", "BARE_METAL_LINUX_COMPATIBLE", "SUSPEND_RESUME_COMPATIBLE", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "TDX_CAPABLE", "IDPF", "SEV_LIVE_MIGRATABLE_V2", ""}),
													Description:  `The ID of a supported feature. Default value: "FEATURE_TYPE_UNSPECIFIED" Possible values: ["FEATURE_TYPE_UNSPECIFIED", "VIRTIO_SCSI_MULTIQUEUE", "WINDOWS", "MULTI_IP_SUBNET", "UEFI_COMPATIBLE", "SECURE_BOOT", "GVNIC", "SEV_CAPABLE", "BARE_METAL_LINUX_COMPATIBLE", "SUSPEND_RESUME_COMPATIBLE", "SEV_LIVE_MIGRATABLE", "SEV_SNP_CAPABLE", "TDX_CAPABLE", "IDPF", "SEV_LIVE_MIGRATABLE_V2"]`,
													Default:      "FEATURE_TYPE_UNSPECIFIED",
												},
											},
										},
									},
									"index": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `A zero-based index to this disk, where 0 is reserved for the boot disk.`,
									},
									"initialize_params": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Specifies the parameters to initialize this disk.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"disk_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Specifies the disk name. If not specified, the default is to use the name of the instance.`,
												},
												"replica_zones": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `URL of the zone where the disk should be created. Required for each regional disk associated with the instance.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"kind": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Type of the resource.`,
									},
									"license": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Any valid publicly visible licenses.`,
									},
									"mode": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DISK_MODE_UNSPECIFIED", "READ_WRITE", "READ_ONLY", "LOCKED", ""}),
										Description:  `The mode in which to attach this disk. Default value: "DISK_MODE_UNSPECIFIED" Possible values: ["DISK_MODE_UNSPECIFIED", "READ_WRITE", "READ_ONLY", "LOCKED"]`,
										Default:      "DISK_MODE_UNSPECIFIED",
									},
									"source": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Specifies a valid partial or full URL to an existing Persistent Disk resource.`,
									},
									"type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"DISK_TYPE_UNSPECIFIED", "SCRATCH", "PERSISTENT", ""}),
										Description:  `Specifies the type of the disk. Default value: "DISK_TYPE_UNSPECIFIED" Possible values: ["DISK_TYPE_UNSPECIFIED", "SCRATCH", "PERSISTENT"]`,
										Default:      "DISK_TYPE_UNSPECIFIED",
									},
									"disk_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The URI of the disk type resource. For example: projects/project/zones/zone/diskTypes/pd-standard or pd-ssd`,
									},
									"saved_state": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The state of the disk.`,
										Default:     "DISK_SAVED_STATE_UNSPECIFIED",
									},
								},
							},
						},
						"machine_type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The machine type to use for instances that are created from these properties.`,
						},
						"network_interface": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `An array of network access configurations for this interface.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"access_configs": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `An array of configurations for this interface. Currently, only one access config,ONE_TO_ONE_NAT is supported. If there are no accessConfigs specified, then this instance will have no external internet access.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"external_ip": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The external IP address of this access configuration.`,
												},
												"external_ipv6": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The external IPv6 address of this access configuration.`,
												},
												"external_ipv6_prefix_length": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `The prefix length of the external IPv6 range.`,
												},
												"name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The name of this access configuration.`,
												},
												"network_tier": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"NETWORK_TIER_UNSPECIFIED", "PREMIUM", "STANDARD", ""}),
													Description:  `This signifies the networking tier used for configuring this access Default value: "NETWORK_TIER_UNSPECIFIED" Possible values: ["NETWORK_TIER_UNSPECIFIED", "PREMIUM", "STANDARD"]`,
													Default:      "NETWORK_TIER_UNSPECIFIED",
												},
												"public_ptr_domain_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The DNS domain name for the public PTR record.`,
												},
												"set_public_ptr": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `Specifies whether a public DNS 'PTR' record should be created to map the external IP address of the instance to a DNS domain name.`,
												},
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"ACCESS_TYPE_UNSPECIFIED", "ONE_TO_ONE_NAT", "DIRECT_IPV6", ""}),
													Description:  `In accessConfigs (IPv4), the default and only option is ONE_TO_ONE_NAT. In ipv6AccessConfigs, the default and only option is DIRECT_IPV6. Default value: "ACCESS_TYPE_UNSPECIFIED" Possible values: ["ACCESS_TYPE_UNSPECIFIED", "ONE_TO_ONE_NAT", "DIRECT_IPV6"]`,
													Default:      "ACCESS_TYPE_UNSPECIFIED",
												},
											},
										},
									},
									"alias_ip_ranges": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `An array of alias IP ranges for this network interface. You can only specify this field for network interfaces in VPC networks.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"ip_cidr_range": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The IP alias ranges to allocate for this interface.`,
												},
												"subnetwork_range_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The name of a subnetwork secondary IP range from which to allocate an IP alias range. If not specified, the primary range of the subnetwork is used.`,
												},
											},
										},
									},
									"internal_ipv6_prefix_length": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `The prefix length of the primary internal IPv6 range.`,
									},
									"ip_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `An IPv4 internal IP address to assign to the instance for this network interface. If not specified by the user, an unused internal IP is assigned by the system.`,
									},
									"ipv6_access_configs": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"external_ip": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The external IP address of this access configuration.`,
												},
												"external_ipv6": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The external IPv6 address of this access configuration.`,
												},
												"external_ipv6_prefix_length": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `The prefix length of the external IPv6 range.`,
												},
												"name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The name of this access configuration.`,
												},
												"network_tier": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"NETWORK_TIER_UNSPECIFIED", "PREMIUM", "STANDARD", ""}),
													Description:  `This signifies the networking tier used for configuring this access Default value: "NETWORK_TIER_UNSPECIFIED" Possible values: ["NETWORK_TIER_UNSPECIFIED", "PREMIUM", "STANDARD"]`,
													Default:      "NETWORK_TIER_UNSPECIFIED",
												},
												"public_ptr_domain_name": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `The DNS domain name for the public PTR record.`,
												},
												"set_public_ptr": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `Specifies whether a public DNS 'PTR' record should be created to map the external IP address of the instance to a DNS domain name.`,
												},
												"type": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"ACCESS_TYPE_UNSPECIFIED", "ONE_TO_ONE_NAT", "DIRECT_IPV6", ""}),
													Description:  `In accessConfigs (IPv4), the default and only option is ONE_TO_ONE_NAT. In ipv6AccessConfigs, the default and only option is DIRECT_IPV6. Default value: "ACCESS_TYPE_UNSPECIFIED" Possible values: ["ACCESS_TYPE_UNSPECIFIED", "ONE_TO_ONE_NAT", "DIRECT_IPV6"]`,
													Default:      "ACCESS_TYPE_UNSPECIFIED",
												},
											},
										},
									},
									"ipv6_access_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"UNSPECIFIED_IPV6_ACCESS_TYPE", "INTERNAL", "EXTERNAL", ""}),
										Description:  `One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork. Default value: "UNSPECIFIED_IPV6_ACCESS_TYPE" Possible values: ["UNSPECIFIED_IPV6_ACCESS_TYPE", "INTERNAL", "EXTERNAL"]`,
										Default:      "UNSPECIFIED_IPV6_ACCESS_TYPE",
									},
									"ipv6_address": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `An IPv6 internal network address for this network interface. To use a static internal IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.`,
									},
									"network": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `URL of the VPC network resource for this instance.`,
									},
									"network_attachment": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The URL of the network attachment that this interface should connect to in the following format: projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.`,
									},
									"nic_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"NIC_TYPE_UNSPECIFIED", "VIRTIO_NET", "GVNIC", ""}),
										Description:  `The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet. Default value: "NIC_TYPE_UNSPECIFIED" Possible values: ["NIC_TYPE_UNSPECIFIED", "VIRTIO_NET", "GVNIC"]`,
										Default:      "NIC_TYPE_UNSPECIFIED",
									},
									"queue_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It'll be empty if not specified by the users.`,
									},
									"stack_type": {
										Type:         schema.TypeString,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"STACK_TYPE_UNSPECIFIED", "IPV4_ONLY", "IPV4_IPV6", ""}),
										Description:  `The stack type for this network interface. Default value: "STACK_TYPE_UNSPECIFIED" Possible values: ["STACK_TYPE_UNSPECIFIED", "IPV4_ONLY", "IPV4_IPV6"]`,
										Default:      "STACK_TYPE_UNSPECIFIED",
									},
									"subnetwork": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The URL of the Subnetwork resource for this instance.`,
									},
									"name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The name of the network interface, which is generated by the server.`,
									},
								},
							},
						},
						"tags": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `A list of tags to apply to the instances that are created from these properties. The tags identify valid sources or targets for network firewalls. The setTags method can modify this list of tags. Each tag within the list must comply with RFC1035 (https://www.ietf.org/rfc/rfc1035.txt).`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"items": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
					},
				},
			},
			"consistency_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The point in time when this backup was captured from the source.`,
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time when the instance was created.`,
			},
			"description": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The description of the Backup instance (2048 characters or less).`,
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				ForceNew:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"gcp_backup_plan_info": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Configuration for a Google Cloud resource.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"backup_plan": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Resource name of backup plan by which workload is protected at the time of the backup. Format: projects/{project}/locations/{location}/backupPlans/{backupPlanId}`,
						},
						"backup_plan_rule_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The rule id of the backup plan which triggered this backup in case of scheduled backup or used for`,
						},
					},
				},
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The name of the backup.`,
			},
			"resource_size_bytes": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `Source resource size in bytes at the time of the backup.`,
			},
			"service_locks": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The list of BackupLocks taken by the service to prevent the deletion of the backup.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"lock_until_time": {
							Type:        schema.TypeString,
							Required:    true,
							Description: `The time after which this lock is not considered valid and will no longer protect the Backup from deletion.`,
						},
						"backup_appliance_lock_info": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `A nested object resource`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"backup_appliance_id": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The ID of the backup/recovery appliance that created this lock.`,
									},
									"backup_appliance_name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The name of the backup/recovery appliance that created this lock.`,
									},
									"lock_reason": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `The reason for the lock: e.g. MOUNT/RESTORE/BACKUP/etc. The value of this string is only meaningful to the client and it is not interpreted by the BackupVault service.`,
									},
									"backup_image": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The image name that depends on this Backup.`,
									},
									"job_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `The job name on the backup/recovery appliance that created this lock.`,
									},
									"sla_id": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `The SLA on the backup/recovery appliance that owns the lock.`,
									},
								},
							},
						},
						"service_lock_info": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `A nested object resource`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"operation": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The name of the operation that created this lock. The lock will automatically be released when the operation completes.`,
									},
								},
							},
						},
					},
				},
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The Backup resource instance state.`,
				Default:     "STATE_UNSPECIFIED",
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The time when the instance was updated.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceBackupDRBackupCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	enforcedRetentionEndTimeProp, err := expandBackupDRBackupEnforcedRetentionEndTime(d.Get("enforced_retention_end_time"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("enforced_retention_end_time"); !tpgresource.IsEmptyValue(reflect.ValueOf(enforcedRetentionEndTimeProp)) && (ok || !reflect.DeepEqual(v, enforcedRetentionEndTimeProp)) {
		obj["enforcedRetentionEndTime"] = enforcedRetentionEndTimeProp
	}
	eTagProp, err := expandBackupDRBackupETag(d.Get("e_tag"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("e_tag"); !tpgresource.IsEmptyValue(reflect.ValueOf(eTagProp)) && (ok || !reflect.DeepEqual(v, eTagProp)) {
		obj["eTag"] = eTagProp
	}
	backupApplianceLocksProp, err := expandBackupDRBackupBackupApplianceLocks(d.Get("backup_appliance_locks"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("backup_appliance_locks"); !tpgresource.IsEmptyValue(reflect.ValueOf(backupApplianceLocksProp)) && (ok || !reflect.DeepEqual(v, backupApplianceLocksProp)) {
		obj["backupApplianceLocks"] = backupApplianceLocksProp
	}
	labelsProp, err := expandBackupDRBackupEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BackupDRBasePath}}projects/{{project}}/locations/{{location}}/backupVaults/{{backupvault}}/dataSources/{{datasource}}/backups/{{backup}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Backup: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Backup: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
		Headers:   headers,
	})
	if err != nil {
		return fmt.Errorf("Error creating Backup: %s", err)
	}
	if err := d.Set("name", flattenBackupDRBackupName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/backupVaults/{{backupvault}}/dataSources/{{datasource}}/backups/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Backup %q: %#v", d.Id(), res)

	return resourceBackupDRBackupRead(d, meta)
}

func resourceBackupDRBackupRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{BackupDRBasePath}}projects/{{project}}/locations/{{location}}/backupVaults/{{backupvault}}/dataSources/{{datasource}}/backups/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Backup: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("BackupDRBackup %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}

	if err := d.Set("name", flattenBackupDRBackupName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("description", flattenBackupDRBackupDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("create_time", flattenBackupDRBackupCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("update_time", flattenBackupDRBackupUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("labels", flattenBackupDRBackupLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("enforced_retention_end_time", flattenBackupDRBackupEnforcedRetentionEndTime(res["enforcedRetentionEndTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("consistency_time", flattenBackupDRBackupConsistencyTime(res["consistencyTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("e_tag", flattenBackupDRBackupETag(res["eTag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("state", flattenBackupDRBackupState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("service_locks", flattenBackupDRBackupServiceLocks(res["serviceLocks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("backup_appliance_locks", flattenBackupDRBackupBackupApplianceLocks(res["backupApplianceLocks"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("compute_instance_backup_properties", flattenBackupDRBackupComputeInstanceBackupProperties(res["computeInstanceBackupProperties"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("backup_appliance_backup_properties", flattenBackupDRBackupBackupApplianceBackupProperties(res["backupApplianceBackupProperties"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("backup_type", flattenBackupDRBackupBackupType(res["backupType"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("gcp_backup_plan_info", flattenBackupDRBackupGcpBackupPlanInfo(res["gcpBackupPlanInfo"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("resource_size_bytes", flattenBackupDRBackupResourceSizeBytes(res["resourceSizeBytes"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("terraform_labels", flattenBackupDRBackupTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}
	if err := d.Set("effective_labels", flattenBackupDRBackupEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Backup: %s", err)
	}

	return nil
}

func resourceBackupDRBackupUpdate(d *schema.ResourceData, meta interface{}) error {
	// Only the root field "labels" and "terraform_labels" are mutable
	return resourceBackupDRBackupRead(d, meta)
}

func resourceBackupDRBackupDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Backup: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{BackupDRBasePath}}projects/{{project}}/locations/{{location}}/backupVaults/{{backupvault}}/dataSources/{{datasource}}/backups/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	headers := make(http.Header)

	log.Printf("[DEBUG] Deleting Backup %q", d.Id())
	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
		Headers:   headers,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Backup")
	}

	err = BackupDROperationWaitTime(
		config, res, project, "Deleting Backup", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Backup %q: %#v", d.Id(), res)
	return nil
}

func resourceBackupDRBackupImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/backupVaults/(?P<backupvault>[^/]+)/dataSources/(?P<datasource>[^/]+)/backups/(?P<backup>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<backupvault>[^/]+)/(?P<datasource>[^/]+)/(?P<backup>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<backupvault>[^/]+)/(?P<datasource>[^/]+)/(?P<backup>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/backupVaults/{{backupvault}}/dataSources/{{datasource}}/backups/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenBackupDRBackupName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenBackupDRBackupEnforcedRetentionEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupConsistencyTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupETag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupServiceLocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"lock_until_time":            flattenBackupDRBackupServiceLocksLockUntilTime(original["lockUntilTime"], d, config),
			"backup_appliance_lock_info": flattenBackupDRBackupServiceLocksBackupApplianceLockInfo(original["backupApplianceLockInfo"], d, config),
			"service_lock_info":          flattenBackupDRBackupServiceLocksServiceLockInfo(original["serviceLockInfo"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRBackupServiceLocksLockUntilTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupServiceLocksBackupApplianceLockInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["backup_appliance_id"] =
		flattenBackupDRBackupServiceLocksBackupApplianceLockInfoBackupApplianceId(original["backupApplianceId"], d, config)
	transformed["backup_appliance_name"] =
		flattenBackupDRBackupServiceLocksBackupApplianceLockInfoBackupApplianceName(original["backupApplianceName"], d, config)
	transformed["lock_reason"] =
		flattenBackupDRBackupServiceLocksBackupApplianceLockInfoLockReason(original["lockReason"], d, config)
	transformed["job_name"] =
		flattenBackupDRBackupServiceLocksBackupApplianceLockInfoJobName(original["jobName"], d, config)
	transformed["backup_image"] =
		flattenBackupDRBackupServiceLocksBackupApplianceLockInfoBackupImage(original["backupImage"], d, config)
	transformed["sla_id"] =
		flattenBackupDRBackupServiceLocksBackupApplianceLockInfoSlaId(original["slaId"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupServiceLocksBackupApplianceLockInfoBackupApplianceId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupServiceLocksBackupApplianceLockInfoBackupApplianceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupServiceLocksBackupApplianceLockInfoLockReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupServiceLocksBackupApplianceLockInfoJobName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupServiceLocksBackupApplianceLockInfoBackupImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupServiceLocksBackupApplianceLockInfoSlaId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupServiceLocksServiceLockInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["operation"] =
		flattenBackupDRBackupServiceLocksServiceLockInfoOperation(original["operation"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupServiceLocksServiceLockInfoOperation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceLocks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"lock_until_time":            flattenBackupDRBackupBackupApplianceLocksLockUntilTime(original["lockUntilTime"], d, config),
			"backup_appliance_lock_info": flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfo(original["backupApplianceLockInfo"], d, config),
			"service_lock_info":          flattenBackupDRBackupBackupApplianceLocksServiceLockInfo(original["serviceLockInfo"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRBackupBackupApplianceLocksLockUntilTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["backup_appliance_id"] =
		flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupApplianceId(original["backupApplianceId"], d, config)
	transformed["backup_appliance_name"] =
		flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupApplianceName(original["backupApplianceName"], d, config)
	transformed["lock_reason"] =
		flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoLockReason(original["lockReason"], d, config)
	transformed["job_name"] =
		flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoJobName(original["jobName"], d, config)
	transformed["backup_image"] =
		flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupImage(original["backupImage"], d, config)
	transformed["sla_id"] =
		flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoSlaId(original["slaId"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupApplianceId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupApplianceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoLockReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoJobName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoSlaId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupBackupApplianceLocksServiceLockInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["operation"] =
		flattenBackupDRBackupBackupApplianceLocksServiceLockInfoOperation(original["operation"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupBackupApplianceLocksServiceLockInfoOperation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["description"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesDescription(original["description"], d, config)
	transformed["tags"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesTags(original["tags"], d, config)
	transformed["machine_type"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesMachineType(original["machineType"], d, config)
	transformed["can_ip_forward"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesCanIpForward(original["canIpForward"], d, config)
	transformed["network_interface"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterface(original["networkInterface"], d, config)
	transformed["disk"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesDisk(original["disk"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["items"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesTagsItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesTagsItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesMachineType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesCanIpForward(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterface(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"network":                     flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceNetwork(original["network"], d, config),
			"subnetwork":                  flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceSubnetwork(original["subnetwork"], d, config),
			"ip_address":                  flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpAddress(original["ipAddress"], d, config),
			"ipv6_address":                flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6Address(original["ipv6Address"], d, config),
			"internal_ipv6_prefix_length": flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceInternalIpv6PrefixLength(original["internalIpv6PrefixLength"], d, config),
			"name":                        flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceName(original["name"], d, config),
			"access_configs":              flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigs(original["accessConfigs"], d, config),
			"ipv6_access_configs":         flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigs(original["ipv6AccessConfigs"], d, config),
			"alias_ip_ranges":             flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAliasIpRanges(original["aliasIpRanges"], d, config),
			"stack_type":                  flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceStackType(original["stackType"], d, config),
			"ipv6_access_type":            flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessType(original["ipv6AccessType"], d, config),
			"queue_count":                 flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceQueueCount(original["queueCount"], d, config),
			"nic_type":                    flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceNicType(original["nicType"], d, config),
			"network_attachment":          flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceNetworkAttachment(original["networkAttachment"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceSubnetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpAddress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6Address(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceInternalIpv6PrefixLength(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                        flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsType(original["type"], d, config),
			"name":                        flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsName(original["name"], d, config),
			"external_ip":                 flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsExternalIp(original["externalIp"], d, config),
			"external_ipv6":               flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsExternalIpv6(original["externalIpv6"], d, config),
			"external_ipv6_prefix_length": flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsExternalIpv6PrefixLength(original["externalIpv6PrefixLength"], d, config),
			"set_public_ptr":              flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsSetPublicPtr(original["setPublicPtr"], d, config),
			"public_ptr_domain_name":      flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsPublicPtrDomainName(original["publicPtrDomainName"], d, config),
			"network_tier":                flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsNetworkTier(original["networkTier"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsExternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsExternalIpv6(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsExternalIpv6PrefixLength(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsSetPublicPtr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsPublicPtrDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAccessConfigsNetworkTier(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                        flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsType(original["type"], d, config),
			"name":                        flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsName(original["name"], d, config),
			"external_ip":                 flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsExternalIp(original["externalIp"], d, config),
			"external_ipv6":               flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsExternalIpv6(original["externalIpv6"], d, config),
			"external_ipv6_prefix_length": flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsExternalIpv6PrefixLength(original["externalIpv6PrefixLength"], d, config),
			"set_public_ptr":              flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsSetPublicPtr(original["setPublicPtr"], d, config),
			"public_ptr_domain_name":      flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsPublicPtrDomainName(original["publicPtrDomainName"], d, config),
			"network_tier":                flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsNetworkTier(original["networkTier"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsExternalIp(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsExternalIpv6(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsExternalIpv6PrefixLength(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsSetPublicPtr(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsPublicPtrDomainName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessConfigsNetworkTier(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAliasIpRanges(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"ip_cidr_range":         flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAliasIpRangesIpCidrRange(original["ipCidrRange"], d, config),
			"subnetwork_range_name": flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAliasIpRangesSubnetworkRangeName(original["subnetworkRangeName"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAliasIpRangesIpCidrRange(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceAliasIpRangesSubnetworkRangeName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceStackType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceIpv6AccessType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceQueueCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceNicType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesNetworkInterfaceNetworkAttachment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDisk(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"initialize_params":   flattenBackupDRBackupComputeInstanceBackupPropertiesDiskInitializeParams(original["initializeParams"], d, config),
			"device_name":         flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDeviceName(original["deviceName"], d, config),
			"kind":                flattenBackupDRBackupComputeInstanceBackupPropertiesDiskKind(original["kind"], d, config),
			"mode":                flattenBackupDRBackupComputeInstanceBackupPropertiesDiskMode(original["mode"], d, config),
			"source":              flattenBackupDRBackupComputeInstanceBackupPropertiesDiskSource(original["source"], d, config),
			"index":               flattenBackupDRBackupComputeInstanceBackupPropertiesDiskIndex(original["index"], d, config),
			"boot":                flattenBackupDRBackupComputeInstanceBackupPropertiesDiskBoot(original["boot"], d, config),
			"auto_delete":         flattenBackupDRBackupComputeInstanceBackupPropertiesDiskAutoDelete(original["autoDelete"], d, config),
			"license":             flattenBackupDRBackupComputeInstanceBackupPropertiesDiskLicense(original["license"], d, config),
			"disk_interface":      flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskInterface(original["diskInterface"], d, config),
			"guest_os_feature":    flattenBackupDRBackupComputeInstanceBackupPropertiesDiskGuestOsFeature(original["guestOsFeature"], d, config),
			"disk_encryption_key": flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKey(original["diskEncryptionKey"], d, config),
			"disk_size_gb":        flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskSizeGb(original["diskSizeGb"], d, config),
			"saved_state":         flattenBackupDRBackupComputeInstanceBackupPropertiesDiskSavedState(original["savedState"], d, config),
			"disk_type":           flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskType(original["diskType"], d, config),
			"type":                flattenBackupDRBackupComputeInstanceBackupPropertiesDiskType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskInitializeParams(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["disk_name"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesDiskInitializeParamsDiskName(original["diskName"], d, config)
	transformed["replica_zones"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesDiskInitializeParamsReplicaZones(original["replicaZones"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskInitializeParamsDiskName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskInitializeParamsReplicaZones(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDeviceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskKind(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskIndex(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskBoot(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskAutoDelete(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskLicense(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskInterface(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskGuestOsFeature(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type": flattenBackupDRBackupComputeInstanceBackupPropertiesDiskGuestOsFeatureType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskGuestOsFeatureType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["raw_key"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKeyRawKey(original["rawKey"], d, config)
	transformed["rsa_encrypted_key"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKeyRsaEncryptedKey(original["rsaEncryptedKey"], d, config)
	transformed["kms_key_name"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKeyKmsKeyName(original["kmsKeyName"], d, config)
	transformed["kms_key_service_account"] =
		flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKeyKmsKeyServiceAccount(original["kmsKeyServiceAccount"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKeyRawKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKeyRsaEncryptedKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKeyKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskEncryptionKeyKmsKeyServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskSizeGb(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskSavedState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskDiskType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupComputeInstanceBackupPropertiesDiskType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceBackupProperties(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["generation_id"] =
		flattenBackupDRBackupBackupApplianceBackupPropertiesGenerationId(original["generationId"], d, config)
	transformed["finalize_time"] =
		flattenBackupDRBackupBackupApplianceBackupPropertiesFinalizeTime(original["finalizeTime"], d, config)
	transformed["recovery_range_start_time"] =
		flattenBackupDRBackupBackupApplianceBackupPropertiesRecoveryRangeStartTime(original["recoveryRangeStartTime"], d, config)
	transformed["recovery_range_end_time"] =
		flattenBackupDRBackupBackupApplianceBackupPropertiesRecoveryRangeEndTime(original["recoveryRangeEndTime"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupBackupApplianceBackupPropertiesGenerationId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupBackupApplianceBackupPropertiesFinalizeTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceBackupPropertiesRecoveryRangeStartTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupApplianceBackupPropertiesRecoveryRangeEndTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupBackupType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupGcpBackupPlanInfo(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["backup_plan"] =
		flattenBackupDRBackupGcpBackupPlanInfoBackupPlan(original["backupPlan"], d, config)
	transformed["backup_plan_rule_id"] =
		flattenBackupDRBackupGcpBackupPlanInfoBackupPlanRuleId(original["backupPlanRuleId"], d, config)
	return []interface{}{transformed}
}
func flattenBackupDRBackupGcpBackupPlanInfoBackupPlan(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupGcpBackupPlanInfoBackupPlanRuleId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenBackupDRBackupResourceSizeBytes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenBackupDRBackupTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenBackupDRBackupEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandBackupDRBackupEnforcedRetentionEndTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupETag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupBackupApplianceLocks(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedLockUntilTime, err := expandBackupDRBackupBackupApplianceLocksLockUntilTime(original["lock_until_time"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLockUntilTime); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["lockUntilTime"] = transformedLockUntilTime
		}

		transformedBackupApplianceLockInfo, err := expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfo(original["backup_appliance_lock_info"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedBackupApplianceLockInfo); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["backupApplianceLockInfo"] = transformedBackupApplianceLockInfo
		}

		transformedServiceLockInfo, err := expandBackupDRBackupBackupApplianceLocksServiceLockInfo(original["service_lock_info"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedServiceLockInfo); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["serviceLockInfo"] = transformedServiceLockInfo
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandBackupDRBackupBackupApplianceLocksLockUntilTime(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBackupApplianceId, err := expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupApplianceId(original["backup_appliance_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBackupApplianceId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["backupApplianceId"] = transformedBackupApplianceId
	}

	transformedBackupApplianceName, err := expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupApplianceName(original["backup_appliance_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBackupApplianceName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["backupApplianceName"] = transformedBackupApplianceName
	}

	transformedLockReason, err := expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoLockReason(original["lock_reason"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLockReason); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["lockReason"] = transformedLockReason
	}

	transformedJobName, err := expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoJobName(original["job_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedJobName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["jobName"] = transformedJobName
	}

	transformedBackupImage, err := expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupImage(original["backup_image"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBackupImage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["backupImage"] = transformedBackupImage
	}

	transformedSlaId, err := expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoSlaId(original["sla_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSlaId); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["slaId"] = transformedSlaId
	}

	return transformed, nil
}

func expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupApplianceId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupApplianceName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoLockReason(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoJobName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoBackupImage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupBackupApplianceLocksBackupApplianceLockInfoSlaId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupBackupApplianceLocksServiceLockInfo(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedOperation, err := expandBackupDRBackupBackupApplianceLocksServiceLockInfoOperation(original["operation"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOperation); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["operation"] = transformedOperation
	}

	return transformed, nil
}

func expandBackupDRBackupBackupApplianceLocksServiceLockInfoOperation(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandBackupDRBackupEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
