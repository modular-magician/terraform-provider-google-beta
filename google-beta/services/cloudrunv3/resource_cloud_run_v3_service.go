// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package cloudrunv3

import (
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"
)

func ResourceCloudRunV3Service() *schema.Resource {
	return &schema.Resource{
		Create: resourceCloudRunV3ServiceCreate,
		Read:   resourceCloudRunV3ServiceRead,
		Update: resourceCloudRunV3ServiceUpdate,
		Delete: resourceCloudRunV3ServiceDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCloudRunV3ServiceImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.SetLabelsDiff,
			tpgresource.SetAnnotationsDiff,
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the cloud run service`,
			},
			"name": {
				Type:             schema.TypeString,
				Required:         true,
				ForceNew:         true,
				DiffSuppressFunc: tpgresource.CompareSelfLinkOrResourceName,
				Description:      `Name of the Service.`,
			},
			"template": {
				Type:        schema.TypeList,
				Required:    true,
				Description: `The template used to create revisions for this Service.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"annotations": {
							Type:     schema.TypeMap,
							Optional: true,
							Description: `Unstructured key value map that may be set by external tools to store and arbitrary metadata. They are not queryable and should be preserved when modifying objects.

Cloud Run API v2 does not support annotations with 'run.googleapis.com', 'cloud.googleapis.com', 'serving.knative.dev', or 'autoscaling.knative.dev' namespaces, and they will be rejected.
All system annotations in v1 now have a corresponding field in v2 RevisionTemplate.

This field follows Kubernetes annotations' namespacing, limits, and rules.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"containers": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Holds the containers that define the unit of execution for this Service.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"image": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `URL of the Container image in Google Container Registry or Google Artifact Registry. More info: https://kubernetes.io/docs/concepts/containers/images`,
									},
									"args": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"command": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"depends_on": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Containers which should be started before this container. If specified the container will wait to start until all containers with the listed names are healthy.`,
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"env": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `List of environment variables to set in the container.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"name": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Name of the environment variable. Must be a C_IDENTIFIER, and mnay not exceed 32768 characters.`,
												},
												"value": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any route environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "", and the maximum length is 32768 bytes`,
												},
												"value_source": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Source for the environment variable's value.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"secret_key_ref": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `Selects a secret and a specific version from Cloud Secret Manager.`,
																MaxItems:    1,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"secret": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: `The name of the secret in Cloud Secret Manager. Format: {secretName} if the secret is in the same project. projects/{project}/secrets/{secretName} if the secret is in a different project.`,
																		},
																		"version": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version.`,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"liveness_probe": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										Description: `Periodic probe of container liveness. Container will be restarted if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"failure_threshold": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.`,
													Default:     3,
												},
												"grpc": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `GRPC specifies an action involving a GRPC port.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"port": {
																Type:     schema.TypeInt,
																Computed: true,
																Optional: true,
																Description: `Port number to access on the container. Number must be in the range 1 to 65535.
If not specified, defaults to the same value as container.ports[0].containerPort.`,
															},
															"service": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The name of the service to place in the gRPC HealthCheckRequest
(see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
If this is not specified, the default behavior is defined by gRPC.`,
															},
														},
													},
												},
												"http_get": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `HTTPGet specifies the http request to perform.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"http_headers": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `Custom headers to set in the request. HTTP allows repeated headers.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"name": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: `The header field name`,
																		},
																		"value": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `The header field value`,
																			Default:     "",
																		},
																	},
																},
															},
															"path": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `Path to access on the HTTP server. Defaults to '/'.`,
																Default:     "/",
															},
															"port": {
																Type:     schema.TypeInt,
																Computed: true,
																Optional: true,
																Description: `Port number to access on the container. Number must be in the range 1 to 65535.
If not specified, defaults to the same value as container.ports[0].containerPort.`,
															},
														},
													},
												},
												"initial_delay_seconds": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes`,
													Default:     0,
												},
												"period_seconds": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds`,
													Default:     10,
												},
												"tcp_socket": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `TCPSocketAction describes an action based on opening a socket`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"port": {
																Type:     schema.TypeInt,
																Required: true,
																Description: `Port number to access on the container. Must be in the range 1 to 65535.
If not specified, defaults to the exposed port of the container, which
is the value of container.ports[0].containerPort.`,
															},
														},
													},
												},
												"timeout_seconds": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes`,
													Default:     1,
												},
											},
										},
									},
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Name of the container specified as a DNS_LABEL.`,
									},
									"ports": {
										Type:     schema.TypeList,
										Computed: true,
										Optional: true,
										Description: `List of ports to expose from the container. Only a single port can be specified. The specified ports must be listening on all interfaces (0.0.0.0) within the container to be accessible.

If omitted, a port number will be chosen and passed to the container through the PORT environment variable for the container to listen on`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"container_port": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Port number the container listens on. This must be a valid TCP port number, 0 < containerPort < 65536.`,
												},
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Optional:    true,
													Description: `If specified, used to specify which protocol to use. Allowed values are "http1" and "h2c".`,
												},
											},
										},
									},
									"resources": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										Description: `Compute Resource requirements by this container. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"cpu_idle": {
													Type:     schema.TypeBool,
													Optional: true,
													Description: `Determines whether CPU is only allocated during requests. True by default if the parent 'resources' field is not set. However, if
'resources' is set, this field must be explicitly set to true to preserve the default behavior.`,
												},
												"limits": {
													Type:        schema.TypeMap,
													Computed:    true,
													Optional:    true,
													Description: `Only memory and CPU are supported. Use key 'cpu' for CPU limit and 'memory' for memory limit. Note: The only supported values for CPU are '1', '2', '4', and '8'. Setting 4 CPU requires at least 2Gi of memory. The values of the map is string form of the 'quantity' k8s type: https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go`,
													Elem:        &schema.Schema{Type: schema.TypeString},
												},
												"startup_cpu_boost": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `Determines whether CPU should be boosted on startup of a new container instance above the requested CPU threshold, this can help reduce cold-start latency.`,
												},
											},
										},
									},
									"startup_probe": {
										Type:        schema.TypeList,
										Computed:    true,
										Optional:    true,
										Description: `Startup probe of application within the container. All other probes are disabled if a startup probe is provided, until it succeeds. Container will not be added to service endpoints if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"failure_threshold": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.`,
													Default:     3,
												},
												"grpc": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `GRPC specifies an action involving a GRPC port.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"port": {
																Type:     schema.TypeInt,
																Computed: true,
																Optional: true,
																Description: `Port number to access on the container. Number must be in the range 1 to 65535.
If not specified, defaults to the same value as container.ports[0].containerPort.`,
															},
															"service": {
																Type:     schema.TypeString,
																Optional: true,
																Description: `The name of the service to place in the gRPC HealthCheckRequest
(see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
If this is not specified, the default behavior is defined by gRPC.`,
															},
														},
													},
												},
												"http_get": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `HTTPGet specifies the http request to perform. Exactly one of HTTPGet or TCPSocket must be specified.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"http_headers": {
																Type:        schema.TypeList,
																Optional:    true,
																Description: `Custom headers to set in the request. HTTP allows repeated headers.`,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"name": {
																			Type:        schema.TypeString,
																			Required:    true,
																			Description: `The header field name`,
																		},
																		"value": {
																			Type:        schema.TypeString,
																			Optional:    true,
																			Description: `The header field value`,
																			Default:     "",
																		},
																	},
																},
															},
															"path": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `Path to access on the HTTP server. Defaults to '/'.`,
																Default:     "/",
															},
															"port": {
																Type:     schema.TypeInt,
																Computed: true,
																Optional: true,
																Description: `Port number to access on the container. Must be in the range 1 to 65535.
If not specified, defaults to the same value as container.ports[0].containerPort.`,
															},
														},
													},
												},
												"initial_delay_seconds": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Number of seconds after the container has started before the probe is initiated. Defaults to 0 seconds. Minimum value is 0. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes`,
													Default:     0,
												},
												"period_seconds": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value for liveness probe is 3600. Maximum value for startup probe is 240. Must be greater or equal than timeoutSeconds`,
													Default:     10,
												},
												"tcp_socket": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `TCPSocket specifies an action involving a TCP port. Exactly one of HTTPGet or TCPSocket must be specified.`,
													MaxItems:    1,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"port": {
																Type:     schema.TypeInt,
																Computed: true,
																Optional: true,
																Description: `Port number to access on the container. Must be in the range 1 to 65535.
If not specified, defaults to the same value as container.ports[0].containerPort.`,
															},
														},
													},
												},
												"timeout_seconds": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 3600. Must be smaller than periodSeconds. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes`,
													Default:     1,
												},
											},
										},
									},
									"volume_mounts": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Volume to mount into the container's filesystem.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"mount_path": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Path within the container at which the volume should be mounted. Must not contain ':'. For Cloud SQL volumes, it can be left empty, or must otherwise be /cloudsql. All instances defined in the Volume will be available as /cloudsql/[instance]. For more information on Cloud SQL volumes, visit https://cloud.google.com/sql/docs/mysql/connect-run`,
												},
												"name": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `This must match the Name of a Volume.`,
												},
											},
										},
									},
									"working_dir": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image.`,
									},
								},
							},
						},
						"encryption_key": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `A reference to a customer managed encryption key (CMEK) to use to encrypt this container image. For more information, go to https://cloud.google.com/run/docs/securing/using-cmek`,
						},
						"execution_environment": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"EXECUTION_ENVIRONMENT_GEN1", "EXECUTION_ENVIRONMENT_GEN2", ""}),
							Description:  `The sandbox environment to host this Revision. Possible values: ["EXECUTION_ENVIRONMENT_GEN1", "EXECUTION_ENVIRONMENT_GEN2"]`,
						},
						"labels": {
							Type:     schema.TypeMap,
							Optional: true,
							Description: `Unstructured key value map that can be used to organize and categorize objects. User-provided labels are shared with Google's billing system, so they can be used to filter, or break down billing charges by team, component, environment, state, etc.
For more information, visit https://cloud.google.com/resource-manager/docs/creating-managing-labels or https://cloud.google.com/run/docs/configuring/labels.

Cloud Run API v2 does not support labels with 'run.googleapis.com', 'cloud.googleapis.com', 'serving.knative.dev', or 'autoscaling.knative.dev' namespaces, and they will be rejected.
All system labels in v1 now have a corresponding field in v2 RevisionTemplate.`,
							Elem: &schema.Schema{Type: schema.TypeString},
						},
						"max_instance_request_concurrency": {
							Type:        schema.TypeInt,
							Computed:    true,
							Optional:    true,
							Description: `Sets the maximum number of requests that each serving instance can receive.`,
						},
						"revision": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The unique name for the revision. If this field is omitted, it will be automatically generated based on the Service name.`,
						},
						"scaling": {
							Type:        schema.TypeList,
							Computed:    true,
							Optional:    true,
							Description: `Scaling settings for this Revision.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"max_instance_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Maximum number of serving instances that this resource should have.`,
									},
									"min_instance_count": {
										Type:        schema.TypeInt,
										Optional:    true,
										Description: `Minimum number of serving instances that this resource should have.`,
									},
								},
							},
						},
						"service_account": {
							Type:        schema.TypeString,
							Computed:    true,
							Optional:    true,
							Description: `Email address of the IAM service account associated with the revision of the service. The service account represents the identity of the running revision, and determines what permissions the revision has. If not provided, the revision will use the project's default service account.`,
						},
						"session_affinity": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `Enables session affinity. For more information, go to https://cloud.google.com/run/docs/configuring/session-affinity`,
						},
						"timeout": {
							Type:     schema.TypeString,
							Computed: true,
							Optional: true,
							Description: `Max allowed time for an instance to respond to a request.

A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".`,
						},
						"volumes": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `A list of Volumes to make available to containers.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: `Volume's name.`,
									},
									"cloud_sql_instance": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `For Cloud SQL volumes, contains the specific instances that should be mounted. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"instances": {
													Type:        schema.TypeSet,
													Optional:    true,
													Description: `The Cloud SQL instance connection names, as can be found in https://console.cloud.google.com/sql/instances. Visit https://cloud.google.com/sql/docs/mysql/connect-run for more information on how to connect Cloud SQL and Cloud Run. Format: {project}:{location}:{instance}`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
													Set: schema.HashString,
												},
											},
										},
									},
									"empty_dir": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Ephemeral storage used as a shared volume.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"medium": {
													Type:         schema.TypeString,
													Optional:     true,
													ValidateFunc: verify.ValidateEnum([]string{"MEMORY", ""}),
													Description:  `The different types of medium supported for EmptyDir. Default value: "MEMORY" Possible values: ["MEMORY"]`,
													Default:      "MEMORY",
												},
												"size_limit": {
													Type:        schema.TypeString,
													Optional:    true,
													Description: `Limit on the storage usable by this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. This field's values are of the 'Quantity' k8s type: https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir.`,
												},
											},
										},
									},
									"gcs": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Represents a GCS Bucket mounted as a volume.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"bucket": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `GCS Bucket name`,
												},
												"read_only": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `If true, mount the GCS bucket as read-only`,
												},
											},
										},
									},
									"nfs": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Represents an NFS mount.`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"path": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Path that is exported by the NFS server.`,
												},
												"server": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `Hostname or IP address of the NFS server`,
												},
												"read_only": {
													Type:        schema.TypeBool,
													Optional:    true,
													Description: `If true, mount the NFS volume as read only`,
												},
											},
										},
									},
									"secret": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret`,
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"secret": {
													Type:        schema.TypeString,
													Required:    true,
													Description: `The name of the secret in Cloud Secret Manager. Format: {secret} if the secret is in the same project. projects/{project}/secrets/{secret} if the secret is in a different project.`,
												},
												"default_mode": {
													Type:        schema.TypeInt,
													Optional:    true,
													Description: `Integer representation of mode bits to use on created files by default. Must be a value between 0000 and 0777 (octal), defaulting to 0444. Directories within the path are not affected by this setting.`,
												},
												"items": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `If unspecified, the volume will expose a file whose name is the secret, relative to VolumeMount.mount_path. If specified, the key will be used as the version to fetch from Cloud Secret Manager and the path will be the name of the file exposed in the volume. When items are defined, they must specify a path and a version.`,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"path": {
																Type:        schema.TypeString,
																Required:    true,
																Description: `The relative path of the secret in the container.`,
															},
															"mode": {
																Type:        schema.TypeInt,
																Optional:    true,
																Description: `Integer octal mode bits to use on this file, must be a value between 01 and 0777 (octal). If 0 or not set, the Volume's default mode will be used.`,
															},
															"version": {
																Type:        schema.TypeString,
																Optional:    true,
																Description: `The Cloud Secret Manager secret version. Can be 'latest' for the latest value or an integer for a specific version`,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"vpc_access": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `VPC Access configuration to use for this Task. For more information, visit https://cloud.google.com/run/docs/configuring/connecting-vpc.`,
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"connector": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `VPC Access connector name. Format: projects/{project}/locations/{location}/connectors/{connector}, where {project} can be project id or number.`,
									},
									"egress": {
										Type:         schema.TypeString,
										Computed:     true,
										Optional:     true,
										ValidateFunc: verify.ValidateEnum([]string{"ALL_TRAFFIC", "PRIVATE_RANGES_ONLY", ""}),
										Description:  `Traffic VPC egress settings. Possible values: ["ALL_TRAFFIC", "PRIVATE_RANGES_ONLY"]`,
									},
									"network_interfaces": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: `Direct VPC egress settings. Currently only single network interface is supported.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"network": {
													Type:     schema.TypeString,
													Computed: true,
													Optional: true,
													Description: `The VPC network that the Cloud Run resource will be able to send traffic to. At least one of network or subnetwork must be specified. If both
network and subnetwork are specified, the given VPC subnetwork must belong to the given VPC network. If network is not specified, it will be
looked up from the subnetwork.`,
												},
												"subnetwork": {
													Type:     schema.TypeString,
													Computed: true,
													Optional: true,
													Description: `The VPC subnetwork that the Cloud Run resource will get IPs from. At least one of network or subnetwork must be specified. If both
network and subnetwork are specified, the given VPC subnetwork must belong to the given VPC network. If subnetwork is not specified, the
subnetwork with the same name with the network will be used.`,
												},
												"tags": {
													Type:        schema.TypeList,
													Optional:    true,
													Description: `Network tags applied to this Cloud Run service.`,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"annotations": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Unstructured key value map that may be set by external tools to store and arbitrary metadata. They are not queryable and should be preserved when modifying objects.

Cloud Run API v2 does not support annotations with 'run.googleapis.com', 'cloud.googleapis.com', 'serving.knative.dev', or 'autoscaling.knative.dev' namespaces, and they will be rejected in new resources.
All system annotations in v1 now have a corresponding field in v2 Service.

This field follows Kubernetes annotations' namespacing, limits, and rules.

**Note**: This field is non-authoritative, and will only manage the annotations present in your configuration.
Please refer to the field 'effective_annotations' for all of the annotations present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"binary_authorization": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Settings for the Binary Authorization feature.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"breakglass_justification": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `If present, indicates to use Breakglass using this justification. If useDefault is False, then it must be empty. For more information on breakglass, see https://cloud.google.com/binary-authorization/docs/using-breakglass`,
						},
						"use_default": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: `If True, indicates to use the default project's binary authorization policy. If False, binary authorization will be disabled.`,
						},
					},
				},
			},
			"client": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Arbitrary identifier for the API client.`,
			},
			"client_version": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Arbitrary version identifier for the API client.`,
			},
			"custom_audiences": {
				Type:     schema.TypeList,
				Optional: true,
				Description: `One or more custom audiences that you want this service to support. Specify each custom audience as the full URL in a string. The custom audiences are encoded in the token and used to authenticate requests.
For more information, see https://cloud.google.com/run/docs/configuring/custom-audiences.`,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `User-provided description of the Service. This field currently has a 512-character limit.`,
			},
			"ingress": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"INGRESS_TRAFFIC_ALL", "INGRESS_TRAFFIC_INTERNAL_ONLY", "INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER", ""}),
				Description:  `Provides the ingress settings for this Service. On output, returns the currently observed ingress settings, or INGRESS_TRAFFIC_UNSPECIFIED if no revision is active. Possible values: ["INGRESS_TRAFFIC_ALL", "INGRESS_TRAFFIC_INTERNAL_ONLY", "INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER"]`,
			},
			"labels": {
				Type:     schema.TypeMap,
				Optional: true,
				Description: `Unstructured key value map that can be used to organize and categorize objects. User-provided labels are shared with Google's billing system, so they can be used to filter, or break down billing charges by team, component,
environment, state, etc. For more information, visit https://cloud.google.com/resource-manager/docs/creating-managing-labels or https://cloud.google.com/run/docs/configuring/labels.

Cloud Run API v2 does not support labels with  'run.googleapis.com', 'cloud.googleapis.com', 'serving.knative.dev', or 'autoscaling.knative.dev' namespaces, and they will be rejected.
All system labels in v1 now have a corresponding field in v2 Service.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field 'effective_labels' for all of the labels present on the resource.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"launch_stage": {
				Type:         schema.TypeString,
				Computed:     true,
				Optional:     true,
				ValidateFunc: verify.ValidateEnum([]string{"UNIMPLEMENTED", "PRELAUNCH", "EARLY_ACCESS", "ALPHA", "BETA", "GA", "DEPRECATED", ""}),
				Description: `The launch stage as defined by [Google Cloud Platform Launch Stages](https://cloud.google.com/products#product-launch-stages). Cloud Run supports ALPHA, BETA, and GA.
If no value is specified, GA is assumed. Set the launch stage to a preview stage on input to allow use of preview features in that stage. On read (or output), describes whether the resource uses preview features.

For example, if ALPHA is provided as input, but only BETA and GA-level features are used, this field will be BETA on output. Possible values: ["UNIMPLEMENTED", "PRELAUNCH", "EARLY_ACCESS", "ALPHA", "BETA", "GA", "DEPRECATED"]`,
			},
			"traffic": {
				Type:        schema.TypeList,
				Computed:    true,
				Optional:    true,
				Description: `Specifies how to distribute traffic over a collection of Revisions belonging to the Service. If traffic is empty or not provided, defaults to 100% traffic to the latest Ready Revision.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"percent": {
							Type:        schema.TypeInt,
							Computed:    true,
							Optional:    true,
							Description: `Specifies percent of the traffic to this Revision. This defaults to zero if unspecified.`,
						},
						"revision": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Revision to which to send this portion of traffic, if traffic allocation is by revision.`,
						},
						"tag": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `Indicates a string to be part of the URI to exclusively reference this target.`,
						},
						"type": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: verify.ValidateEnum([]string{"TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST", "TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION", ""}),
							Description:  `The allocation type for this traffic target. Possible values: ["TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST", "TRAFFIC_TARGET_ALLOCATION_TYPE_REVISION"]`,
						},
					},
				},
			},
			"conditions": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The Conditions of all other associated sub-resources. They contain additional diagnostics information in case the Service does not reach its Serving state. See comments in reconciling for additional information on reconciliation process in Cloud Run.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"execution_reason": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `A reason for the execution condition.`,
						},
						"last_transition_time": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `Last time the condition transitioned from one status to another.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
						},
						"message": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Human readable message indicating details about the current status.`,
						},
						"reason": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `A common (service-level) reason for this condition.`,
						},
						"revision_reason": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `A reason for the revision condition.`,
						},
						"severity": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `How to interpret failures of this condition, one of Error, Warning, Info`,
						},
						"state": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `State of the condition.`,
						},
						"type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `type is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/main/docs/spec/errors.md#error-conditions-and-reporting Types common to all resources include: * "Ready": True when the Resource is ready.`,
						},
					},
				},
			},
			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The creation time.`,
			},
			"creator": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Email address of the authenticated creator.`,
			},
			"delete_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The deletion time.`,
			},
			"effective_annotations": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of annotations (key/value pairs) present on the resource in GCP, including the annotations configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"effective_labels": {
				Type:        schema.TypeMap,
				Computed:    true,
				Description: `All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.`,
				Elem:        &schema.Schema{Type: schema.TypeString},
			},
			"etag": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `A system-generated fingerprint for this version of the resource. May be used to detect modification conflict during updates.`,
			},
			"expire_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `For a deleted resource, the time after which it will be permamently deleted.`,
			},
			"generation": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `A number that monotonically increases every time the user modifies the desired state. Please note that unlike v1, this is an int64 value. As with most Google APIs, its JSON representation will be a string instead of an integer.`,
			},
			"last_modifier": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Email address of the last authenticated modifier.`,
			},
			"latest_created_revision": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Name of the last created revision. See comments in reconciling for additional information on reconciliation process in Cloud Run.`,
			},
			"latest_ready_revision": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Name of the latest revision that is serving traffic. See comments in reconciling for additional information on reconciliation process in Cloud Run.`,
			},
			"observed_generation": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The generation of this Service currently serving traffic. See comments in reconciling for additional information on reconciliation process in Cloud Run. Please note that unlike v1, this is an int64 value. As with most Google APIs, its JSON representation will be a string instead of an integer.`,
			},
			"reconciling": {
				Type:     schema.TypeBool,
				Computed: true,
				Description: `Returns true if the Service is currently being acted upon by the system to bring it into the desired state.

When a new Service is created, or an existing one is updated, Cloud Run will asynchronously perform all necessary steps to bring the Service to the desired serving state. This process is called reconciliation. While reconciliation is in process, observedGeneration, latest_ready_revison, trafficStatuses, and uri will have transient values that might mismatch the intended state: Once reconciliation is over (and this field is false), there are two possible outcomes: reconciliation succeeded and the serving state matches the Service, or there was an error, and reconciliation failed. This state can be found in terminalCondition.state.

If reconciliation succeeded, the following fields will match: traffic and trafficStatuses, observedGeneration and generation, latestReadyRevision and latestCreatedRevision.

If reconciliation failed, trafficStatuses, observedGeneration, and latestReadyRevision will have the state of the last serving revision, or empty for newly created Services. Additional information on the failure can be found in terminalCondition and conditions.`,
			},
			"terminal_condition": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The Condition of this Service, containing its readiness status, and detailed error information in case it did not reach a serving state. See comments in reconciling for additional information on reconciliation process in Cloud Run.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"execution_reason": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `A reason for the execution condition.`,
						},
						"last_transition_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Last time the condition transitioned from one status to another.`,
						},
						"message": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Human readable message indicating details about the current status.`,
						},
						"reason": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `A common (service-level) reason for this condition.`,
						},
						"revision_reason": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `A reason for the revision condition.`,
						},
						"severity": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `How to interpret failures of this condition, one of Error, Warning, Info`,
						},
						"state": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `State of the condition.`,
						},
						"type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `type is used to communicate the status of the reconciliation process. See also: https://github.com/knative/serving/blob/main/docs/spec/errors.md#error-conditions-and-reporting Types common to all resources include: * "Ready": True when the Resource is ready.`,
						},
					},
				},
			},
			"terraform_labels": {
				Type:     schema.TypeMap,
				Computed: true,
				Description: `The combination of labels configured directly on the resource
 and default labels configured on the provider.`,
				Elem: &schema.Schema{Type: schema.TypeString},
			},
			"traffic_statuses": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Detailed status information for corresponding traffic targets. See comments in reconciling for additional information on reconciliation process in Cloud Run.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"percent": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Specifies percent of the traffic to this Revision.`,
						},
						"revision": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Revision to which this traffic is sent.`,
						},
						"tag": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the string used in the URI to exclusively reference this target.`,
						},
						"type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The allocation type for this traffic target.`,
						},
						"uri": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Displays the target URI.`,
						},
					},
				},
			},
			"uid": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Server assigned unique identifier for the trigger. The value is a UUID4 string and guaranteed to remain unchanged until the resource is deleted.`,
			},
			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The last-modified time.`,
			},
			"uri": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The main URI in which this Service is serving traffic.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCloudRunV3ServiceCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	descriptionProp, err := expandCloudRunV3ServiceDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	clientProp, err := expandCloudRunV3ServiceClient(d.Get("client"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client"); !tpgresource.IsEmptyValue(reflect.ValueOf(clientProp)) && (ok || !reflect.DeepEqual(v, clientProp)) {
		obj["client"] = clientProp
	}
	clientVersionProp, err := expandCloudRunV3ServiceClientVersion(d.Get("client_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(clientVersionProp)) && (ok || !reflect.DeepEqual(v, clientVersionProp)) {
		obj["clientVersion"] = clientVersionProp
	}
	ingressProp, err := expandCloudRunV3ServiceIngress(d.Get("ingress"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ingress"); !tpgresource.IsEmptyValue(reflect.ValueOf(ingressProp)) && (ok || !reflect.DeepEqual(v, ingressProp)) {
		obj["ingress"] = ingressProp
	}
	launchStageProp, err := expandCloudRunV3ServiceLaunchStage(d.Get("launch_stage"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("launch_stage"); !tpgresource.IsEmptyValue(reflect.ValueOf(launchStageProp)) && (ok || !reflect.DeepEqual(v, launchStageProp)) {
		obj["launchStage"] = launchStageProp
	}
	binaryAuthorizationProp, err := expandCloudRunV3ServiceBinaryAuthorization(d.Get("binary_authorization"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("binary_authorization"); !tpgresource.IsEmptyValue(reflect.ValueOf(binaryAuthorizationProp)) && (ok || !reflect.DeepEqual(v, binaryAuthorizationProp)) {
		obj["binaryAuthorization"] = binaryAuthorizationProp
	}
	customAudiencesProp, err := expandCloudRunV3ServiceCustomAudiences(d.Get("custom_audiences"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("custom_audiences"); !tpgresource.IsEmptyValue(reflect.ValueOf(customAudiencesProp)) && (ok || !reflect.DeepEqual(v, customAudiencesProp)) {
		obj["customAudiences"] = customAudiencesProp
	}
	templateProp, err := expandCloudRunV3ServiceTemplate(d.Get("template"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("template"); !tpgresource.IsEmptyValue(reflect.ValueOf(templateProp)) && (ok || !reflect.DeepEqual(v, templateProp)) {
		obj["template"] = templateProp
	}
	trafficProp, err := expandCloudRunV3ServiceTraffic(d.Get("traffic"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("traffic"); !tpgresource.IsEmptyValue(reflect.ValueOf(trafficProp)) && (ok || !reflect.DeepEqual(v, trafficProp)) {
		obj["traffic"] = trafficProp
	}
	labelsProp, err := expandCloudRunV3ServiceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	annotationsProp, err := expandCloudRunV3ServiceEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(annotationsProp)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CloudRunV3BasePath}}projects/{{project}}/locations/{{location}}/services?serviceId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Service: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Service: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating Service: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/services/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Use the resource in the operation response to populate
	// identity fields and d.Id() before read
	var opRes map[string]interface{}
	err = CloudRunV3OperationWaitTimeWithResponse(
		config, res, &opRes, project, "Creating Service", userAgent,
		d.Timeout(schema.TimeoutCreate))
	if err != nil {
		// The resource didn't actually create
		d.SetId("")

		return fmt.Errorf("Error waiting to create Service: %s", err)
	}

	// This may have caused the ID to update - update it if so.
	id, err = tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/services/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating Service %q: %#v", d.Id(), res)

	return resourceCloudRunV3ServiceRead(d, meta)
}

func resourceCloudRunV3ServiceRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CloudRunV3BasePath}}projects/{{project}}/locations/{{location}}/services/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Service: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("CloudRunV3Service %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}

	if err := d.Set("description", flattenCloudRunV3ServiceDescription(res["description"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("uid", flattenCloudRunV3ServiceUid(res["uid"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("generation", flattenCloudRunV3ServiceGeneration(res["generation"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("labels", flattenCloudRunV3ServiceLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("annotations", flattenCloudRunV3ServiceAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("create_time", flattenCloudRunV3ServiceCreateTime(res["createTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("update_time", flattenCloudRunV3ServiceUpdateTime(res["updateTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("delete_time", flattenCloudRunV3ServiceDeleteTime(res["deleteTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("expire_time", flattenCloudRunV3ServiceExpireTime(res["expireTime"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("creator", flattenCloudRunV3ServiceCreator(res["creator"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("last_modifier", flattenCloudRunV3ServiceLastModifier(res["lastModifier"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("client", flattenCloudRunV3ServiceClient(res["client"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("client_version", flattenCloudRunV3ServiceClientVersion(res["clientVersion"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("ingress", flattenCloudRunV3ServiceIngress(res["ingress"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("launch_stage", flattenCloudRunV3ServiceLaunchStage(res["launchStage"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("binary_authorization", flattenCloudRunV3ServiceBinaryAuthorization(res["binaryAuthorization"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("custom_audiences", flattenCloudRunV3ServiceCustomAudiences(res["customAudiences"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("template", flattenCloudRunV3ServiceTemplate(res["template"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("traffic", flattenCloudRunV3ServiceTraffic(res["traffic"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("observed_generation", flattenCloudRunV3ServiceObservedGeneration(res["observedGeneration"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("terminal_condition", flattenCloudRunV3ServiceTerminalCondition(res["terminalCondition"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("conditions", flattenCloudRunV3ServiceConditions(res["conditions"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("latest_ready_revision", flattenCloudRunV3ServiceLatestReadyRevision(res["latestReadyRevision"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("latest_created_revision", flattenCloudRunV3ServiceLatestCreatedRevision(res["latestCreatedRevision"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("traffic_statuses", flattenCloudRunV3ServiceTrafficStatuses(res["trafficStatuses"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("uri", flattenCloudRunV3ServiceUri(res["uri"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("reconciling", flattenCloudRunV3ServiceReconciling(res["reconciling"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("etag", flattenCloudRunV3ServiceEtag(res["etag"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("terraform_labels", flattenCloudRunV3ServiceTerraformLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("effective_labels", flattenCloudRunV3ServiceEffectiveLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}
	if err := d.Set("effective_annotations", flattenCloudRunV3ServiceEffectiveAnnotations(res["annotations"], d, config)); err != nil {
		return fmt.Errorf("Error reading Service: %s", err)
	}

	return nil
}

func resourceCloudRunV3ServiceUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Service: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	descriptionProp, err := expandCloudRunV3ServiceDescription(d.Get("description"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	clientProp, err := expandCloudRunV3ServiceClient(d.Get("client"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, clientProp)) {
		obj["client"] = clientProp
	}
	clientVersionProp, err := expandCloudRunV3ServiceClientVersion(d.Get("client_version"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("client_version"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, clientVersionProp)) {
		obj["clientVersion"] = clientVersionProp
	}
	ingressProp, err := expandCloudRunV3ServiceIngress(d.Get("ingress"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("ingress"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, ingressProp)) {
		obj["ingress"] = ingressProp
	}
	launchStageProp, err := expandCloudRunV3ServiceLaunchStage(d.Get("launch_stage"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("launch_stage"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, launchStageProp)) {
		obj["launchStage"] = launchStageProp
	}
	binaryAuthorizationProp, err := expandCloudRunV3ServiceBinaryAuthorization(d.Get("binary_authorization"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("binary_authorization"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, binaryAuthorizationProp)) {
		obj["binaryAuthorization"] = binaryAuthorizationProp
	}
	customAudiencesProp, err := expandCloudRunV3ServiceCustomAudiences(d.Get("custom_audiences"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("custom_audiences"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, customAudiencesProp)) {
		obj["customAudiences"] = customAudiencesProp
	}
	templateProp, err := expandCloudRunV3ServiceTemplate(d.Get("template"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("template"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, templateProp)) {
		obj["template"] = templateProp
	}
	trafficProp, err := expandCloudRunV3ServiceTraffic(d.Get("traffic"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("traffic"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, trafficProp)) {
		obj["traffic"] = trafficProp
	}
	labelsProp, err := expandCloudRunV3ServiceEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	annotationsProp, err := expandCloudRunV3ServiceEffectiveAnnotations(d.Get("effective_annotations"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("effective_annotations"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, annotationsProp)) {
		obj["annotations"] = annotationsProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{CloudRunV3BasePath}}projects/{{project}}/locations/{{location}}/services/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Service %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
	})

	if err != nil {
		return fmt.Errorf("Error updating Service %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating Service %q: %#v", d.Id(), res)
	}

	err = CloudRunV3OperationWaitTime(
		config, res, project, "Updating Service", userAgent,
		d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return err
	}

	return resourceCloudRunV3ServiceRead(d, meta)
}

func resourceCloudRunV3ServiceDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Service: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{CloudRunV3BasePath}}projects/{{project}}/locations/{{location}}/services/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Service %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "Service")
	}

	err = CloudRunV3OperationWaitTime(
		config, res, project, "Deleting Service", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Service %q: %#v", d.Id(), res)
	return nil
}

func resourceCloudRunV3ServiceImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/services/(?P<name>[^/]+)$",
		"^(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)$",
		"^(?P<location>[^/]+)/(?P<name>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/services/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenCloudRunV3ServiceDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenCloudRunV3ServiceAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenCloudRunV3ServiceCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceDeleteTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceExpireTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceCreator(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceLastModifier(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceClient(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceClientVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceIngress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceLaunchStage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceBinaryAuthorization(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["breakglass_justification"] =
		flattenCloudRunV3ServiceBinaryAuthorizationBreakglassJustification(original["breakglassJustification"], d, config)
	transformed["use_default"] =
		flattenCloudRunV3ServiceBinaryAuthorizationUseDefault(original["useDefault"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceBinaryAuthorizationBreakglassJustification(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceBinaryAuthorizationUseDefault(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceCustomAudiences(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplate(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["revision"] =
		flattenCloudRunV3ServiceTemplateRevision(original["revision"], d, config)
	transformed["labels"] =
		flattenCloudRunV3ServiceTemplateLabels(original["labels"], d, config)
	transformed["annotations"] =
		flattenCloudRunV3ServiceTemplateAnnotations(original["annotations"], d, config)
	transformed["scaling"] =
		flattenCloudRunV3ServiceTemplateScaling(original["scaling"], d, config)
	transformed["vpc_access"] =
		flattenCloudRunV3ServiceTemplateVpcAccess(original["vpcAccess"], d, config)
	transformed["timeout"] =
		flattenCloudRunV3ServiceTemplateTimeout(original["timeout"], d, config)
	transformed["service_account"] =
		flattenCloudRunV3ServiceTemplateServiceAccount(original["serviceAccount"], d, config)
	transformed["containers"] =
		flattenCloudRunV3ServiceTemplateContainers(original["containers"], d, config)
	transformed["volumes"] =
		flattenCloudRunV3ServiceTemplateVolumes(original["volumes"], d, config)
	transformed["execution_environment"] =
		flattenCloudRunV3ServiceTemplateExecutionEnvironment(original["executionEnvironment"], d, config)
	transformed["encryption_key"] =
		flattenCloudRunV3ServiceTemplateEncryptionKey(original["encryptionKey"], d, config)
	transformed["max_instance_request_concurrency"] =
		flattenCloudRunV3ServiceTemplateMaxInstanceRequestConcurrency(original["maxInstanceRequestConcurrency"], d, config)
	transformed["session_affinity"] =
		flattenCloudRunV3ServiceTemplateSessionAffinity(original["sessionAffinity"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateRevision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateScaling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["min_instance_count"] =
		flattenCloudRunV3ServiceTemplateScalingMinInstanceCount(original["minInstanceCount"], d, config)
	transformed["max_instance_count"] =
		flattenCloudRunV3ServiceTemplateScalingMaxInstanceCount(original["maxInstanceCount"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateScalingMinInstanceCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateScalingMaxInstanceCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateVpcAccess(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["connector"] =
		flattenCloudRunV3ServiceTemplateVpcAccessConnector(original["connector"], d, config)
	transformed["egress"] =
		flattenCloudRunV3ServiceTemplateVpcAccessEgress(original["egress"], d, config)
	transformed["network_interfaces"] =
		flattenCloudRunV3ServiceTemplateVpcAccessNetworkInterfaces(original["networkInterfaces"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateVpcAccessConnector(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVpcAccessEgress(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVpcAccessNetworkInterfaces(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"network":    flattenCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesNetwork(original["network"], d, config),
			"subnetwork": flattenCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesSubnetwork(original["subnetwork"], d, config),
			"tags":       flattenCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesTags(original["tags"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesSubnetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesTags(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateTimeout(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainers(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":           flattenCloudRunV3ServiceTemplateContainersName(original["name"], d, config),
			"image":          flattenCloudRunV3ServiceTemplateContainersImage(original["image"], d, config),
			"command":        flattenCloudRunV3ServiceTemplateContainersCommand(original["command"], d, config),
			"args":           flattenCloudRunV3ServiceTemplateContainersArgs(original["args"], d, config),
			"env":            flattenCloudRunV3ServiceTemplateContainersEnv(original["env"], d, config),
			"resources":      flattenCloudRunV3ServiceTemplateContainersResources(original["resources"], d, config),
			"ports":          flattenCloudRunV3ServiceTemplateContainersPorts(original["ports"], d, config),
			"volume_mounts":  flattenCloudRunV3ServiceTemplateContainersVolumeMounts(original["volumeMounts"], d, config),
			"working_dir":    flattenCloudRunV3ServiceTemplateContainersWorkingDir(original["workingDir"], d, config),
			"liveness_probe": flattenCloudRunV3ServiceTemplateContainersLivenessProbe(original["livenessProbe"], d, config),
			"startup_probe":  flattenCloudRunV3ServiceTemplateContainersStartupProbe(original["startupProbe"], d, config),
			"depends_on":     flattenCloudRunV3ServiceTemplateContainersDependsOn(original["dependsOn"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateContainersName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersImage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersCommand(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersArgs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersEnv(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":         flattenCloudRunV3ServiceTemplateContainersEnvName(original["name"], d, config),
			"value":        flattenCloudRunV3ServiceTemplateContainersEnvValue(original["value"], d, config),
			"value_source": flattenCloudRunV3ServiceTemplateContainersEnvValueSource(original["valueSource"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateContainersEnvName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersEnvValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersEnvValueSource(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret_key_ref"] =
		flattenCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRef(original["secretKeyRef"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRef(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret"] =
		flattenCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRefSecret(original["secret"], d, config)
	transformed["version"] =
		flattenCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRefVersion(original["version"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRefSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRefVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersResources(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["limits"] =
		flattenCloudRunV3ServiceTemplateContainersResourcesLimits(original["limits"], d, config)
	transformed["cpu_idle"] =
		flattenCloudRunV3ServiceTemplateContainersResourcesCpuIdle(original["cpuIdle"], d, config)
	transformed["startup_cpu_boost"] =
		flattenCloudRunV3ServiceTemplateContainersResourcesStartupCpuBoost(original["startupCpuBoost"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersResourcesLimits(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersResourcesCpuIdle(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersResourcesStartupCpuBoost(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersPorts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":           flattenCloudRunV3ServiceTemplateContainersPortsName(original["name"], d, config),
			"container_port": flattenCloudRunV3ServiceTemplateContainersPortsContainerPort(original["containerPort"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateContainersPortsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersPortsContainerPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersVolumeMounts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":       flattenCloudRunV3ServiceTemplateContainersVolumeMountsName(original["name"], d, config),
			"mount_path": flattenCloudRunV3ServiceTemplateContainersVolumeMountsMountPath(original["mountPath"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateContainersVolumeMountsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersVolumeMountsMountPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersWorkingDir(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbe(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["initial_delay_seconds"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeInitialDelaySeconds(original["initialDelaySeconds"], d, config)
	transformed["timeout_seconds"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeTimeoutSeconds(original["timeoutSeconds"], d, config)
	transformed["period_seconds"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbePeriodSeconds(original["periodSeconds"], d, config)
	transformed["failure_threshold"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeFailureThreshold(original["failureThreshold"], d, config)
	transformed["http_get"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGet(original["httpGet"], d, config)
	transformed["grpc"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeGrpc(original["grpc"], d, config)
	transformed["tcp_socket"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeTcpSocket(original["tcpSocket"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersLivenessProbeInitialDelaySeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeTimeoutSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbePeriodSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeFailureThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["path"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetPath(original["path"], d, config)
	transformed["port"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetPort(original["port"], d, config)
	transformed["http_headers"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeaders(original["httpHeaders"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":  flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeadersName(original["name"], d, config),
			"value": flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeadersValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeadersName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeadersValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeGrpc(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["port"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeGrpcPort(original["port"], d, config)
	transformed["service"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeGrpcService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersLivenessProbeGrpcPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeGrpcService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersLivenessProbeTcpSocket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["port"] =
		flattenCloudRunV3ServiceTemplateContainersLivenessProbeTcpSocketPort(original["port"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersLivenessProbeTcpSocketPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbe(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["initial_delay_seconds"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeInitialDelaySeconds(original["initialDelaySeconds"], d, config)
	transformed["timeout_seconds"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeTimeoutSeconds(original["timeoutSeconds"], d, config)
	transformed["period_seconds"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbePeriodSeconds(original["periodSeconds"], d, config)
	transformed["failure_threshold"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeFailureThreshold(original["failureThreshold"], d, config)
	transformed["http_get"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGet(original["httpGet"], d, config)
	transformed["tcp_socket"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeTcpSocket(original["tcpSocket"], d, config)
	transformed["grpc"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeGrpc(original["grpc"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersStartupProbeInitialDelaySeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeTimeoutSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbePeriodSeconds(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeFailureThreshold(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["path"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetPath(original["path"], d, config)
	transformed["port"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetPort(original["port"], d, config)
	transformed["http_headers"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeaders(original["httpHeaders"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":  flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeadersName(original["name"], d, config),
			"value": flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeadersValue(original["value"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeadersName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeadersValue(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeTcpSocket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["port"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeTcpSocketPort(original["port"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersStartupProbeTcpSocketPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeGrpc(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["port"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeGrpcPort(original["port"], d, config)
	transformed["service"] =
		flattenCloudRunV3ServiceTemplateContainersStartupProbeGrpcService(original["service"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateContainersStartupProbeGrpcPort(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateContainersStartupProbeGrpcService(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateContainersDependsOn(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"name":               flattenCloudRunV3ServiceTemplateVolumesName(original["name"], d, config),
			"secret":             flattenCloudRunV3ServiceTemplateVolumesSecret(original["secret"], d, config),
			"cloud_sql_instance": flattenCloudRunV3ServiceTemplateVolumesCloudSqlInstance(original["cloudSqlInstance"], d, config),
			"empty_dir":          flattenCloudRunV3ServiceTemplateVolumesEmptyDir(original["emptyDir"], d, config),
			"gcs":                flattenCloudRunV3ServiceTemplateVolumesGcs(original["gcs"], d, config),
			"nfs":                flattenCloudRunV3ServiceTemplateVolumesNfs(original["nfs"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateVolumesName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["secret"] =
		flattenCloudRunV3ServiceTemplateVolumesSecretSecret(original["secret"], d, config)
	transformed["default_mode"] =
		flattenCloudRunV3ServiceTemplateVolumesSecretDefaultMode(original["defaultMode"], d, config)
	transformed["items"] =
		flattenCloudRunV3ServiceTemplateVolumesSecretItems(original["items"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateVolumesSecretSecret(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesSecretDefaultMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateVolumesSecretItems(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"path":    flattenCloudRunV3ServiceTemplateVolumesSecretItemsPath(original["path"], d, config),
			"version": flattenCloudRunV3ServiceTemplateVolumesSecretItemsVersion(original["version"], d, config),
			"mode":    flattenCloudRunV3ServiceTemplateVolumesSecretItemsMode(original["mode"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTemplateVolumesSecretItemsPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesSecretItemsVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesSecretItemsMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateVolumesCloudSqlInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["instances"] =
		flattenCloudRunV3ServiceTemplateVolumesCloudSqlInstanceInstances(original["instances"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateVolumesCloudSqlInstanceInstances(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return schema.NewSet(schema.HashString, v.([]interface{}))
}

func flattenCloudRunV3ServiceTemplateVolumesEmptyDir(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["medium"] =
		flattenCloudRunV3ServiceTemplateVolumesEmptyDirMedium(original["medium"], d, config)
	transformed["size_limit"] =
		flattenCloudRunV3ServiceTemplateVolumesEmptyDirSizeLimit(original["sizeLimit"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateVolumesEmptyDirMedium(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesEmptyDirSizeLimit(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesGcs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["bucket"] =
		flattenCloudRunV3ServiceTemplateVolumesGcsBucket(original["bucket"], d, config)
	transformed["read_only"] =
		flattenCloudRunV3ServiceTemplateVolumesGcsReadOnly(original["readOnly"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateVolumesGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesGcsReadOnly(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesNfs(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["server"] =
		flattenCloudRunV3ServiceTemplateVolumesNfsServer(original["server"], d, config)
	transformed["path"] =
		flattenCloudRunV3ServiceTemplateVolumesNfsPath(original["path"], d, config)
	transformed["read_only"] =
		flattenCloudRunV3ServiceTemplateVolumesNfsReadOnly(original["readOnly"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTemplateVolumesNfsServer(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesNfsPath(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateVolumesNfsReadOnly(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateExecutionEnvironment(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateEncryptionKey(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTemplateMaxInstanceRequestConcurrency(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTemplateSessionAffinity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTraffic(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenCloudRunV3ServiceTrafficType(original["type"], d, config),
			"revision": flattenCloudRunV3ServiceTrafficRevision(original["revision"], d, config),
			"percent":  flattenCloudRunV3ServiceTrafficPercent(original["percent"], d, config),
			"tag":      flattenCloudRunV3ServiceTrafficTag(original["tag"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTrafficType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTrafficRevision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTrafficPercent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTrafficTag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceObservedGeneration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerminalCondition(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["type"] =
		flattenCloudRunV3ServiceTerminalConditionType(original["type"], d, config)
	transformed["state"] =
		flattenCloudRunV3ServiceTerminalConditionState(original["state"], d, config)
	transformed["message"] =
		flattenCloudRunV3ServiceTerminalConditionMessage(original["message"], d, config)
	transformed["last_transition_time"] =
		flattenCloudRunV3ServiceTerminalConditionLastTransitionTime(original["lastTransitionTime"], d, config)
	transformed["severity"] =
		flattenCloudRunV3ServiceTerminalConditionSeverity(original["severity"], d, config)
	transformed["reason"] =
		flattenCloudRunV3ServiceTerminalConditionReason(original["reason"], d, config)
	transformed["revision_reason"] =
		flattenCloudRunV3ServiceTerminalConditionRevisionReason(original["revisionReason"], d, config)
	transformed["execution_reason"] =
		flattenCloudRunV3ServiceTerminalConditionExecutionReason(original["executionReason"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunV3ServiceTerminalConditionType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerminalConditionState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerminalConditionMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerminalConditionLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerminalConditionSeverity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerminalConditionReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerminalConditionRevisionReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerminalConditionExecutionReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceConditions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":                 flattenCloudRunV3ServiceConditionsType(original["type"], d, config),
			"state":                flattenCloudRunV3ServiceConditionsState(original["state"], d, config),
			"message":              flattenCloudRunV3ServiceConditionsMessage(original["message"], d, config),
			"last_transition_time": flattenCloudRunV3ServiceConditionsLastTransitionTime(original["lastTransitionTime"], d, config),
			"severity":             flattenCloudRunV3ServiceConditionsSeverity(original["severity"], d, config),
			"reason":               flattenCloudRunV3ServiceConditionsReason(original["reason"], d, config),
			"revision_reason":      flattenCloudRunV3ServiceConditionsRevisionReason(original["revisionReason"], d, config),
			"execution_reason":     flattenCloudRunV3ServiceConditionsExecutionReason(original["executionReason"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceConditionsType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceConditionsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceConditionsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceConditionsLastTransitionTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceConditionsSeverity(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceConditionsReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceConditionsRevisionReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceConditionsExecutionReason(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceLatestReadyRevision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceLatestCreatedRevision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTrafficStatuses(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"type":     flattenCloudRunV3ServiceTrafficStatusesType(original["type"], d, config),
			"revision": flattenCloudRunV3ServiceTrafficStatusesRevision(original["revision"], d, config),
			"percent":  flattenCloudRunV3ServiceTrafficStatusesPercent(original["percent"], d, config),
			"tag":      flattenCloudRunV3ServiceTrafficStatusesTag(original["tag"], d, config),
			"uri":      flattenCloudRunV3ServiceTrafficStatusesUri(original["uri"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunV3ServiceTrafficStatusesType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTrafficStatusesRevision(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTrafficStatusesPercent(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunV3ServiceTrafficStatusesTag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTrafficStatusesUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceEtag(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenCloudRunV3ServiceEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudRunV3ServiceEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandCloudRunV3ServiceDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceClient(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceClientVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceIngress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceLaunchStage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceBinaryAuthorization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBreakglassJustification, err := expandCloudRunV3ServiceBinaryAuthorizationBreakglassJustification(original["breakglass_justification"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBreakglassJustification); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["breakglassJustification"] = transformedBreakglassJustification
	}

	transformedUseDefault, err := expandCloudRunV3ServiceBinaryAuthorizationUseDefault(original["use_default"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUseDefault); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["useDefault"] = transformedUseDefault
	}

	return transformed, nil
}

func expandCloudRunV3ServiceBinaryAuthorizationBreakglassJustification(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceBinaryAuthorizationUseDefault(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceCustomAudiences(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplate(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedRevision, err := expandCloudRunV3ServiceTemplateRevision(original["revision"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRevision); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["revision"] = transformedRevision
	}

	transformedLabels, err := expandCloudRunV3ServiceTemplateLabels(original["labels"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLabels); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["labels"] = transformedLabels
	}

	transformedAnnotations, err := expandCloudRunV3ServiceTemplateAnnotations(original["annotations"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAnnotations); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["annotations"] = transformedAnnotations
	}

	transformedScaling, err := expandCloudRunV3ServiceTemplateScaling(original["scaling"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedScaling); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["scaling"] = transformedScaling
	}

	transformedVpcAccess, err := expandCloudRunV3ServiceTemplateVpcAccess(original["vpc_access"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVpcAccess); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["vpcAccess"] = transformedVpcAccess
	}

	transformedTimeout, err := expandCloudRunV3ServiceTemplateTimeout(original["timeout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeout"] = transformedTimeout
	}

	transformedServiceAccount, err := expandCloudRunV3ServiceTemplateServiceAccount(original["service_account"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServiceAccount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["serviceAccount"] = transformedServiceAccount
	}

	transformedContainers, err := expandCloudRunV3ServiceTemplateContainers(original["containers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContainers); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["containers"] = transformedContainers
	}

	transformedVolumes, err := expandCloudRunV3ServiceTemplateVolumes(original["volumes"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVolumes); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["volumes"] = transformedVolumes
	}

	transformedExecutionEnvironment, err := expandCloudRunV3ServiceTemplateExecutionEnvironment(original["execution_environment"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExecutionEnvironment); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["executionEnvironment"] = transformedExecutionEnvironment
	}

	transformedEncryptionKey, err := expandCloudRunV3ServiceTemplateEncryptionKey(original["encryption_key"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEncryptionKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["encryptionKey"] = transformedEncryptionKey
	}

	transformedMaxInstanceRequestConcurrency, err := expandCloudRunV3ServiceTemplateMaxInstanceRequestConcurrency(original["max_instance_request_concurrency"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxInstanceRequestConcurrency); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxInstanceRequestConcurrency"] = transformedMaxInstanceRequestConcurrency
	}

	transformedSessionAffinity, err := expandCloudRunV3ServiceTemplateSessionAffinity(original["session_affinity"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSessionAffinity); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sessionAffinity"] = transformedSessionAffinity
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateRevision(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunV3ServiceTemplateAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunV3ServiceTemplateScaling(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMinInstanceCount, err := expandCloudRunV3ServiceTemplateScalingMinInstanceCount(original["min_instance_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinInstanceCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minInstanceCount"] = transformedMinInstanceCount
	}

	transformedMaxInstanceCount, err := expandCloudRunV3ServiceTemplateScalingMaxInstanceCount(original["max_instance_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxInstanceCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxInstanceCount"] = transformedMaxInstanceCount
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateScalingMinInstanceCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateScalingMaxInstanceCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVpcAccess(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedConnector, err := expandCloudRunV3ServiceTemplateVpcAccessConnector(original["connector"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConnector); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["connector"] = transformedConnector
	}

	transformedEgress, err := expandCloudRunV3ServiceTemplateVpcAccessEgress(original["egress"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEgress); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["egress"] = transformedEgress
	}

	transformedNetworkInterfaces, err := expandCloudRunV3ServiceTemplateVpcAccessNetworkInterfaces(original["network_interfaces"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNetworkInterfaces); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["networkInterfaces"] = transformedNetworkInterfaces
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateVpcAccessConnector(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVpcAccessEgress(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVpcAccessNetworkInterfaces(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedNetwork, err := expandCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesNetwork(original["network"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["network"] = transformedNetwork
		}

		transformedSubnetwork, err := expandCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesSubnetwork(original["subnetwork"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSubnetwork); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["subnetwork"] = transformedSubnetwork
		}

		transformedTags, err := expandCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesTags(original["tags"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTags); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["tags"] = transformedTags
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesSubnetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVpcAccessNetworkInterfacesTags(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateTimeout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainers(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunV3ServiceTemplateContainersName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedImage, err := expandCloudRunV3ServiceTemplateContainersImage(original["image"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedImage); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["image"] = transformedImage
		}

		transformedCommand, err := expandCloudRunV3ServiceTemplateContainersCommand(original["command"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["command"] = transformedCommand
		}

		transformedArgs, err := expandCloudRunV3ServiceTemplateContainersArgs(original["args"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedArgs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["args"] = transformedArgs
		}

		transformedEnv, err := expandCloudRunV3ServiceTemplateContainersEnv(original["env"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEnv); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["env"] = transformedEnv
		}

		transformedResources, err := expandCloudRunV3ServiceTemplateContainersResources(original["resources"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedResources); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["resources"] = transformedResources
		}

		transformedPorts, err := expandCloudRunV3ServiceTemplateContainersPorts(original["ports"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPorts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["ports"] = transformedPorts
		}

		transformedVolumeMounts, err := expandCloudRunV3ServiceTemplateContainersVolumeMounts(original["volume_mounts"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVolumeMounts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["volumeMounts"] = transformedVolumeMounts
		}

		transformedWorkingDir, err := expandCloudRunV3ServiceTemplateContainersWorkingDir(original["working_dir"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedWorkingDir); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["workingDir"] = transformedWorkingDir
		}

		transformedLivenessProbe, err := expandCloudRunV3ServiceTemplateContainersLivenessProbe(original["liveness_probe"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedLivenessProbe); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["livenessProbe"] = transformedLivenessProbe
		}

		transformedStartupProbe, err := expandCloudRunV3ServiceTemplateContainersStartupProbe(original["startup_probe"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedStartupProbe); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["startupProbe"] = transformedStartupProbe
		}

		transformedDependsOn, err := expandCloudRunV3ServiceTemplateContainersDependsOn(original["depends_on"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDependsOn); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["dependsOn"] = transformedDependsOn
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateContainersName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersImage(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersCommand(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersArgs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersEnv(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunV3ServiceTemplateContainersEnvName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandCloudRunV3ServiceTemplateContainersEnvValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		transformedValueSource, err := expandCloudRunV3ServiceTemplateContainersEnvValueSource(original["value_source"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValueSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["valueSource"] = transformedValueSource
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateContainersEnvName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersEnvValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersEnvValueSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecretKeyRef, err := expandCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRef(original["secret_key_ref"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecretKeyRef); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secretKeyRef"] = transformedSecretKeyRef
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRef(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecret, err := expandCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRefSecret(original["secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secret"] = transformedSecret
	}

	transformedVersion, err := expandCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRefVersion(original["version"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["version"] = transformedVersion
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRefSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersEnvValueSourceSecretKeyRefVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersResources(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLimits, err := expandCloudRunV3ServiceTemplateContainersResourcesLimits(original["limits"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLimits); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["limits"] = transformedLimits
	}

	transformedCpuIdle, err := expandCloudRunV3ServiceTemplateContainersResourcesCpuIdle(original["cpu_idle"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCpuIdle); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["cpuIdle"] = transformedCpuIdle
	}

	transformedStartupCpuBoost, err := expandCloudRunV3ServiceTemplateContainersResourcesStartupCpuBoost(original["startup_cpu_boost"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartupCpuBoost); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startupCpuBoost"] = transformedStartupCpuBoost
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersResourcesLimits(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunV3ServiceTemplateContainersResourcesCpuIdle(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersResourcesStartupCpuBoost(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersPorts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunV3ServiceTemplateContainersPortsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedContainerPort, err := expandCloudRunV3ServiceTemplateContainersPortsContainerPort(original["container_port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainerPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["containerPort"] = transformedContainerPort
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateContainersPortsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersPortsContainerPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersVolumeMounts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunV3ServiceTemplateContainersVolumeMountsName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedMountPath, err := expandCloudRunV3ServiceTemplateContainersVolumeMountsMountPath(original["mount_path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMountPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["mountPath"] = transformedMountPath
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateContainersVolumeMountsName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersVolumeMountsMountPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersWorkingDir(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbe(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInitialDelaySeconds, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeInitialDelaySeconds(original["initial_delay_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInitialDelaySeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["initialDelaySeconds"] = transformedInitialDelaySeconds
	}

	transformedTimeoutSeconds, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedPeriodSeconds, err := expandCloudRunV3ServiceTemplateContainersLivenessProbePeriodSeconds(original["period_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeriodSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["periodSeconds"] = transformedPeriodSeconds
	}

	transformedFailureThreshold, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeFailureThreshold(original["failure_threshold"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFailureThreshold); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["failureThreshold"] = transformedFailureThreshold
	}

	transformedHttpGet, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGet(original["http_get"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["httpGet"] = transformedHttpGet
	}

	transformedGrpc, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeGrpc(original["grpc"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["grpc"] = transformedGrpc
	}

	transformedTcpSocket, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeTcpSocket(original["tcp_socket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTcpSocket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["tcpSocket"] = transformedTcpSocket
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeInitialDelaySeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeTimeoutSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbePeriodSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeFailureThreshold(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPath, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetPath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedPort, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetPort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedHttpHeaders, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeaders(original["http_headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHttpHeaders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["httpHeaders"] = transformedHttpHeaders
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeaders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeadersName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeadersValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeadersName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeHttpGetHttpHeadersValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeGrpc(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPort, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeGrpcPort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedService, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeGrpcService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["service"] = transformedService
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeGrpcPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeGrpcService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeTcpSocket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPort, err := expandCloudRunV3ServiceTemplateContainersLivenessProbeTcpSocketPort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersLivenessProbeTcpSocketPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbe(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInitialDelaySeconds, err := expandCloudRunV3ServiceTemplateContainersStartupProbeInitialDelaySeconds(original["initial_delay_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInitialDelaySeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["initialDelaySeconds"] = transformedInitialDelaySeconds
	}

	transformedTimeoutSeconds, err := expandCloudRunV3ServiceTemplateContainersStartupProbeTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedPeriodSeconds, err := expandCloudRunV3ServiceTemplateContainersStartupProbePeriodSeconds(original["period_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeriodSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["periodSeconds"] = transformedPeriodSeconds
	}

	transformedFailureThreshold, err := expandCloudRunV3ServiceTemplateContainersStartupProbeFailureThreshold(original["failure_threshold"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFailureThreshold); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["failureThreshold"] = transformedFailureThreshold
	}

	transformedHttpGet, err := expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGet(original["http_get"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["httpGet"] = transformedHttpGet
	}

	transformedTcpSocket, err := expandCloudRunV3ServiceTemplateContainersStartupProbeTcpSocket(original["tcp_socket"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["tcpSocket"] = transformedTcpSocket
	}

	transformedGrpc, err := expandCloudRunV3ServiceTemplateContainersStartupProbeGrpc(original["grpc"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["grpc"] = transformedGrpc
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeInitialDelaySeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeTimeoutSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbePeriodSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeFailureThreshold(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGet(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPath, err := expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetPath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedPort, err := expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetPort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedHttpHeaders, err := expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeaders(original["http_headers"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHttpHeaders); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["httpHeaders"] = transformedHttpHeaders
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeaders(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeadersName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeadersValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeadersName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeHttpGetHttpHeadersValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeTcpSocket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPort, err := expandCloudRunV3ServiceTemplateContainersStartupProbeTcpSocketPort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeTcpSocketPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeGrpc(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPort, err := expandCloudRunV3ServiceTemplateContainersStartupProbeGrpcPort(original["port"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["port"] = transformedPort
	}

	transformedService, err := expandCloudRunV3ServiceTemplateContainersStartupProbeGrpcService(original["service"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedService); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["service"] = transformedService
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeGrpcPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersStartupProbeGrpcService(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateContainersDependsOn(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumes(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandCloudRunV3ServiceTemplateVolumesName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedSecret, err := expandCloudRunV3ServiceTemplateVolumesSecret(original["secret"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["secret"] = transformedSecret
		}

		transformedCloudSqlInstance, err := expandCloudRunV3ServiceTemplateVolumesCloudSqlInstance(original["cloud_sql_instance"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedCloudSqlInstance); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["cloudSqlInstance"] = transformedCloudSqlInstance
		}

		transformedEmptyDir, err := expandCloudRunV3ServiceTemplateVolumesEmptyDir(original["empty_dir"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEmptyDir); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["emptyDir"] = transformedEmptyDir
		}

		transformedGcs, err := expandCloudRunV3ServiceTemplateVolumesGcs(original["gcs"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedGcs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["gcs"] = transformedGcs
		}

		transformedNfs, err := expandCloudRunV3ServiceTemplateVolumesNfs(original["nfs"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedNfs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["nfs"] = transformedNfs
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateVolumesName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedSecret, err := expandCloudRunV3ServiceTemplateVolumesSecretSecret(original["secret"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSecret); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["secret"] = transformedSecret
	}

	transformedDefaultMode, err := expandCloudRunV3ServiceTemplateVolumesSecretDefaultMode(original["default_mode"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDefaultMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["defaultMode"] = transformedDefaultMode
	}

	transformedItems, err := expandCloudRunV3ServiceTemplateVolumesSecretItems(original["items"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedItems); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["items"] = transformedItems
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateVolumesSecretSecret(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesSecretDefaultMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesSecretItems(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedPath, err := expandCloudRunV3ServiceTemplateVolumesSecretItemsPath(original["path"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["path"] = transformedPath
		}

		transformedVersion, err := expandCloudRunV3ServiceTemplateVolumesSecretItemsVersion(original["version"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["version"] = transformedVersion
		}

		transformedMode, err := expandCloudRunV3ServiceTemplateVolumesSecretItemsMode(original["mode"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedMode); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["mode"] = transformedMode
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTemplateVolumesSecretItemsPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesSecretItemsVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesSecretItemsMode(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesCloudSqlInstance(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstances, err := expandCloudRunV3ServiceTemplateVolumesCloudSqlInstanceInstances(original["instances"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstances); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instances"] = transformedInstances
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateVolumesCloudSqlInstanceInstances(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	v = v.(*schema.Set).List()
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesEmptyDir(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMedium, err := expandCloudRunV3ServiceTemplateVolumesEmptyDirMedium(original["medium"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMedium); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["medium"] = transformedMedium
	}

	transformedSizeLimit, err := expandCloudRunV3ServiceTemplateVolumesEmptyDirSizeLimit(original["size_limit"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSizeLimit); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sizeLimit"] = transformedSizeLimit
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateVolumesEmptyDirMedium(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesEmptyDirSizeLimit(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesGcs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedBucket, err := expandCloudRunV3ServiceTemplateVolumesGcsBucket(original["bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBucket); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["bucket"] = transformedBucket
	}

	transformedReadOnly, err := expandCloudRunV3ServiceTemplateVolumesGcsReadOnly(original["read_only"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReadOnly); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["readOnly"] = transformedReadOnly
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateVolumesGcsBucket(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesGcsReadOnly(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesNfs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedServer, err := expandCloudRunV3ServiceTemplateVolumesNfsServer(original["server"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedServer); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["server"] = transformedServer
	}

	transformedPath, err := expandCloudRunV3ServiceTemplateVolumesNfsPath(original["path"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPath); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["path"] = transformedPath
	}

	transformedReadOnly, err := expandCloudRunV3ServiceTemplateVolumesNfsReadOnly(original["read_only"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedReadOnly); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["readOnly"] = transformedReadOnly
	}

	return transformed, nil
}

func expandCloudRunV3ServiceTemplateVolumesNfsServer(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesNfsPath(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateVolumesNfsReadOnly(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateExecutionEnvironment(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateEncryptionKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateMaxInstanceRequestConcurrency(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTemplateSessionAffinity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTraffic(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedType, err := expandCloudRunV3ServiceTrafficType(original["type"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["type"] = transformedType
		}

		transformedRevision, err := expandCloudRunV3ServiceTrafficRevision(original["revision"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedRevision); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["revision"] = transformedRevision
		}

		transformedPercent, err := expandCloudRunV3ServiceTrafficPercent(original["percent"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedPercent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["percent"] = transformedPercent
		}

		transformedTag, err := expandCloudRunV3ServiceTrafficTag(original["tag"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedTag); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["tag"] = transformedTag
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandCloudRunV3ServiceTrafficType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTrafficRevision(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTrafficPercent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceTrafficTag(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandCloudRunV3ServiceEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandCloudRunV3ServiceEffectiveAnnotations(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
