// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package logging

import (
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

func ResourceLoggingProjectSettings() *schema.Resource {
	return &schema.Resource{
		Create: resourceLoggingProjectSettingsCreate,
		Read:   resourceLoggingProjectSettingsRead,
		Update: resourceLoggingProjectSettingsUpdate,
		Delete: resourceLoggingProjectSettingsDelete,

		Importer: &schema.ResourceImporter{
			State: resourceLoggingProjectSettingsImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		CustomizeDiff: customdiff.All(
			tpgresource.DefaultProviderProject,
		),

		Schema: map[string]*schema.Schema{
			"project": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The project for which to retrieve settings.`,
			},
			"kms_service_account_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				Description: `The service account that will be used by the Log Router to access your Cloud KMS key. This can be modified only once to migrate from the legacy CMEK service account to the logging service account as described in [Migrate CMEK SA](https://cloud.google.com/logging/docs/routing/troubleshoot-cmek-orgs#migrate-cmek-sa).`,
			},
			"disable_default_sink": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `If set to true, the _Default sink in newly created projects and folders will created in a disabled state. This can be used to automatically disable log storage if there is already an aggregated sink configured in the hierarchy. The _Default sink can be re-enabled manually if needed.`,
			},
			"kms_key_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource name for the configured Cloud KMS key.`,
			},
			"logging_service_account_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The service account for the given container. Sinks use this service account as their writerIdentity if no custom service account is provided.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource name of the settings.`,
			},
			"storage_location": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The storage location that Cloud Logging will use to create new resources when a location is needed but not explicitly provided.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceLoggingProjectSettingsCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	kmsServiceAccountIdProp, err := expandLoggingProjectSettingsKmsServiceAccountId(d.Get("kms_service_account_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("kms_service_account_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(kmsServiceAccountIdProp)) && (ok || !reflect.DeepEqual(v, kmsServiceAccountIdProp)) {
		obj["kmsServiceAccountId"] = kmsServiceAccountIdProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{LoggingBasePath}}projects/{{project}}/settings?updateMask=kmsServiceAccountId")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new ProjectSettings: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ProjectSettings: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating ProjectSettings: %s", err)
	}
	if err := d.Set("name", flattenLoggingProjectSettingsName(res["name"], d, config)); err != nil {
		return fmt.Errorf(`Error setting computed identity field "name": %s`, err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/settings")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	log.Printf("[DEBUG] Finished creating ProjectSettings %q: %#v", d.Id(), res)

	return resourceLoggingProjectSettingsRead(d, meta)
}

func resourceLoggingProjectSettingsRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{LoggingBasePath}}projects/{{project}}/settings")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ProjectSettings: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("LoggingProjectSettings %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading ProjectSettings: %s", err)
	}

	if err := d.Set("name", flattenLoggingProjectSettingsName(res["name"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectSettings: %s", err)
	}
	if err := d.Set("kms_key_name", flattenLoggingProjectSettingsKmsKeyName(res["kmsKeyName"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectSettings: %s", err)
	}
	if err := d.Set("kms_service_account_id", flattenLoggingProjectSettingsKmsServiceAccountId(res["kmsServiceAccountId"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectSettings: %s", err)
	}
	if err := d.Set("storage_location", flattenLoggingProjectSettingsStorageLocation(res["storageLocation"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectSettings: %s", err)
	}
	if err := d.Set("disable_default_sink", flattenLoggingProjectSettingsDisableDefaultSink(res["disableDefaultSink"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectSettings: %s", err)
	}
	if err := d.Set("logging_service_account_id", flattenLoggingProjectSettingsLoggingServiceAccountId(res["loggingServiceAccountId"], d, config)); err != nil {
		return fmt.Errorf("Error reading ProjectSettings: %s", err)
	}

	return nil
}

func resourceLoggingProjectSettingsUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for ProjectSettings: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})
	kmsServiceAccountIdProp, err := expandLoggingProjectSettingsKmsServiceAccountId(d.Get("kms_service_account_id"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("kms_service_account_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, kmsServiceAccountIdProp)) {
		obj["kmsServiceAccountId"] = kmsServiceAccountIdProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{LoggingBasePath}}projects/{{project}}/settings?updateMask=kmsServiceAccountId")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating ProjectSettings %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "PATCH",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutUpdate),
	})

	if err != nil {
		return fmt.Errorf("Error updating ProjectSettings %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating ProjectSettings %q: %#v", d.Id(), res)
	}

	return resourceLoggingProjectSettingsRead(d, meta)
}

func resourceLoggingProjectSettingsDelete(d *schema.ResourceData, meta interface{}) error {
	log.Printf("[WARNING] Logging ProjectSettings resources"+
		" cannot be deleted from Google Cloud. The resource %s will be removed from Terraform"+
		" state, but will still be present on Google Cloud.", d.Id())
	d.SetId("")

	return nil
}

func resourceLoggingProjectSettingsImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"^projects/(?P<project>[^/]+)/settings$",
		"^(?P<project>[^/]+)$",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/settings")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenLoggingProjectSettingsName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenLoggingProjectSettingsKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenLoggingProjectSettingsKmsServiceAccountId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenLoggingProjectSettingsStorageLocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenLoggingProjectSettingsDisableDefaultSink(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenLoggingProjectSettingsLoggingServiceAccountId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandLoggingProjectSettingsKmsServiceAccountId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
