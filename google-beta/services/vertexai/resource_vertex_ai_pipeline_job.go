// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package vertexai

import (
	"fmt"
	"log"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/verify"
)

var vertexAIPipelineJobGoogleProvidedLabels = []string{
	"vertex-ai-pipelines-run-billing-id",
}

func VertexAIPipelineJobLabelDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the labels provided by Google
	for _, label := range vertexAIPipelineJobGoogleProvidedLabels {
		if strings.Contains(k, label) && new == "" {
			return true
		}
	}

	// Let diff be determined by labels (above)
	if strings.Contains(k, "labels.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

func waitForVertexAIPipelineJobReady(d *schema.ResourceData, config *transport_tpg.Config, timeout time.Duration) error {
	return resource.Retry(timeout, func() *resource.RetryError {
		if err := resourceVertexAIPipelineJobRead(d, config); err != nil {
			return resource.NonRetryableError(err)
		}

		name := d.Get("name").(string)
		state := d.Get("state").(string)
		if state == "PIPELINE_STATE_QUEUED" || state == "PIPELINE_STATE_PENDING" || state == "PIPELINE_STATE_CANCELLING" {
			return resource.RetryableError(fmt.Errorf("VertexAIPipelineJob %q has state %q.", name, state))
		} else if state == "PIPELINE_STATE_SUCCEEDED" || state == "PIPELINE_STATE_RUNNING" {
			log.Printf("[DEBUG] VertexAIPipelineJob %q has state %q.", name, state)
			return nil
		} else {
			return resource.NonRetryableError(fmt.Errorf("VertexAIPipelineJob %q has state %q.", name, state))
		}
	})
}

func waitForVertexAIPipelineJobReadyForDeletion(d *schema.ResourceData, config *transport_tpg.Config, timeout time.Duration) error {
	return resource.Retry(timeout, func() *resource.RetryError {
		if err := resourceVertexAIPipelineJobRead(d, config); err != nil {
			return resource.NonRetryableError(err)
		}

		name := d.Get("name").(string)
		state := d.Get("state").(string)
		if state == "PIPELINE_STATE_RUNNING" || state == "PIPELINE_STATE_PENDING" || state == "PIPELINE_STATE_CANCELLING" {
			return resource.RetryableError(fmt.Errorf("VertexAIPipelineJob %q has state %q.", name, state))
		} else {
			log.Printf("[DEBUG] VertexAIPipelineJob %q has state %q.", name, state)
			return nil
		}
	})
}

func ResourceVertexAIPipelineJob() *schema.Resource {
	return &schema.Resource{
		Create: resourceVertexAIPipelineJobCreate,
		Read:   resourceVertexAIPipelineJobRead,
		Delete: resourceVertexAIPipelineJobDelete,

		Importer: &schema.ResourceImporter{
			State: resourceVertexAIPipelineJobImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location for the resource.`,
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The resource name of the Pipeline. This value should be less than 128 characters, and valid characters are /[a-z][0-9]-/`,
			},
			"display_name": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `The display name of the Pipeline. The name can be up to 128 characters long and can consist of any UTF-8 characters.`,
			},
			"encryption_spec": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Customer-managed encryption key spec for a pipelineJob. If set, this PipelineJob and all of its sub-resources will be secured by this key.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"kms_key_name": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key. The key needs to be in the same region as where the compute resource is created.`,
						},
					},
				},
			},
			"labels": {
				Type:             schema.TypeMap,
				Optional:         true,
				ForceNew:         true,
				DiffSuppressFunc: VertexAIPipelineJobLabelDiffSuppress,
				Description:      `The labels with user-defined metadata to organize PipelineJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. Note there is some reserved label key for Vertex AI Pipelines. - vertex-ai-pipelines-run-billing-id, user set value will get overrided.`,
				Elem:             &schema.Schema{Type: schema.TypeString},
			},
			"network": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: `The full name of the Compute Engine network to which the Pipeline Job's workload should be peered. For example, projects/12345/global/networks/myVPC. Format is of the form projects/{project}/global/networks/{network}. Where {project} is a project number, as in 12345, and {network} is a network name.
Private services access must already be configured for the network. Pipeline job will apply the network configuration to the Google Cloud resources being launched, if applied, such as Vertex AI Training or Dataflow job. If left unspecified, the workload is not peered with any network.`,
			},
			"runtime_config": {
				Type:        schema.TypeList,
				Optional:    true,
				ForceNew:    true,
				Description: `Runtime config of the pipeline.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"gcs_output_directory": {
							Type:        schema.TypeString,
							Required:    true,
							ForceNew:    true,
							Description: `A path in a Cloud Storage bucket, which will be treated as the root output directory of the pipeline. It is used by the system to generate the paths of output artifacts. The artifact paths are generated with a sub-path pattern {job_id}/{taskId}/{output_key} under the specified output directory. The service account specified in this pipeline must have the storage.objects.get and storage.objects.create permissions for this bucket.`,
						},
						"failure_policy": {
							Type:         schema.TypeString,
							Optional:     true,
							ForceNew:     true,
							ValidateFunc: verify.ValidateEnum([]string{"PIPELINE_FAILURE_POLICY_FAIL_SLOW", "PIPELINE_FAILURE_POLICY_FAIL_FAST", ""}),
							Description:  `Represents the failure policy of a pipeline. Currently, the default of a pipeline is that the pipeline will continue to run until no more tasks can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks when a task has failed. Any scheduled tasks will continue to completion. Possible values: ["PIPELINE_FAILURE_POLICY_FAIL_SLOW", "PIPELINE_FAILURE_POLICY_FAIL_FAST"]`,
						},
						"input_artifacts": {
							Type:        schema.TypeSet,
							Optional:    true,
							ForceNew:    true,
							Description: `The runtime artifacts of the PipelineJob.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"artifact": {
										Type:     schema.TypeString,
										Required: true,
										ForceNew: true,
									},
									"version": {
										Type:        schema.TypeString,
										Optional:    true,
										ForceNew:    true,
										Description: `The type of an input artifact.`,
									},
								},
							},
						},
						"parameter_values": {
							Type:        schema.TypeMap,
							Optional:    true,
							ForceNew:    true,
							Description: `The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using PipelineJob.pipeline_spec.schema_version 2.1.0, such as pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.`,
							Elem:        &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"service_account": {
				Type:        schema.TypeString,
				Computed:    true,
				Optional:    true,
				ForceNew:    true,
				Description: `The service account that the pipeline workload runs as. If not specified, the Compute Engine default service account in the project will be used. See https://cloud.google.com/compute/docs/access/service-accounts#default_service_account Users starting the pipeline must have the iam.serviceAccounts.actAs permission on this service account.`,
			},
			"template_uri": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: `A template uri from where the PipelineJob.pipeline_spec, if empty, will be downloaded.`,
			},
			"schedule_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The schedule resource name. Only returned if the Pipeline is created by Schedule API.`,
			},
			"state": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The detailed state of the job.`,
			},
			"template_metadata": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Pipeline template metadata. Will fill up fields if PipelineJob.template_uri is from supported template registry.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The version_name in artifact registry. Will always be presented in output if the PipelineJob.template_uri is from supported template registry. Format is "sha256:abcdef123456...".`,
						},
					},
				},
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceVertexAIPipelineJobCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	displayNameProp, err := expandVertexAIPipelineJobDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	labelsProp, err := expandVertexAIPipelineJobLabels(d.Get("labels"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}
	runtimeConfigProp, err := expandVertexAIPipelineJobRuntimeConfig(d.Get("runtime_config"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("runtime_config"); !tpgresource.IsEmptyValue(reflect.ValueOf(runtimeConfigProp)) && (ok || !reflect.DeepEqual(v, runtimeConfigProp)) {
		obj["runtimeConfig"] = runtimeConfigProp
	}
	encryptionSpecProp, err := expandVertexAIPipelineJobEncryptionSpec(d.Get("encryption_spec"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("encryption_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(encryptionSpecProp)) && (ok || !reflect.DeepEqual(v, encryptionSpecProp)) {
		obj["encryptionSpec"] = encryptionSpecProp
	}
	serviceAccountProp, err := expandVertexAIPipelineJobServiceAccount(d.Get("service_account"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("service_account"); !tpgresource.IsEmptyValue(reflect.ValueOf(serviceAccountProp)) && (ok || !reflect.DeepEqual(v, serviceAccountProp)) {
		obj["serviceAccount"] = serviceAccountProp
	}
	networkProp, err := expandVertexAIPipelineJobNetwork(d.Get("network"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("network"); !tpgresource.IsEmptyValue(reflect.ValueOf(networkProp)) && (ok || !reflect.DeepEqual(v, networkProp)) {
		obj["network"] = networkProp
	}
	templateUriProp, err := expandVertexAIPipelineJobTemplateUri(d.Get("template_uri"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("template_uri"); !tpgresource.IsEmptyValue(reflect.ValueOf(templateUriProp)) && (ok || !reflect.DeepEqual(v, templateUriProp)) {
		obj["templateUri"] = templateUriProp
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{location}}/pipelineJobs?pipelineJobId={{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new PipelineJob: %#v", obj)
	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PipelineJob: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "POST",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutCreate),
	})
	if err != nil {
		return fmt.Errorf("Error creating PipelineJob: %s", err)
	}

	// Store the ID now
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/pipelineJobs/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	if err := waitForVertexAIPipelineJobReady(d, config, d.Timeout(schema.TimeoutCreate)-time.Minute); err != nil {
		return fmt.Errorf("Error waiting for VertexAIPipelineJob %q to be ready during creation: %q", d.Get("name").(string), err)
	}

	log.Printf("[DEBUG] Finished creating PipelineJob %q: %#v", d.Id(), res)

	return resourceVertexAIPipelineJobRead(d, meta)
}

func resourceVertexAIPipelineJobRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	url, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{location}}/pipelineJobs/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PipelineJob: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("VertexAIPipelineJob %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}

	if err := d.Set("display_name", flattenVertexAIPipelineJobDisplayName(res["displayName"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("state", flattenVertexAIPipelineJobState(res["state"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("labels", flattenVertexAIPipelineJobLabels(res["labels"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("runtime_config", flattenVertexAIPipelineJobRuntimeConfig(res["runtimeConfig"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("encryption_spec", flattenVertexAIPipelineJobEncryptionSpec(res["encryptionSpec"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("service_account", flattenVertexAIPipelineJobServiceAccount(res["serviceAccount"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("network", flattenVertexAIPipelineJobNetwork(res["network"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("template_uri", flattenVertexAIPipelineJobTemplateUri(res["templateUri"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("template_metadata", flattenVertexAIPipelineJobTemplateMetadata(res["templateMetadata"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}
	if err := d.Set("schedule_name", flattenVertexAIPipelineJobScheduleName(res["scheduleName"], d, config)); err != nil {
		return fmt.Errorf("Error reading PipelineJob: %s", err)
	}

	return nil
}

func resourceVertexAIPipelineJobDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*transport_tpg.Config)
	userAgent, err := tpgresource.GenerateUserAgentString(d, config.UserAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := tpgresource.GetProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for PipelineJob: %s", err)
	}
	billingProject = project

	url, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{location}}/pipelineJobs/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	getUrl, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{location}}/pipelineJobs/{{name}}")
	if err != nil {
		return err
	}

	getRes, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "GET",
		Project:   project,
		RawURL:    getUrl,
		UserAgent: userAgent,
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, fmt.Sprintf("VertexAIPipelineJob %q", d.Id()))
	}

	// VertexAIPipelineJob cannot be deleted when it's in progress
	if v := getRes["state"]; v == "PIPELINE_STATE_RUNNING" {
		cancelUrl, err := tpgresource.ReplaceVars(d, config, "{{VertexAIBasePath}}projects/{{project}}/locations/{{location}}/pipelineJobs/{{name}}:cancel")
		if err != nil {
			return err
		}
		var obj map[string]interface{}
		log.Printf("[DEBUG] Cancelling VertexAIPipelineJob %q: %#v", d.Id(), getRes)
		_, err = transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
			Config:    config,
			Method:    "POST",
			Project:   billingProject,
			RawURL:    cancelUrl,
			UserAgent: userAgent,
			Body:      obj,
			Timeout:   d.Timeout(schema.TimeoutDelete),
		})
		if err != nil {
			return fmt.Errorf("Error canceling VertexAIPipelineJob %q: %s", d.Id(), err)
		}
	}

	if err := waitForVertexAIPipelineJobReadyForDeletion(d, config, d.Timeout(schema.TimeoutDelete)-time.Minute); err != nil {
		return fmt.Errorf("Error waiting for VertexAIPipelineJob %q to be ready for deletion: %q", d.Get("name").(string), err)
	}
	log.Printf("[DEBUG] Deleting PipelineJob %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := tpgresource.GetBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := transport_tpg.SendRequest(transport_tpg.SendRequestOptions{
		Config:    config,
		Method:    "DELETE",
		Project:   billingProject,
		RawURL:    url,
		UserAgent: userAgent,
		Body:      obj,
		Timeout:   d.Timeout(schema.TimeoutDelete),
	})
	if err != nil {
		return transport_tpg.HandleNotFoundError(err, d, "PipelineJob")
	}

	err = VertexAIOperationWaitTime(
		config, res, project, "Deleting PipelineJob", userAgent,
		d.Timeout(schema.TimeoutDelete))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting PipelineJob %q: %#v", d.Id(), res)
	return nil
}

func resourceVertexAIPipelineJobImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*transport_tpg.Config)
	if err := tpgresource.ParseImportId([]string{
		"projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/pipelineJobs/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<location>[^/]+)/(?P<name>[^/]+)",
		"(?P<location>[^/]+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := tpgresource.ReplaceVars(d, config, "projects/{{project}}/locations/{{location}}/pipelineJobs/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	if err := waitForVertexAIPipelineJobReady(d, config, d.Timeout(schema.TimeoutCreate)-time.Minute); err != nil {
		return nil, fmt.Errorf("Error waiting for VertexAIPipelineJob %q to be ready during import: %q", d.Get("name").(string), err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenVertexAIPipelineJobDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobRuntimeConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["gcs_output_directory"] =
		flattenVertexAIPipelineJobRuntimeConfigGcsOutputDirectory(original["gcsOutputDirectory"], d, config)
	transformed["parameter_values"] =
		flattenVertexAIPipelineJobRuntimeConfigParameterValues(original["parameterValues"], d, config)
	transformed["failure_policy"] =
		flattenVertexAIPipelineJobRuntimeConfigFailurePolicy(original["failurePolicy"], d, config)
	transformed["input_artifacts"] =
		flattenVertexAIPipelineJobRuntimeConfigInputArtifacts(original["inputArtifacts"], d, config)
	return []interface{}{transformed}
}
func flattenVertexAIPipelineJobRuntimeConfigGcsOutputDirectory(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobRuntimeConfigParameterValues(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobRuntimeConfigFailurePolicy(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobRuntimeConfigInputArtifacts(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.(map[string]interface{})
	transformed := make([]interface{}, 0, len(l))
	for k, raw := range l {
		original := raw.(map[string]interface{})
		transformed = append(transformed, map[string]interface{}{
			"artifact": k,
			"version":  flattenVertexAIPipelineJobRuntimeConfigInputArtifactsVersion(original["version"], d, config),
		})
	}
	return transformed
}
func flattenVertexAIPipelineJobRuntimeConfigInputArtifactsVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobEncryptionSpec(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["kms_key_name"] =
		flattenVertexAIPipelineJobEncryptionSpecKmsKeyName(original["kmsKeyName"], d, config)
	return []interface{}{transformed}
}
func flattenVertexAIPipelineJobEncryptionSpecKmsKeyName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobTemplateUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobTemplateMetadata(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["version"] =
		flattenVertexAIPipelineJobTemplateMetadataVersion(original["version"], d, config)
	return []interface{}{transformed}
}
func flattenVertexAIPipelineJobTemplateMetadataVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenVertexAIPipelineJobScheduleName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func expandVertexAIPipelineJobDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIPipelineJobLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandVertexAIPipelineJobRuntimeConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedGcsOutputDirectory, err := expandVertexAIPipelineJobRuntimeConfigGcsOutputDirectory(original["gcs_output_directory"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcsOutputDirectory); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcsOutputDirectory"] = transformedGcsOutputDirectory
	}

	transformedParameterValues, err := expandVertexAIPipelineJobRuntimeConfigParameterValues(original["parameter_values"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParameterValues); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["parameterValues"] = transformedParameterValues
	}

	transformedFailurePolicy, err := expandVertexAIPipelineJobRuntimeConfigFailurePolicy(original["failure_policy"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFailurePolicy); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["failurePolicy"] = transformedFailurePolicy
	}

	transformedInputArtifacts, err := expandVertexAIPipelineJobRuntimeConfigInputArtifacts(original["input_artifacts"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputArtifacts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputArtifacts"] = transformedInputArtifacts
	}

	return transformed, nil
}

func expandVertexAIPipelineJobRuntimeConfigGcsOutputDirectory(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIPipelineJobRuntimeConfigParameterValues(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}

func expandVertexAIPipelineJobRuntimeConfigFailurePolicy(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIPipelineJobRuntimeConfigInputArtifacts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedVersion, err := expandVertexAIPipelineJobRuntimeConfigInputArtifactsVersion(original["version"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVersion); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["version"] = transformedVersion
		}

		transformedArtifact, err := tpgresource.ExpandString(original["artifact"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedArtifact] = transformed
	}
	return m, nil
}

func expandVertexAIPipelineJobRuntimeConfigInputArtifactsVersion(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIPipelineJobEncryptionSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKmsKeyName, err := expandVertexAIPipelineJobEncryptionSpecKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandVertexAIPipelineJobEncryptionSpecKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIPipelineJobServiceAccount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIPipelineJobNetwork(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIPipelineJobTemplateUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}
